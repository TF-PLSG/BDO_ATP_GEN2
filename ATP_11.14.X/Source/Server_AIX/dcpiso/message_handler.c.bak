/**************************************************************************************************
*  
* MODULE:      message_handler.c

  Copyright (c) 2008, Hypercom, Inc.
  All Rights Reserved.

* TITLE:       ATP Standard - Terminal Handler Main.
*  
* DESCRIPTION: Main startup and end process routines. Waits for incoming PTE message and 
*              passes control to message processing loop.  
*
* APPLICATION: DCPISO
*
* AUTHOR:  Unknown
*
   ----------------
   REVISION HISTORY
   ----------------

		Rev 1.95   Dec 16 2010  TF-Phani
		Updated version to 4.4.1.41
		DCPISO is crashing due to invalid DE60 and 63, Fixed while parsing the Mesg.
		Previous DCPISO version: 4.4.1.39, Increamented to 4.4.1.41. Since another release
		having OLD RRN format with version 4.4.1.40. This releas on NEW RRN FORMAT.

			Rev 1.94   Nov 11 2009  TF-Ajay
		Updated version to 4.4.1.34
		Changed code to set general staus, if original txn not found for void sale
		and reversal 


			Rev 1.93   May 25 2009  Nirbhay
		Updated version to 4.4.1.33
		Dcpiso version 4.4.1.32 - Duplicate settlement log changes.
		Successful settlement log will record Old (from dcf01) and new batch numbers.



	 Rev 1.92   Jan 09 2008  dirby
      Updated version to 4.4.1.29

      Changed the format of the RRN:
         from   YDDDhmmssjjj
         to     YDDDhhmmsscc, where cc is a counter from 00 to 99 

      Added a global counter to track cc. This counter is initialized
      at startup using the system time seconds value. This way, if there
      are multiple instances of txcntl running, the initial value in each
      instance will be different.

      The reason for this change is we were seeing duplicate RRNs when
      the time was 12 hours apart. Using only the last digit of the 24
      hour clock, (example: hour 20 and hour 10) the h value is zero in
      both cases and the millisecond (jjj) just happened to be the same.
      With the new format, we still run the risk of duplicates if more
      than 100 txns are processed per second.

      Equitable was seeing the problem with MasterCard transactions. This
      problem might still exist with Visa because ncvisa creates its own
      RRN with format YDDDhmmssjjj.
   SCR 25046

      Rev 1.91   Aug 23 2007  ThoughtFocus
   Updated version to 4.4.1.28
   SCR 22830

      Rev 1.90   Jun 05 2007  DIrby
   Updated version to 4.4.1.27
   SCR 13515 and 16379

      Rev 1.89   May 30 2007  DIrby
   Updated version to 4.4.1.26
   SCR 24912

      Rev 1.88   Dec 06 2006 08:17:08   DIrby
   Updated version to 4.4.1.25
   SCR 23864
   
      Rev 1.87   Nov 30 2006 14:39:02   DIrby
   Updated version to 4.4.1.24
   SCR 23599
   
      Rev 1.86   Nov 15 2006 14:44:00   DIrby
   Updated version to 4.4.1.23
   SCR 23559 and 23722
   
      Rev 1.85   Sep 29 2006 14:54:34   dirby
   Updated version to 4.4.1.22
   
      Rev 1.84   Sep 07 2006 17:04:12   dirby
   Updated version to 4.4.1.21
   SCR 22835
   
      Rev 1.83   Aug 14 2006 17:34:54   dirby
   Updated version to 4.4.1.20
   SCR 22649
   
      Rev 1.82   Aug 07 2006 10:50:02   lmitchel
   SCR22649 - added response code 57 to valid_rc table in map_response_code function. This allows the 57 response code to be sent to the terminal instead of converting to response code 96.
   
      Rev 1.81   Jun 09 2006 17:46:26   dirby
   Updated version to 4.4.1.18
   SCR 21716
   
      Rev 1.80   May 23 2006 17:50:08   dirby
   Updated version to 4.4.1.17
   SCR 21041
   
      Rev 1.79   May 12 2006 13:47:14   dirby
   Updated version to 4.4.1.16
   SCR 21042
   
      Rev 1.78   May 04 2006 16:49:06   dirby
   Updated version to 4.4.1.15
   SCR 21042
   
      Rev 1.77   Apr 28 2006 09:33:02   dirby
   1.  Updated version to 4.4.1.14
   2.  Added code to prevent flooding of Applnk with errors when
       dcpiso's queues are not being accessed.
   SCR 21041
   
      Rev 1.76   Mar 09 2006 09:19:04   dirby
   Updated version to 4.4.1.13
   SCR 19670
   
      Rev 1.75   Feb 24 2006 16:32:32   dirby
   Updated version to 4.4.1.12
   SCR 19670
   
      Rev 1.74   Feb 08 2006 10:15:06   dirby
   Updated version to 4.4.1.11
   SCR 19211
   
      Rev 1.73   Feb 07 2006 15:06:14   dirby
   Updated version to 4.4.1.10
   SCR 19211
   
      Rev 1.72   Dec 22 2005 11:20:10   dirby
   Updated version to 4.4.1.9
   SCR 18962
   
      Rev 1.71   Dec 15 2005 13:32:24   dirby
   Added the Visa Online File Maintenance processing.  Equitable
   will send Visa 0302 messages from a PC.  Dcpiso sends these
   directly to ncvisa; gets the response directly from ncvisa; and forwards
   the response to the terminal (or PC).  No database logging is done
   by dcpiso.  That is done in ncvisa.
   SCR 18962
   
      Rev 1.70   Dec 13 2005 17:33:00   dirby
   Updated version to 4.4.1.8
   SCR 12216
   
      Rev 1.69   Jul 07 2005 21:56:32   dirby
   Updated version to 4.4.1.7
   SCR 16398
   
      Rev 1.68   Jun 22 2005 13:34:50   chuang
   Version 4.4.1.6. Fix 16168: crash due to invalid EMV data(field 55).
   
      Rev 1.67   Jun 10 2005 16:48:40   dirby
   Updated version to 4.4.1.5
   SCR 15725
   
      Rev 1.66   May 26 2005 13:54:22   dirby
   Updated version to 4.4.1.4
   SCR 15371
   
      Rev 1.65   May 06 2005 14:33:28   dirby
   Updated version to 4.4.1.3
   SCR 15019
   
      Rev 1.64   Apr 23 2005 16:24:22   dirby
   Updated version to 4.4.1.2
   SCR 15264
   
      Rev 1.63   Apr 05 2005 14:11:42   dirby
   Updated version to 4.4.1.1
   SCR 12785
   
      Rev 1.62   Mar 14 2005 15:20:54   dirby
   Updated version to 4.4.0.17
   SCR 14730
   
      Rev 1.61   Mar 10 2005 17:13:56   dirby
   Updated version to 4.4.0.16
   SCR 14238
   
      Rev 1.60   Mar 01 2005 16:28:14   dirby
   Updated version to 4.4.0.15
   SCR 13769
   
      Rev 1.59   Feb 23 2005 15:52:34   dirby
   Updated version to 4.4.0.14
   SCR 14238
   
      Rev 1.58   Dec 09 2004 14:28:14   dirby
   Updated version to 4.4.0.13
   SCR 12475
   
      Rev 1.57   Nov 24 2004 10:17:22   dirby
   Updated version to 4.4.0.12
   SCR 13221
   
      Rev 1.56   Nov 23 2004 13:49:04   dirby
   Updated version to 4.4.0.11
   SCR 13221
   
      Rev 1.55   Nov 12 2004 17:17:12   dirby
   Updated version to 4.4.0.10
   SCR 12483
   
      Rev 1.54   Nov 08 2004 13:12:58   dirby
   Updated version to 4.4.0.9
   SCR 12786
   
      Rev 1.53   Oct 01 2004 14:59:40   dirby
   Updated version to 4.4.0.8
   SCR 12626
   
      Rev 1.52   Sep 30 2004 16:02:12   dirby
   Updated version to 4.4.0.7
   SCR 12623
   
      Rev 1.51   Sep 28 2004 13:18:10   dirby
   Updated version to 4.4.0.6
   SCR 12582
   
      Rev 1.50   Sep 27 2004 17:16:10   dirby
   Updated version to 4.4.0.5
   SCR 12572
   
      Rev 1.49   Sep 22 2004 15:19:12   dirby
   Updated version to 4.4.0.4
   SCR 12504
   
      Rev 1.48   Sep 20 2004 15:26:04   dirby
   Updated version to 4.4.0.3
   SCR 12503
   
      Rev 1.47   Sep 08 2004 13:32:54   dirby
   Updated version to 4.4.0.2
   SCR 1491
   
      Rev 1.46   Jul 22 2004 10:52:36   mbysani
   updated the version to 4.4.0.1 for emv chip data and auto init reload transactions
   
      Rev 1.45   Jul 13 2004 17:06:08   mbysani
   Added new functionality for AUTO INIT and RELOAD transaction s
   
      Rev 1.44   Jul 09 2004 11:59:22   mbysani
   Added support for EMV chip data coming in field 55
   
      Rev 1.43   Jun 24 2004 12:57:20   dirby
   Updated version to 4.3.0.2
   SCR 1413
   
      Rev 1.42   May 27 2004 18:08:52   dirby
   Updated version to 4.3.0.1
   SCR 1380
   
      Rev 1.41   Mar 12 2004 17:54:54   dirby
   Updated version to 4.2.0.10
   SCR 1222
   
      Rev 1.40   Feb 24 2004 11:24:42   dirby
   Updated version to 4.2.0.9
   SCR 1351
   
      Rev 1.39   Jan 28 2004 13:38:14   dirby
   Updated version to 4.2.0.8
   SCR 1327
   
      Rev 1.38   Jan 26 2004 13:22:48   dirby
   Updated version to 4.2.0.7
   SCR 1181
   
      Rev 1.37   Oct 02 2003 09:51:32   lmitchel
   Ver: 4.2.0.6 - SCR1220 Implemented Duplicate Batch Processing Design.
   
      Rev 1.36   Sep 02 2003 13:13:48   dirby
   Updated version to 4.2.0.5 for VbV
   SCR 1117
   
      Rev 1.35   Aug 29 2003 11:18:18   svelaga
   Added support for security control information.
   field 53. Version number updated: 4.2.0.4
   
      Rev 1.34   Aug 26 2003 13:58:46   mbysani
   added support for VbV transactions 
   
      Rev 1.33   Mar 24 2003 13:54:24   dirby
   Updated version to 4.2.0.3
   SCR 1064
   
      Rev 1.32   Mar 19 2003 20:34:14   dirby
   Modified to get def_gross_amt from bch10 for reversals.
   This is for Cirrus network controller.
   SCR 1063
   
      Rev 1.31   Feb 19 2003 17:12:02   dirby
   Updated version to 4.2.0.1
   SCR 955
   
      Rev 1.30   Feb 11 2003 14:13:20   dirby
   Updated version to 4.1.1.6
   SCR 1019
   
      Rev 1.29   Nov 08 2002 11:23:04   dirby
   Updated version to 4.1.1.5
   SCR 845
   
      Rev 1.28   Oct 01 2002 09:37:02   dirby
   Updated version to 4.1.1.4
   SCR 913
   
      Rev 1.27   Sep 09 2002 16:50:48   dirby
   Updated version to 4.1.1.3
   SCR 897
   
      Rev 1.26   Sep 06 2002 13:37:00   dirby
   Updated version to 4.1.1.2
   SCR 888
   
      Rev 1.25   Aug 21 2002 15:38:26   dirby
   Updated version to 4.1.1.1
   SCR 255
   
      Rev 1.24   Jul 10 2002 09:35:40   dirby
   Updated version to 4.0.3.1
   SCR 621
   
      Rev 1.23   Jun 21 2002 10:40:08   dirby
   Updated version to 4.0.2.4
   SCR 792
   
      Rev 1.22   Jun 19 2002 13:42:18   dirby
   Updated version to 4.0.2.3
   SCR 792
   
      Rev 1.21   May 16 2002 15:04:44   dirby
   1.  Updated version to 4.0.2.2
   2.  Adjusted lots of indentation.
   SCR 665
   
      Rev 1.20   Apr 15 2002 21:23:12   dirby
   Updated version to 4.0.2.1
   SCR 700
   
      Rev 1.19   Jan 16 2002 14:25:28   dirby
   Added transaction trace functionality.
   SCR 546
   
      Rev 1.18   Jan 14 2002 18:05:38   dirby
   Modified the transaction statistic functions to keep statistics
   on number of approved, declined, timed out, and reversed
   txns.  These stats are displayed on Monitor.
   SCR 484
   
      Rev 1.17   Nov 03 2001 13:51:08   dirby
   Updated version to 4.0.0.1
   
      Rev 1.16   Oct 24 2001 16:48:56   dirby
   Updated version to 3.2.3.8    SCR 520
   
      Rev 1.15   Oct 08 2001 10:40:50   dirby
   Updated version to 3.2.3.7   SCR 507
   
      Rev 1.14   Oct 03 2001 15:20:16   dirby
   Updated version to 3.2.3.6   SCR 449
   
      Rev 1.13   Oct 02 2001 14:38:24   dirby
   Updated version to 3.2.3.5    SCR 449
   
      Rev 1.12   Sep 25 2001 16:52:50   dirby
   Updated version to 3.2.3.4
   SCR #449
   
      Rev 1.11   Aug 20 2001 16:57:18   dirby
   Updated version to 3.2.3.3  Reference SCR 440
   
      Rev 1.10   Jul 10 2001 10:25:32   dirby
   Updated version to 3.2.3.2
   
      Rev 1.9   Jun 13 2001 14:52:58   dirby
   Updated version to 3.2.3.1
   
      Rev 1.8   Jun 12 2001 10:18:46   dirby
   Updated version to 3.2.2.5
   
      Rev 1.7   Apr 19 2001 13:46:48   SYARLAGA
   Updated to version 3.2.2.4
   
      Rev 1.6   Jan 09 2001 13:45:56   dirby
    
   
      Rev 1.5   Sep 12 2000 15:17:08   dirby
   Updated the version number to 3.2.2.2
   
      Rev 1.4   Aug 23 2000 16:36:06   dirby
   Added code to support transaction statistics for Monitor.
   
   
      Rev 1.3   Jul 31 2000 09:52:38   dirby
   Modified to display version number at startup and shutdown.
   
   
      Rev 1.2   Dec 17 1999 18:03:26   sdasgupt
    
   
      Rev 1.1   Nov 22 1999 17:52:00   sdasgupt
    
   
      Rev 1.0   Nov 17 1999 13:18:20   sdasgupt
   Initial Release
   
      
**************************************************************************************************/

#include <stdio.h>
#include "pteipc.h"
#include "global_definitions.h"
#include "ntutils.h"
#include "ptesystm.h"
#include "message_handler.h"
#include "genutil.h"
#include "txutils.h"
#include "txtrace.h"
#include "diskio.h"
#include "service_functions.h"
#include "process_incoming_msg.h"
#include "process_outgoing_msg.h"
#include "database_response.h"
#include "general_utilities.h"

AUTH_TX auth_tx ;

CHAR    devds_que_name[]       = "devdsA" ;
CHAR    trands_que_name []     = "trandsA" ;
CHAR    updateds_que_name []   = "updatdsA" ;
CHAR    mrads_que_name[]       = "mradsA" ;
CHAR    authorizer_que_name [] = "txcntlA" ;
CHAR    ncvisa_que_name []     = "ncvisaA" ;
CHAR    visa1_que_name []      = "visa1A" ;
CHAR    oprmon_que_name []     = "oprmonI" ;
CHAR    Version[]              = "ATP_5.18.0"; 
											
/* Statistics for Monitor */
TXN_COUNTS     Txn_Counts;
MONITOR_STATS  Monitor_Stats;

/* Txn Tracing Info */
CHAR   DirPath[MAX_APP_NAME_SIZE];
CHAR   TraceFile[MAX_APP_NAME_SIZE];
INT    Tracing;
FILE   TraceFile_fp;
FILE   *pTraceFile_fp;
FILE   **ppTraceFile_fp;

/* RRN counter to maintain a unique value per second (0 - 99). */
INT  RRNctr;

/* External Function Prototypes */
extern CHAR     ServiceName[12] ;
extern INT      EndProcessSignalled ;
extern INT      MainProcessDone ;
INT void_reload_timeout;
INT mra_send_falg = 0;

/*****************************************************************************

  Function:   end_process

  Description: This function will shutdown the terminal handler.
  Author: 
      unknown
  Inputs:
      None
  Outputs:
      None
  Return values:
      None
  Modified by:
      BGable      6/30/98
******************************************************************************/
void EndProcess(void)
{
   CHAR Buffer[100] = "";

#ifdef _DEBUG
    pteipc_trace_off(); 
#endif

   if ( Tracing == TRACE_ON )
   {
      if ( false == close_trace_file( ppTraceFile_fp ))
      {
         sprintf( Buffer, "Unable to close trace file %s", TraceFile );
         TxUtils_Send_Msg_To_Operator(1,Buffer,
                                      1,INFO_MSG,"EndProcess",2,INFO_ERROR,
                                      0,0,0);
      }
   }

   sprintf( Buffer, "Shutting down the %s Service, version %s",
            ServiceName, Version );
   LogEvent( Buffer, INFO_MSG );
   strcat( Buffer, "\n" );
   PRINT( Buffer );

} /* EndProcess */

/******************************************************************************
 *
 *  NAME:         read_mra_send_falg
 *
 *  DESCRIPTION:  This function reads information from the tf ini file.
 *                This flag information is stored in global variables for use of 
 *					MRA DB Send
 *                .
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      err_buf - Text message explaining why this function failed
 *
 *  RTRN VALUE:   OK if successful, NOT_OK if a problem occurred
 *
 *  AUTHOR:       Dennis Irby
 *
 *  MODIFICATIONS:
 ******************************************************************************/
INT read_mra_send_falg( pCHAR err_buf )
{
   DWORD rc;
   CHAR sectionname  [MAX_APPNAME_SIZE] = "";
   CHAR filename     [MAX_FILENAME_SIZE];
   CHAR tmpstr       [MAX_FILENAME_SIZE];
   CHAR tmpstring    [MAX_INI_INFO_SIZE];
   CHAR ini_info     [MAX_INI_INFO_SIZE];
   INT  ret_val = true;

   /* Determine directory and filename of the .ini file. */
   memset( tmpstr, 0x00, MAX_FILENAME_SIZE );
   GetPinnacleConfigDirectory(tmpstr);
   sprintf(filename, "%s%s", tmpstr, TF_INI_FILE);

   strcpy( sectionname, "PREPAID" );
   memset( ini_info, 0x00, MAX_INI_INFO_SIZE );
   rc = GetPrivateProfileString(
             "MRA_SECTION",                   /* points to section name       */
            "SEND_TO_MRADB",  /* points to key name           */
            "0",                       /* points to default string     */
             ini_info,                      /* points to destination buffer */
             MAX_INI_INFO_SIZE - 1,         /* size of destination buffer   */
             filename                       /* points to ini filename       */
   );

   /* Convert entry from a string into a number. */
   memset(  tmpstring, 0x00, MAX_INI_INFO_SIZE );
   strncpy( tmpstring, ini_info, MAX_INI_INFO_SIZE-1 );
   mra_send_falg = atoi(tmpstring);
	

   return( ret_val );
}



/******************************************************************************
 *
 *  NAME:         read_tf_ini
 *
 *  DESCRIPTION:  This function reads information from the tf ini file.
 *                This information is stored in global variables for use
 *                by any network controller function.  This information
 *                allows customers to have flexibility with some of the
 *                program logic.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      err_buf - Text message explaining why this function failed
 *
 *  RTRN VALUE:   OK if successful, NOT_OK if a problem occurred
 *
 *  AUTHOR:       Dennis Irby
 *
 *  MODIFICATIONS:
 ******************************************************************************/
INT read_tf_ini( pCHAR err_buf )
{
   DWORD rc;
   CHAR sectionname  [MAX_APPNAME_SIZE] = "";
   CHAR filename     [MAX_FILENAME_SIZE];
   CHAR tmpstr       [MAX_FILENAME_SIZE];
   CHAR tmpstring    [MAX_INI_INFO_SIZE];
   CHAR ini_info     [MAX_INI_INFO_SIZE];
   INT  ret_val = true;

   /* Determine directory and filename of the .ini file. */
   memset( tmpstr, 0x00, MAX_FILENAME_SIZE );
   GetPinnacleConfigDirectory(tmpstr);
   sprintf(filename, "%s%s", tmpstr, TF_INI_FILE);

   strcpy( sectionname, "PREPAID" );
   memset( ini_info, 0x00, MAX_INI_INFO_SIZE );
   rc = GetPrivateProfileString(
             sectionname,                   /* points to section name       */
            "Void_Reload_Timeout",  /* points to key name           */
            "600",                       /* points to default string     */
             ini_info,                      /* points to destination buffer */
             MAX_INI_INFO_SIZE - 1,         /* size of destination buffer   */
             filename                       /* points to ini filename       */
   );

   /* Convert entry from a string into a number. */
   memset(  tmpstring, 0x00, MAX_INI_INFO_SIZE );
   strncpy( tmpstring, ini_info, MAX_INI_INFO_SIZE-1 );
   void_reload_timeout = atoi(tmpstring);
	
   if (void_reload_timeout <= 0)
	   void_reload_timeout = 600;

   return( ret_val );
}


/*****************************************************************************

  Function:   MainProcessor

  Description: Initial application setup.  This is the main entry point for 
               incoming PTE messages.
  Author: 
      unknown
  Inputs:
      None
  Outputs:
      None
  Return values:
      None
  Modified by:
      BGable      6/30/98
******************************************************************************/
void MainProcessor (void)
{
   pPTE_MSG p_msg = NULL_PTR ; 
   LONG     retCode = 0L ;
   INT      rc;
   INT      err_ctr = 0;
   CHAR     strError[512] = {0} ;
   CHAR     strTemp[512] = {0} ;
   CHAR     strAppName[512] = {0} ;
   CHAR     strInstanceName[512] = {0} ;
   CHAR     time_date[25] = "";
   CHAR     seconds   [3] = "";


   GetAppName (strAppName) ;
   GetXipcInstanceName (strInstanceName) ;
   sprintf( strTemp,
           "Starting the Service: %s, version %s",
            ServiceName, Version );
   LogEvent( strTemp, INFO_MSG );
   printf( "%s\n", strTemp );


   rc = read_tf_ini( strError );
   rc= read_mra_send_falg(strError);	
   #ifdef _DEBUG
      pteipc_trace_on(); 
   #endif

   if(!pteipc_init_multiple_instance_app (strAppName, ServiceName, strInstanceName))
   {
      strcpy (strError, "Failed to create XIPC queues");
      TxUtils_Send_Msg_To_Operator(1,strError,
                                   1,ERROR_MSG,"MainProcessor",3,FATAL_ERROR,
                                   NULL_STR, NULL_STR, NULL_STR );

      /* signal that we are ready to shut down and quit */
      pteipc_shutdown_multiple_instance_app();
      MainProcessDone = 1;
      return;
   } 

   /* Initialize transaction statistics */
   (void)reset_stats( &Txn_Counts );

   /* Determine if transaction tracing should be turned on. */
   rc = get_trace_ini_info( strAppName, DirPath, strError );
   if ( rc == 0 )
   {
      Tracing = TRACE_ON;

      /* Open the transaction trace file. */
      memset( TraceFile, 0x00, sizeof(TraceFile) );

      pTraceFile_fp  = &TraceFile_fp;
      ppTraceFile_fp = &pTraceFile_fp;

      if (false == open_trace_file(strAppName,DirPath,ppTraceFile_fp,TraceFile))
      {
         Tracing = TRACE_OFF;
         sprintf( strError,
                 "Unable to open trace file %s. Tracing is off",
                  TraceFile );
         TxUtils_Send_Msg_To_Operator(1,strError,
                                      1,INFO_MSG,"MainProcessor",2,INFO_ERROR,
                                      0,0,0);
      }
      else
         TxUtils_Send_Msg_To_Operator(1,"Tracing is turned ON",
                                      1,INFO_MSG,"MainProcessor",2,INFO_ERROR,
                                      0,0,0);
   }
   else
   {
      Tracing = TRACE_OFF;
      if ( rc == -1 )
      {
         TxUtils_Send_Msg_To_Operator(1,strError,
                                      1,INFO_MSG,"MainProcessor",2,INFO_ERROR,
                                      0,0,0);
      }
      TxUtils_Send_Msg_To_Operator(1,"Tracing is turned off",
                                   1,INFO_MSG,"MainProcessor",0,INFO_ERROR,
                                   0,0,0);
   }

   /* Initialize the RRN counter that ensures unique RRNs per second. */
   ptetime_get_timestamp( time_date );
   memcpy( seconds, time_date+17, 2 );
   RRNctr = atoi( seconds );


   while (!EndProcessSignalled)
   {
      /* You are blocked here waiting for a message on either app queue or control que  */
      /* if there is no message on either que for 5 seconds, the blocking call returns   */
      p_msg = pteipc_receive (application_que_name, control_que_name, 5, &retCode);

      if (p_msg != NULL_PTR)
      {
         PinnacleMsgHandler (p_msg);
         free (p_msg);
      }
      else if (retCode != QUE_ER_TIMEOUT) 
      {
         pteipc_get_errormsg( retCode, strTemp );
         sprintf(strError, "Error on pteipc_receive %s", strTemp);
         TxUtils_Send_Msg_To_Operator( 1, strError, 1, ERROR_MSG,
                                      "MainProcessor", 3, WARNING_ERROR,
                                       0, 0, 0 );

         /* There is a problem with the queue.  Delay 1 second
          * so as to not flood Applnk's queue and syslog.
          */
         #ifdef WIN32
            Sleep( 1000 );
         #else
            usleep( 1000000 );
         #endif

         /* Inform Operators if service's queue is no longer readable. */
         if ( ++err_ctr > 10 )
         {
            err_ctr = 0;
            sprintf( strError,
                    "SHUT DOWN %s. UNABLE TO ACCESS QUEUE!!!!",
                     ServiceName );
            TxUtils_Send_Msg_To_Operator (1, strError, 1, ALERT_MSG,
                                         "MainProcessor", 4, FATAL_ERROR,0,0,0);
            #ifdef WIN32
               Sleep (5000);
            #else
               usleep (5000000);
            #endif
         }
      }
   }

   pteipc_shutdown_multiple_instance_app ();
   MainProcessDone = 1;
   free (p_msg);
   return;
} /* MainProcessor */

/*****************************************************************************

  Function:   PinnacleMsgHandler

  Description: This function receives a PTE message and passes it to the 
               appropriate processing function.
  Author: 
      unknown
  Inputs:
      p_msg_in - incoming PTE message
  Outputs:
      None
  Return values:
      None
  Modified by:
      BGable      6/30/98
******************************************************************************/
void PinnacleMsgHandler (pPTE_MSG p_msg_in )
{
   pPTE_MSG p_cur_msg;
   pPTE_MSG p_msg_out;
   BYTE msgtyp;
   CHAR buffer[100]="";
   INT      rc;
   CHAR     strError[512] = {0} ;

   BYTE retCode = 0 ;

   memset(&auth_tx, 0, sizeof auth_tx) ;

   p_cur_msg = p_msg_in ;
   p_msg_out = NULL_PTR ;

   msgtyp = ptemsg_get_msg_type( p_cur_msg) ;
   switch (ptemsg_get_msg_type( p_cur_msg))
   {
      case MT_AUTH_RESPONSE:
            retCode = Process_Response_From_Authorizer (p_msg_in) ;	

            /* At this point, either the ALL_DATA update has been
             * called and DEVICE_OK has been returned OR SYSTEM_ERROR or
             * DEVICE_ERROR has been returned
             */
           if (retCode != DEVICE_OK)
              Send_Transaction_To_Originator () ;
      break;

      case MT_INCOMING:
         retCode = Process_Incoming_Message_From_Terminal (p_msg_in) ;

         if (retCode != DEVICE_OK) 
         {
            /* Could be ISO_PARSE_ERROR or DEVICE_ERROR or SYSTEM_ERROR */
            if (retCode == ISO_PARSE_ERROR)
            {
               /* Drop the transaction as writing to TLF01 does not
                * make any sense as auth_tx might not be populated
                */
               break ;
            }
            Send_Transaction_To_Originator () ;
         }
      break;

      case MT_TIMER_TIMEOUT:
      break;	

      case MT_SYSTEM_REQUEST:
         ptesystm_system_msg_handler (p_msg_in);
		 process_encryption_flag( p_msg_in );
         if ( ST1_SYS_PING == ptemsg_get_msg_subtype1(p_msg_in) )
         {
            rc = read_tf_ini( strError );
			/* Get config parameter for mra send flag while ping request Added by praneeth*/
			rc = read_mra_send_falg( strError );//praneeth
			TxUtils_Send_Msg_To_Operator( 1, "Reading mra send flag from ini file", 1, INFO_MSG,
                                            "PinnacleMsgHandler",
                                             0, INFO_ERROR, 0, 0, 0 );
            if ( Tracing == TRACE_ON )
            {
               /* Flush the trace file buffer when service is pinged. */
               if ( false == flush_file(ppTraceFile_fp) )
               {
                  Tracing = TRACE_OFF;
                  sprintf( buffer,
                       "%s: Unable to flush trace file buffer. Turning Trace off.",
                        ServiceName );
                  TxUtils_Send_Msg_To_Operator(1, buffer,
                                   1,INFO_MSG,"PinnacleMsgHandler",3,INFO_ERROR,
                                   0,0,0);
                  (void)close_trace_file( ppTraceFile_fp );
               }
            }

            /* When pinged, display application version on Monitor. */
            sprintf( buffer,
                    "Pinged -> Device Controller Service: %s, version %s",
                     ServiceName, Version );
            TxUtils_Send_Msg_To_Operator( 1, buffer, 1, INFO_MSG,
                                         "PinnacleMsgHandler",
                                          0, INFO_ERROR, 0, 0, 0 );
         }
		 if( ST1_SRVC_MRAON == ptemsg_get_msg_subtype1(p_msg_in) ) 
	     {
			mra_send_falg = 1;
			send_trace_response(p_msg_in);
			sprintf( buffer,
                    "MRA enabled for %s, version %s",
                     ServiceName, Version );
            TxUtils_Send_Msg_To_Operator( 1, buffer, 1, INFO_MSG,
                                         "PinnacleMsgHandler",
                                          0, INFO_ERROR, 0, 0, 0 );
	     }
		 if( ST1_SRVC_MRAOFF == ptemsg_get_msg_subtype1(p_msg_in) ) 
	     {
			mra_send_falg = 0;
			send_trace_response(p_msg_in);
			sprintf( buffer,
                    "MRA disabled for %s, version %s",
                     ServiceName, Version );
            TxUtils_Send_Msg_To_Operator( 1, buffer, 1, INFO_MSG,
                                         "PinnacleMsgHandler",
                                          0, INFO_ERROR, 0, 0, 0 );

	     }
      break;        

      case MT_DB_REPLY:
         retCode = ptemsg_get_result_code (p_msg_in) ;
         if (retCode == PTEMSG_OK)
         {
            retCode = Process_Dataserver_OK_Message (p_msg_in) ;
         }
         else if (retCode == PTEMSG_NOT_FOUND)
         {
            retCode = Process_Dataserver_NotFound_Message (p_msg_in) ;
         }
         else 
         {
            retCode = Process_Dataserver_ERROR_Message (p_msg_in) ;
         }

         if (retCode != DEVICE_OK)
         {
            /* Control comes here on SYSTEM_ERROR, BCH01_TOTALS_MATCHED,
             * BCH01_TOTALS_NOT_MATCHED, BCH10_INSERT_SUCCESSFUL, 
             * SEND_RESPONSE_TO_ORIGINATOR 
             */
            if (If_Transaction_Cannot_Be_Declined ())
            {
               /* If transactions cannot be declined, set the response code
                * to 00 (even for SYSTEM_ERROR)
                */
               strcpy( auth_tx.TLF01_details.response_code,
                       TRANSACTION_APPROVED) ;
            }
            Send_Transaction_To_Originator () ;
         }
      break;

      case MT_GET_STATS:
         (void)send_transaction_statistics( p_msg_in );
      break;

      case MT_RESET_STATS:
         (void)reset_transaction_statistics( p_msg_in );
      break;

      case MT_SYSTEM_REPLY: 
      break;

      case MT_DB_REQUEST:
      break;

      case MT_TIMER_REPLY:
      break;

      case MT_INCOMING_GUI:
         (void)process_0312( p_msg_in );
      break;

      default:
         LogEvent("PinnacleMsgHandler: unknown msg_type received", WARN_MSG);
      break;
   }  /* switch msg_type */
} /* PinnacleMsgHandler */
/******************************  END OF FILE  ****************************************************/
