/******************************************************************************

   Module: updatds.c

   Title:  Update Dataserver

   Description: Dataserver Routines to update database for each transaction

   ----------------
   REVISION HISTORY
   ----------------
   
   Rev 1.112  Aug 27 2009   TF-Ajay 
   Changed the code to update currency conversion rate in TLF01_STIP table 
   Updated version 4.4.1.33

   Rev 1.111   Jul 22 2009   TF-Ajay 
   Changed the code to update  table TLF01_STIP feild 6 and 51
   Updated version 4.4.1.32


	 Rev 1.110   Jul 13 2009   TF-Ajay 
  Changed the code to update  table ncf30 and bch20 for Void/Reversal/Adjust txn.
   Updated version 4.4.1.31
   
	 
	   Rev 1.109   Jun 03 2009  Ajay/Pahni ThoughtFocus, Bangalore
	  Updated version to 4.4.1.30
	  Changed the code to update  table TLF01_STIP for Void/Reversal/Adjust txn.
   Rel 09-40
	
	  Rev 1.108   Nov 06 2008  Girija Y ThoughtFocus, Bangalore
	  Updated version to 4.4.1.29
	  Changed the code to create new table TLF01_STIP and to insert stand-in processed 
	  tx into TLF01_STIP tabel.
   Rel 08-33

   Rev 1.107   Nov 15 2007  dirby
      Updated version to 4.4.1.28
      Fixed bug in process_network_request for non-nccirs hosts. The reversal
      flag was not being set for reversals. Moved that piece of code out of
      the nccirs block so it is common for all hosts.
   SCR 25042

   Rev 1.106   Oct 30 2007  dirby
      Updated to version 4.4.1.27
   SCR 25039

   Rev 1.105   Oct 18 2007  dirby
      Updated to version 4.4.1.26
   SCR 25037

   Rev 1.104   Sep 18 2007  dirby
      Updated to version 4.4.1.25

      Isolated the cash bonus program processing in the update-all function.
      Put it at the beginning so it could be committed (for non-winners only)
      without affecting the rest of the update-all process. For winners, it
      gets committed/rolled back with the rest of the update-all processes.
      This is done to free table Bon02 as quick as possible. Equitable is
      seeing a lot of "resource busy" errors in connection with this table.
      In conjunction with these changes, changes were made in the .pc file
      to remove the NO WAIT functionality on Bon02. This way, the "resource
      busy" warning will not occur. Instead, other instances of updatds will
      wait for the table to free up.
   SCR 25034

      Rev 1.103   Jun 05 2007  DIrby
   ThoughtFocus made changes to fix reversals so voids are properly
   reversed.  SCR 12502

   ThoughtFocus made changes to fix the stan on reload reversals. The reversal
   contained the wrong stan.  SCR 13515

      Rev 1.102   Mar 08 2007 10:28:02   DIrby
   Fixed bug when checking subtype 2 on a ping; changed '==' to '!='.
   SCR 24081
   
      Rev 1.101   Mar 02 2007 11:34:50   DIrby
   Added support for every SQL to be stored into shared memory
   in table SQL01 prior to being executed.
   SCR 24081
   
      Rev 1.100   Jan 18 2007 09:33:32   DIrby
   1.  Updated version to 4.4.1.22
   2.  Modified the Cash Bonus processing so that when there is
       a winner, check to see if the program allows a cardholder to
       win the program more than once.  If not, check table BON03
       to see if that cardholder has already won this program at a
       previous date.  If yes, do not allow the win, but instead, reset
       the transaction counter to allow the next cardholder to win.
   SCR 24046
   
      Rev 1.99   Sep 21 2006 11:07:22   dirby
   Updated version to 4.4.1.21
   SCR 22835
   
      Rev 1.98   Sep 15 2006 16:52:40   dirby
   Fixed the conversion algorithm in Cash Bonus processing to get
   the currency conversion rate from CRF01 in shared memory.
   The conversion rate in TLF01 did not seem to be accurate.
   SCR 22835
   
      Rev 1.97   Sep 14 2006 13:50:32   dirby
   Modified Cash Bonus processing to determine which time period
   we are in, instead of just looking for a new time period.
   Also modified the reward amount to be converted to Peso if in USD.
   SCR 22835
   
      Rev 1.96   Sep 07 2006 15:08:38   dirby
   Fixed bugs in Cash Bonus logic to put dates in proper format
   before converting to Julian, and also to store an updated time
   period (tag_id).
   SCR 22835
   
      Rev 1.95   Sep 06 2006 17:28:26   dirby
   Modified to read tf.ini at startup to get a Cash Bonus message
   to be displayed on the terminal for non-winners.
   SCR 22835
   
      Rev 1.94   Sep 06 2006 16:32:54   dirby
   Changed the Cash Bonus code from the old BON01 functionality
   to the enhanced Cash Bonus Program which uses BON02 and BON03.
   SCR 22835
   
      Rev 1.93   Jul 26 2006 07:50:18   dirby
   Updated version to 4.4.1.17
   SCR 12299
   
      Rev 1.92   Jul 24 2006 16:02:32   dirby
   Add some "waits" to the FGUARD update function.  When a request
   is sent to Fraudguard, that request is immediately inserted into
   FGUARD.  When Fraudguard sends its response, the response
   information is updated into the request record in FGUARD.  However,
   if the request has not completed being inserted by the time the response
   wants to update it, then a "record not found" error is returned.  This
   scenario can happen when there are multiple instances of updatds
   running (EB has 5 instances).  To compensate for this, some "waits"
   have been added to the FGUARD update function.
   SCR 21292
   
      Rev 1.91   Jul 10 2006 12:59:46   dirby
   Fixed bug in function 'process_reversal'.  The result code was
   being returned for Voice Auth reversals before being reset after
   a check for a duplicate transaction.
   SCR 22230
   
      Rev 1.90   Jul 07 2006 16:45:36   dirby
   Implemented functionality to gather statistics on database SQL calls.
   SCR 12299
   
      Rev 1.89   May 26 2006 09:23:08   dirby
   Updated version to 4.4.1.13
   Modified to not attempt an insert into EMV01 without first checking
   to see if data is present.
   SCR 21465
   
      Rev 1.88   May 09 2006 18:59:48   dirby
   Updated version to 4.4.1.12
   SCR 21189
   
      Rev 1.87   Apr 19 2006 17:48:48   dirby
   Modified to look for duplicate transactions prior to doing an update all.
   This is needed because during high volume, queues can back up
   causing terminals to timeout and reissue transactions.  The 2nd
   transaction might get processed before the 1st one completes;
   so the exising check for duplicate transactions in dcpiso might not
   catch it.
   SCR 19327
   
      Rev 1.86   Dec 13 2005 17:26:48   dirby
   Added Card Verification to update all to be treated like an authorization.
   SCR 12216
   
      Rev 1.85   Jul 28 2005 14:21:22   dirby
   Modified the check to see if there is an EMV block to insert into
   emv_raw.  Instead of looking at just the 1st length byte, look at
   both of them.
   SCR 16652
   
      Rev 1.84   Jul 13 2005 11:17:14   dirby
   Updated version to 4.4.1.8
   SCR 15918
   
      Rev 1.83   Jul 01 2005 11:25:34   dirby
   Updated version to 4.4.1.7
   SCR 16303
   
      Rev 1.82   Jun 30 2005 16:27:28   dirby
   Changed function db_process_tc_crypto to update tag 9F27 in
   addition to tag 9F26.
   SCR 16166
      
   
      Rev 1.81   Jun 27 2005 14:26:52   dirby
   Added support for Fraudguard
   SCR 14421
   
      Rev 1.80   Jun 21 2005 15:06:46   dirby
   Modified storing for EMV tag 9F10 to not skip the first byte.
   SCR 15726
   
      Rev 1.79   Jun 10 2005 17:09:56   dirby
   Modified to make EMV field Issuer Script 1 so that is logs a variable
   Tag ID.  MC might store tag 71 here while Visa stores tag 72.  Also fixed logging/storing of tag 91 to store the length of the raw
   data, not the length of the ASCII data stored in EMV01.
   SCR 15725
   
      Rev 1.78   Jun 08 2005 20:19:24   dirby
   Added logic to update original Reload transactions as being
   confirmed.  This is done when a Reload Confirm is processed.
   SCR 15748
   
      Rev 1.77   May 26 2005 16:21:30   dirby
   Corrected EMV logging bugs:
   1.  Tag 84, first 2 bytes were being cut off.
   2.  Prepend 0 in front of Country Code (Tag 9F1A).
   SCR 15725
   
      Rev 1.76   May 26 2005 13:37:22   dirby
   Modified to insert or update an EMV01 record for TC Uploads (0320,94nnnn).
   This is EMV TAG 9F26.  It needs to contain the same tran id as the
   original EMV message.  So first find the original in BCH10, get its
   tran id, then insert or update EMV01; also insert into TLF01.
   SCR 15371
   
      Rev 1.75   May 06 2005 16:59:50   dirby
   When storing EMV data in the database, the length byte(s) were
   being stored as part of the data.  Fixed this to not store the length
   bytes.
   SCR 15497
   
      Rev 1.74   May 04 2005 15:32:08   dirby
   Modified the Cash Bonus functionality to be performed prior to
   inserting records into BCH10.  This is so the cash bonus flag
   can be properly set in BCH10 (transferred from TLF01), thus
   allowing it to be extracted into the raffle file by the settlement application.
   SCR 15307
   
      Rev 1.73   Apr 05 2005 16:00:40   dirby
   Updated version to 4.4.1.1
   SCR 12785
   
      Rev 1.72   Mar 09 2005 08:46:28   dirby
   Removed the temporary logging statements that were used to
   determine bottlenecks with EMV inserts.
   SCR 13391
   
      Rev 1.71   Feb 18 2005 14:05:06   mbysani
   scr 13560,  EMV Support
   
      Rev 1.70   Feb 17 2005 14:22:46   mbysani
   scr 13560,  EMV Support
   
      Rev 1.69   Jan 05 2005 17:04:06   dirby
   Added a log message with time after each hit to the database.
   These are temporary to diagnose DB slowness with EMV.  However,
   based on traces sent by EB, the problem is prior to EMV inserts.
   SCR 13391
   
      Rev 1.68   Jan 04 2005 13:27:16   dirby
   Added a commit after update all before EMV inserts begin.  This
   is in the hopes of speeding up the EMV inserts.  Updatds takes
   a long time on EMV txns; could be due to large rollback records.
   This commit should cut down on that.  But just in case, I also added
   some timing info that gets logged to narrow down where most of
   the time is being taken.  This is temporary code until the problem
   can be found.
   SCR 13391
   
      Rev 1.67   Dec 20 2004 14:34:18   dirby
   Modified to provide an audit trail of the update all function.  A letter
   is used to indicate a function that gets accessed.  A '1' following
   the letter means the function was successful; '0' indicates it failed.
   This info gets stored into TLF01.dcf01_retired_cwk.
   Also, removed a condition that was preventing rollbacks in some
   cases.
   SCR 12446
   
      Rev 1.66   Sep 22 2004 15:12:28   dirby
   Changed the update all function to update batch tables for Reloads,
   not Reload Confirms.  A Reload Confirm will still update accout
   balances, but not batch records.
   SCR 12504
   
      Rev 1.65   Jul 22 2004 13:47:14   dirby
   Added Reload Confirm and Reload Void tran types to the update
   all process.  Reload Confirm is treated like a sale.
   SCR 1287
   
      Rev 1.64   Jul 14 2004 16:57:34   dirby
   Initialize EMV data structure before each tag that gets stored into EMV01.
   SCR 1388
   
      Rev 1.63   Jul 13 2004 14:42:00   dirby
   In the EMV structure in auth_tx, changed category code to tcc
   and added mcc.
   SCR 1287
   
      Rev 1.62   Jul 08 2004 16:22:08   dirby
   Added support to populate EMV01 table.
   Added support to update DCF01.additional_pos_information
   with a chip condition code for EMV transactions.
   SCR 1388
   
      Rev 1.61   May 27 2004 17:26:16   dirby
   Updated version to 4.3.0.1
   SCR 1380
   
      Rev 1.60   Feb 18 2004 17:47:14   dirby
   Updated version to 4.2.0.9
   SCR 1339
   
      Rev 1.59   Sep 19 2003 13:21:56   dirby
   Updated version to 4.2.0.8
   SCR 1083
   
      Rev 1.58   Sep 12 2003 13:18:30   dirby
   Modified to allow updates to TLF01.
   Removed some functions that were not used.
   
      Rev 1.57   Jul 09 2003 17:47:20   dirby
   1.  Updated version to 4.2.0.6
   2.  Added code to log an error for Voice txns that fail.  Voice cannot
   log to syslog, so it needs to be done here.
   SCR 1126
   
      Rev 1.56   Jun 13 2003 11:43:54   dirby
   Updated to version 4.2.0.5
   Modified to delete BCH20 record for Voice reversals - all kinds.
   SCR 1162
   
      Rev 1.55   May 20 2003 16:39:58   dirby
   Updated version to 4.2.0.4
   Modified alldata to not update ACF01 deferred accounts for RSB cards.
   SCR 1124
   
      Rev 1.54   Apr 03 2003 12:36:22   dirby
   Modified to check bin type for deferred transactions in addition
   to credit and debit transactions.  Deferred transactions should
   be treated similar to credit transactions.
   SCR 1031
   
      Rev 1.53   Mar 25 2003 14:54:48   dirby
   Modified all_data to update BCH tables for Void and Reversals
   of Deferred Txns if they are not from Voice.  Else it causes
   batch uploads.
   SCR 1031
   
      Rev 1.52   Mar 24 2003 17:12:16   dirby
   Modified to save settlement_date in BCH10 for Cirrus reversals.
   SCR 1063
   
      Rev 1.51   Mar 24 2003 14:10:58   dirby
   Added an update option to update NCF21 and insert into NCF30.
   This is for Cirrus which needs to do this as an acquirer - without
   updating all or inserting into TLF01.
   SCR 1064
   
      Rev 1.50   Feb 17 2003 10:18:24   dirby
   Updated version to 4.2.0.1
   SCR 955
   
      Rev 1.49   Feb 11 2003 13:58:36   dirby
   1.  Modified to treat online deferreds as sales, voice deferreds as auths.
   2.  Updated version to 4.1.1.5
   SCR 1019
   
      Rev 1.48   Dec 23 2002 09:10:02   dirby
   Corrected a bug in update_all.  When update or insert failed,
   the insert into TLF01 with RC=96 is successful, but it was being
   rolled back.  Corrected this so that it only attempts to insert into
   TLF01 if the updates/inserts were successful.  If the insert into
   TLF01 fails, everything is rolled back.
   SCR 845
   
      Rev 1.47   Nov 12 2002 14:22:04   dirby
   Modified update_all function to insert into TLF01 after the update
   is completed, whether successful or not.  The response to a
   device now depends on the success or failure of updates and
   TLF01 inserts.  Previously, it just depended upon the updates.
   SCR 845
   
      Rev 1.46   Oct 16 2002 11:57:54   dirby
   Added a line that had been taken out awhile ago in function
   process_update_msg.  This is to populate buffer atp_buffer
   with auth_tx so it can be returned to caller in the event of an
   error.
   SCR 820
   
      Rev 1.45   Sep 13 2002 17:22:50   dirby
   Added Cash Bonus Processing to this data server.  Did this to
   prevent multiple winners - this could have happened before
   because it took quite a bit of time from selecting BON01 to
   finally updating it. Since the processing is here now and the
   selecting and updating of BON01 are close together, I also put
   BON01 into shared memory for performance improvement.
   SCR 804
   
      Rev 1.44   Sep 09 2002 17:34:22   dirby
   Modified to update deferred related account for reversals and
   voids if they are for deferred transactions.  Also modified to not
   do any update of BCH20/BCH10 for reversals and voids of
   deferred transactions.
   SCR 897
   
      Rev 1.43   Aug 16 2002 17:55:08   dirby
   Updated version to 4.1.1.1
   SCR 255
   
      Rev 1.42   Jul 18 2002 16:11:40   dirby
   Added functionality to support timing of queries and report on
   any that take too long.  This is configurable in TF.INI.
   SCR 818
   
      Rev 1.41   Jul 09 2002 14:32:20   dirby
   1.  Added code to allow Voice txns to update network records.
       This is for Voice cancellations of network records.
   2.  Updated version to 4.0.3.1
   SCR 810
   
      Rev 1.40   Jun 21 2002 11:24:28   dirby
   Added code to display version when pinged.
   SCR 792
   
      Rev 1.39   Jun 21 2002 11:01:20   dirby
   1.  Updated version to 4.0.2.1
   2.  Modified to accept reversals of Quasi-Cash.
   3.  Modified to give error msg if txn type not found, for reversals.
   SCR 792
   
      Rev 1.38   Nov 03 2001 13:27:58   dirby
   Updated version to 4.0.0.1
   Added 'def_gross_amt' and 'monthly_amort_amt' to BCH10/20
   SCR 256
   
      Rev 1.37   Aug 06 2001 08:50:04   dirby
   1.  Updated version to 3.2.3.2
   2.  Modified code for reversal processing.  Where it checks the
        processing code to determine txn type, changed it to just
        check first 2 digits.  It was comparing against all 6 digits,
        requiring the last 4 to be all zeroes.
   
      Rev 1.36   Jun 13 2001 14:55:16   dirby
   Updated version to 3.2.3.1
   
      Rev 1.35   Jun 12 2001 10:26:08   dirby
   Updated version to 3.2.2.6
   
      Rev 1.34   Jan 09 2001 14:17:18   dirby
   Updated version number.  This marks the release where the production
   stability issue has been resolved.  Some debug code has been removed and
   added #ifndef around some Unix signal code so the data server will compile
   on NT.
   
      Rev 1.33   Jan 09 2001 13:46:04   dirby
    
   
      Rev 1.32   Oct 18 2000 15:17:26   dirby
   1.  Updated version number to 3.2.2.4
   2.  Added code to convert a message type from a response to a request prior
   to an insert.  For example, store 0200 instead of 0210.
   
      Rev 1.31   Oct 16 2000 12:29:02   dirby
   1.  Updated version number to 3.2.2.3 - TEST.
   2.  Added code to support XipcSystemErrReport in the event of XIPC problems.
   3.  Removed catching of OS signals CHILD and HangUP so the daemon process can catch them.
   
      Rev 1.30   Oct 05 2000 15:02:24   dirby
   Updated the version number to '3.2.2.2 - TEST'.
   This version is compiled with more diagnostic stuff
   in daemon.c.
   
      Rev 1.29   Sep 01 2000 16:51:24   dirby
   Corrected a typo on app_name.
   
      Rev 1.28   Sep 01 2000 16:19:44   dirby
   Added TrapFunction to catch Unix signals.  This will not compile under NT.
   
      Rev 1.27   Aug 31 2000 17:30:24   dirby
   Appended "TEST" to the version number to account for some
   daemon testing getting linked in.
   
      Rev 1.26   Aug 30 2000 15:12:34   dirby
   Updated version number to 3.2.2.1
   
      Rev 1.25   Aug 01 2000 16:51:34   dirby
   Added populating odometer and ticket_nbr for bch10 and bch20.
   
      Rev 1.24   Aug 01 2000 10:13:48   dirby
   Added code to create system date when a record
   is inserted into TLF01.
   
      Rev 1.23   Aug 01 2000 09:45:16   dirby
   Added card_nbr as part of primary key to NCF30.
   
      Rev 1.22   Jul 30 2000 15:37:12   dirby
   Modified to display version number at startup and shutdown.
   
      Rev 1.21   Jun 24 2000 23:30:04   dirby
   Added code to make ATM_CONFIRMs be treated like reversals.
   
      Rev 1.20   Apr 13 2000 14:00:48   iarustam
   added offus_velocity table
   
      Rev 1.19   Mar 29 2000 15:20:48   ddabberu
   all_data function modified
   
      Rev 1.18   Mar 22 2000 13:48:26   ddabberu
   process_network_request() changed to propagate error_msg
   
      Rev 1.17   Feb 25 2000 17:46:06   ddabberu
   fix : scr# 439 
   
      Rev 1.16   Feb 23 2000 14:26:20   ddabberu
   process_network_request() modified
   to populate ncf30 structure.
   
      Rev 1.15   Feb 15 2000 16:43:40   ddabberu
   1.Totals Corrected
   2.Create_rrn and related functionality added.
   3.Modified to copy the Original rrn into ncf30,
     to delete the orign txn from NCF30
   
      Rev 1.14   Feb 15 2000 12:51:32   iarustam
   Fixed cirrus SALE transactions.
   Messages from cirrus will go to NCF21 and
   NCF30
   
      Rev 1.13   Feb 14 2000 15:25:54   iarustam
   Added select for Update for ncf21
   and changed the code for populating ncf30 for
   reversal tx 
   
      Rev 1.12   Feb 11 2000 10:01:00   svelaga
   Proper rollback if either NCF21 or NCF30 operation 
   fails in process_network_request function.
   
      Rev 1.11   Feb 10 2000 15:37:04   iarustam
   added the functionality to delete original
   transaction from ncf30 for reversals
   SCR#374
   
      Rev 1.10   Feb 10 2000 13:20:04   iarustam
   Added the login to populate ncf21 and ncf30 
   tables.
   SCF# 374
   
      Rev 1.9   Feb 01 2000 11:27:02   iarustam
   added open_date and open_time to bch20
   
      Rev 1.8   Jan 28 2000 09:58:58   iarustam
   Fixed adjustments
   
      Rev 1.7   Jan 17 2000 16:49:38   sdasgupt
    
   
      Rev 1.6   Jan 13 2000 10:17:26   sdasgupt
   Insert BCH10/BCH20 - transaction timestamp, response code etc
   Modified reversal logic such that the reversal of an AUTH removes the AUTH from BCH20
   
      Rev 1.5   Dec 28 1999 17:53:36   iarustam
   fix for void transaction
   
      Rev 1.4   Dec 28 1999 10:39:04   jxiao
    
   
      Rev 1.3   Dec 16 1999 14:29:28   iarustam
   added voice auth transaction types
   
      Rev 1.2   Dec 15 1999 09:10:38   dirby
   Removed GUARANTEED_LATE_ARRIVAL.  Not need for Equitable.
   
      Rev 1.1   Dec 07 1999 14:16:34   jxiao
   reorganize update logic, fix db_updated flag problems
   
      Rev 1.0   Nov 30 1999 09:58:48   jxiao
   Initial check in
   
******************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <sys/timeb.h>

#include "basictyp.h"
#include "pte.h"
#include "pteipc.h"
#include "ptemsg.h"
#include "ptestats.h"
#include "ptesystm.h"
#include "ptetimer.h"
#include "ptetime.h"
#include "ntutils.h"
#include "logger.h"

#include "dbcommon.h"
#include "app_info.h"
#include "equitdb.h"
#include "dc_dbstruct.h"
#include "nc_dbstruct.h"
#include "tx_dbstruct.h"
#include "update_db.h"
#include "memmnger.h"
#include "dstimer.h"
#include "txutils.h"
#include "timings.h"


/*   GLOBAL VARIABLES    */
extern CHAR ServiceName[];
extern int volatile EndProcessSignalled;
extern int volatile MainProcessDone;
CHAR         AppName   [MAX_APP_NAME_SIZE];

void TrapFunction( INT signum );
void create_system_time( pCHAR system_time );
void commit_the_update();


PRIVATE union
{
	DCF01   dcf01;
	BCH01   bch01;
	BCH10   bch10;
	MCF01   mcf01;
	MCF20   mcf20;
	TLF01   tlf01;
	BCH11   bch11;
	BCH20   bch20;
   NCF21   ncf21;
   NCF30   ncf30;

}db_recs;

PRIVATE BYTE         msg_sub_type2;
PRIVATE BYTE         msg_sub_type1;
PRIVATE BYTE         app_data_type;
PRIVATE BYTE         result_code;
PRIVATE BOOLEAN      updates_to_db_made = false;
PRIVATE CHAR         err_msg[100];
        CHAR         app_name[MAX_APP_NAME_SIZE];
PRIVATE pCHAR        reply_que;
PRIVATE CHAR         orig_comm_inf[MAX_ORIG_INFO_SIZE];
PRIVATE CHAR         atp_buffer[30000];
PRIVATE CHAR         update_all_status[48]; /* Status of alldata func in tlf01*/
CHAR                 Version[] = "ATP_5.18.0";  
BYTE                 OrigTxKey;

/* Globals for Cash Bonus Program */
INT     CashBonusWinner;
CHAR    CashBonusNonWinnerMsg[121];


INT ds_timer_flag;
INT ds_timer_value;

/* Database Timing Measurements */
TIMINGS_LIST  TimingStats;
INT           DB_Timing_Flag; /* True = Do DB Timing Stats, False = don't do */
INT           ForceReport;
double        NextReportTime;
CHAR          ReportTime[5];


#ifdef _DEBUG
   #define PRINT(X) printf(X)
#else
   #define PRINT(X)
#endif

// fuctions

void get_time( pCHAR time_date, pCHAR time_str )
{
   memset ( time_str,  0x00,          7 );
   strncpy( time_str, &time_date[11], 2 );
   strncat( time_str, &time_date[14], 2 );
   strncat( time_str, &time_date[17], 2 );
}

/* TF-Phani*/
BYTE IsFieldNull (char str[])
{
	if (strlen (str) == 0)
		return 1 ;
	return 0 ;
}

void calc_julian_day( pCHAR date_str, pCHAR julian_str )
{
   CHAR  year[5];
   CHAR  month[3];
   CHAR  day[3];
   INT   iYear;
   INT   iMonth;
   INT   iDay;
   INT   julian_day;
   INT   i;
   INT   DaysOfMonth[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };


   strncpy( year, date_str, 4 );
   iYear  = atoi( year );

   strncpy( month, &date_str[4], 2 );
   iMonth = atoi( month );

   strncpy( day, &date_str[6], 2 );
   iDay   = atoi( day );

   for( i=0,julian_day=0; i<iMonth-1 && i<12; i++ )
   {
      julian_day += DaysOfMonth[i];
   }
   julian_day += iDay;

   if ( 2 < iMonth )
      if ( 0 == ( iYear % 4 ) )
         julian_day++;

   sprintf( julian_str, "%03d", julian_day );
   return;
}


/******************************************************************************
 *
 *  NAME:         CREATE_RRN
 *
 *  DESCRIPTION:  This procedure creates a retrieval reference number in the
 *                format of YDDDhmmssjjj, that is:
 *                     Y   = last digit of the year
 *                     DDD = Julian day
 *                     h   = last digit of the 24 hour clock (current time)
 *                     mm  = current system minutes
 *                     ss  = current system seconds
 *                     jjj = current system milliseconds
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      rrn - Formatted as mentioned above in the description
 *                      RRN should be a 13 character string.
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Dennis Irby
 *
 ******************************************************************************/
void create_rrn( pCHAR rrn )
{
   CHAR    julian_day[4];
   CHAR    date_str[9];
   CHAR    time_str[7];
   CHAR    time_date[25]; 

   /* Get system timestamp "YYYY-MM-DD-hh.mm.ss.jjj" */
   (void) ptetime_get_timestamp( time_date );

   /* Reformat to get date "YYYYMMDD" and time "hhmmss" */
   get_date( time_date, date_str );
   get_time( time_date, time_str );

   /* Change date to julian format - DDD */
   calc_julian_day( date_str, julian_day );

   /* Format RRN: "YDDDhmmssjjj" */
   sprintf( rrn, "%1.1s%3.3s%5.5s%3.3s",time_date+3, julian_day,
                time_str+1, time_date+20 );
   return;
}/* This function is mainly for reversal. It is a generic function, but only a few cases is in use*/

BYTE get_orig_response_tx_key_for_reversal(char * msg_type, char * processing_code, char * voice_auth)
{  
   BYTE  ret_val;

   if (strcmp(msg_type, "0100") == 0)
   {
      if (strncmp(processing_code,      "00",2) == 0) ret_val = AUTH_AUTHORIZATION_RESPONSE;
      else if (strncmp(processing_code, "30",2) == 0) ret_val = AUTH_PRE_AUTHORIZATION_RESPONSE;
      else if (strncmp(processing_code, "31",2) == 0) ret_val = AUTH_BALANCE_INQUIRY_RESPONSE;
      else if (strncmp(processing_code, "38",2) == 0) ret_val = AUTH_CARD_VERIFICATION_RESPONSE;
      else if (strncmp(processing_code, "04",2) == 0) ret_val = AUTH_CHECK_VERIFICATION_RESPONSE;
      else if (strncmp(processing_code, "02",2) == 0) ret_val = AUTH_VOID_PRE_AUTHORIZATION_RESPONSE;
      else if (strncmp(processing_code, "11",2) == 0) ret_val = AUTH_QUASI_CASH_RESPONSE;
      else ret_val = AUTH_INVALID;
   } 
   else if (strcmp(msg_type, "0200") == 0)
   {
      if (strncmp(processing_code,      "00",2) == 0) ret_val = AUTH_SALE_RESPONSE;
      else if (strncmp(processing_code, "20",2) == 0) ret_val = AUTH_REFUND_RESPONSE;
      else if (strncmp(processing_code, "02",2) == 0) ret_val = AUTH_VOID_SALE_RESPONSE;
      else if (strncmp(processing_code, "22",2) == 0) ret_val = AUTH_VOID_REFUND_RESPONSE;
      else if (strncmp(processing_code, "01",2) == 0) ret_val = AUTH_CASH_ADVANCE_RESPONSE;
      else if (strncmp(processing_code, "04",2) == 0) ret_val = AUTH_CHECK_VERIFICATION_RESPONSE;
      else if (strncmp(processing_code, "09",2) == 0) ret_val = AUTH_SALE_CASH_RESPONSE;
      else if (strncmp(processing_code, "11",2) == 0) ret_val = AUTH_QUASI_CASH_RESPONSE;
      else ret_val = AUTH_INVALID;
   } 
   else if (strcmp(msg_type, "0220") == 0)
   {
      if (strncmp(processing_code,      "00",2) == 0) ret_val = AUTH_OFFLINE_SALE_RESPONSE;
      else if (strncmp(processing_code, "20",2) == 0) ret_val = AUTH_OFFLINE_REFUND_RESPONSE;
      else if (strncmp(processing_code, "02",2) == 0) ret_val = AUTH_SALE_ADJUSTMENT_RESPONSE;
      else if (strncmp(processing_code, "22",2) == 0) ret_val = AUTH_REFUND_ADJUSTMENT_RESPONSE;
      else if (strncmp(processing_code, "42",2) == 0) ret_val = AUTH_PAYMENT_ADJUSTMENT_RESPONSE;
      else ret_val = AUTH_INVALID;
   } 
   else if (strcmp(msg_type, "0320") == 0)
   {
      if (strncmp(processing_code, "90",2) == 0) ret_val = AUTH_SIGNATURE_DATA_RESPONSE; 
      ret_val = AUTH_BATCH_UPLOAD_RESPONSE;
   }
   else if (strcmp(msg_type, "0400") == 0) ret_val = AUTH_REVERSAL_RESPONSE;
   else if (strcmp(msg_type, "0500") == 0)
   {
      if (strncmp(processing_code,      "92",2) == 0) ret_val = AUTH_SETTLE_RESPONSE;
      else if (strncmp(processing_code, "96",2) == 0) ret_val = AUTH_SETTLE_TRAILER_RESPONSE;
      else if (strncmp(processing_code, "95",2) == 0) ret_val = AUTH_BATCH_DOWN_LINE_LOAD_RESPONSE;
      else ret_val = AUTH_INVALID;
   } 
   else if (strcmp(msg_type, "0800") == 0)
   {
      if (strncmp(processing_code,      "90",2) == 0) ret_val = AUTH_PIN_CHANGE_RESPONSE;
      else if (strncmp(processing_code, "91",2) == 0) ret_val = AUTH_STATISTICS_RESPONSE;
      else if (strncmp(processing_code, "92",2) == 0) ret_val = AUTH_LOGON_RESPONSE;
      else if (strncmp(processing_code, "93",2) == 0) ret_val = AUTH_INITIALIZATION_RESPONSE;
      else if (strncmp(processing_code, "99",2) == 0) ret_val = AUTH_TEST_RESPONSE;
      else ret_val = AUTH_INVALID;
   } 
   else if (strcmp(msg_type, "0830") == 0) ret_val = AUTH_PLEASE_WAIT_ADVICE_RESPONSE;
   else ret_val = AUTH_INVALID ;

   return( ret_val );
}

void format_date(pCHAR temp)
{
   struct timeb   time_structure;   // Time for ftime
   time_t long_time_since_1970;     // Number of seconds since 01/01/1970 A.D. 12:00 A.M.
   struct tm *current_time;         // Current time structure
   CHAR   temp1[4] = "0";

   ftime(&time_structure);
   long_time_since_1970 = time_structure.time;
   current_time = localtime(&long_time_since_1970);
   current_time->tm_mon++;
   if (current_time->tm_year >= 70)
      current_time->tm_year += 1900;
   else
      current_time->tm_year += 2000;
   itoa(current_time->tm_year, temp, 10);
   itoa(current_time->tm_mon, temp1 + 1, 10);
   if (strlen(temp1) == 2)
      memcpy(temp + 4, temp1, 2);
   else
      memcpy(temp + 4, temp1 + 1, 2);
   memset(temp1, 0, sizeof(temp1));
   temp1[0] = '0';
   itoa(current_time->tm_mday, temp1 + 1, 10);
   if (strlen(temp1) == 2)
      memcpy(temp + 6, temp1, 2);
   else
      memcpy(temp + 6, temp1 + 1, 2);
   memset(temp1, 0, sizeof(temp1));
   temp1[0] = '0';
   itoa(current_time->tm_hour, temp1 + 1, 10);
   if (strlen(temp1) == 2)
      memcpy(temp + 8, temp1, 2);
   else
      memcpy(temp + 8, temp1 + 1, 2);
   memset(temp1, 0, sizeof(temp1));
   temp1[0] = '0';
   itoa(current_time->tm_min, temp1 + 1, 10);
   if (strlen(temp1) == 2)
      memcpy(temp + 10, temp1, 2);
   else
      memcpy(temp + 10, temp1 + 1, 2);
   memset(temp1, 0, sizeof(temp1));
   temp1[0] = '0';
   itoa(current_time->tm_sec, temp1 + 1, 10);
   if (strlen(temp1) == 2)
      memcpy(temp + 12, temp1, 2);
   else
      memcpy(temp + 12, temp1 + 1, 2);
   return;
} 

void prepare_bch10_for_update(pAUTH_TX auth_tx)
{
   strcpy(db_recs.bch10.merchant_id,auth_tx->TLF01_details.merchant_id);
   strcpy(db_recs.bch10.transaction_id,auth_tx->TLF01_details.primary_key.transaction_id);
   strcpy(db_recs.bch10.tran_date,auth_tx->TLF01_details.date_yyyymmdd);
   strcpy(db_recs.bch10.tran_time,auth_tx->TLF01_details.time_hhmmss);
   strcpy(db_recs.bch10.tran_amount,auth_tx->TLF01_details.total_amount);
   strcpy(db_recs.bch10.processing_code,auth_tx->TLF01_details.processing_code);
   strcpy(db_recs.bch10.response_code,auth_tx->TLF01_details.response_code);
   strcpy(db_recs.bch10.auth_number,auth_tx->TLF01_details.auth_number);
   strcpy(db_recs.bch10.message_type,auth_tx->TLF01_details.message_type);
   strcpy(db_recs.bch10.card_nbr,auth_tx->TLF01_details.card_num);
   strcpy(db_recs.bch10.invoice_nbr,auth_tx->TLF01_details.invoice_number);
   strcpy(db_recs.bch10.settle_file_prefix,auth_tx->BIN01_details.settle_file_prefix);
   strcpy(db_recs.bch10.product_code,auth_tx->TLF01_details.product_code);
   strcpy(db_recs.bch10.sys_trace_audit_num,auth_tx->TLF01_details.sys_trace_audit_num);
   db_recs.bch10.bin_type = auth_tx->bin_type;
   strcpy(db_recs.bch10.pos_entry_mode,auth_tx->TLF01_details.pos_entry_mode);
   strcpy(db_recs.bch10.profile,auth_tx->TLF01_details.profile);
   strcpy(db_recs.bch10.exp_date,auth_tx->TLF01_details.exp_date);
   strcpy(db_recs.bch10.transmission_timestamp,auth_tx->TLF01_details.transmission_timestamp);
   strcpy(db_recs.bch10.mcard_banknet,auth_tx->TLF01_details.mcard_banknet);
   if(IsFieldNull(db_recs.bch10.mcard_banknet)) /* To store AMEX tran ID -DE31*/
	strcpy(db_recs.bch10.mcard_banknet,auth_tx->TLF01_details.visa_tran_id);
   strcpy (db_recs.bch10.cash_bonus, auth_tx->TLF01_details.cash_bonus);
   strcpy (db_recs.bch10.ticket_nbr, auth_tx->TLF01_details.ticket_nbr);
   strcpy (db_recs.bch10.odometer, auth_tx->TLF01_details.odometer);
   strcpy( db_recs.bch10.def_gross_amt, auth_tx->TLF01_details.def_gross_amt );
   strcpy( db_recs.bch10.term, auth_tx->TLF01_details.deferred_term_length );
   strcpy( db_recs.bch10.product_codes[19].code, auth_tx->TLF01_details.settlement_date );
   strcpy( db_recs.bch10.product_codes[6].amount, auth_tx->TLF01_details.pos_condition_code);/*Girija GB*/
   strcat( db_recs.bch10.product_codes[6].amount, auth_tx->TLF01_details.service_code );/*Girija GB*/
   /* Store Stand in flag in BCH10 also, This will be usefull for VOID/Reversal/Adjustment transactions*/
   strcpy( db_recs.bch10.product_codes[1].code, auth_tx->TLF01_details.product_codes[1].code);/*TF Phani*/
   if((auth_tx->TLF01_details.tx_key== AUTH_VOID_SALE_RESPONSE ) && 
	  (strcmp(auth_tx->TLF01_details.product_codes[1].code,STANDIN) == 0))
   {
    strcpy( db_recs.bch10.product_codes[1].code, VOIDED);
   }
	/* TF Phani-  Copy DE63 table Id 12- value */
	strcpy( db_recs.bch10.product_codes[14].amount, auth_tx->TLF01_details.product_codes[14].amount);/*TF PHani*/

	
   return;
} 

BYTE process_sale_trans(pAUTH_TX auth_tx)
{
   CHAR   primary_key[16] = "";
   CHAR   date_time[16] = "";
   CHAR   bch01_open_date[9] = "";
   CHAR   bch01_open_time[7] = "";
   LONG   total;
   INT    cnt;
   BYTE   auth_number[7]  = "";
   BYTE   rrn[13]         = "";
   TLF01  tlf01;
   double         start_time;
   double         end_time;
   double         duration;

   /* See if this is a duplicate. */
   memcpy( &tlf01, &auth_tx->TLF01_details, sizeof(TLF01) );

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_look_for_duplicate( &tlf01, auth_number, rrn );
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                           (float)duration, &TimingStats );
   }

   if ( result_code == PTEMSG_OK)
   {
      /* A duplicate has been found.
       * Update Auth_Tx with original's auth number and RRN.
       * Rollback any previous DB updates (i.e. ACF01)
       * Return success!
       */
      memcpy( auth_tx->TLF01_details.auth_number, auth_number, 6 );
      memcpy( auth_tx->TLF01_details.retrieval_ref_num,  rrn, 12 );

      rollback_the_update();
      return PTEMSG_OK;
   }
   else
   {
      strcpy(primary_key,auth_tx->TLF01_details.terminal_id);
      strcpy(primary_key + sizeof(db_recs.tlf01.terminal_id), "ACTIVE");

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      result_code = db_select_bch01(primary_key,&db_recs.bch01,err_msg);

      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_SELECT, 2, BCH01_DATA,
                              (float)duration, &TimingStats );
      }

      //create and Insert into BCH01, delete any ACTIVE trans. for this terminal 
      if (result_code == PTEMSG_NOT_FOUND)
      {
         //Delete BCH10 if any ACTIVE
         memset(&db_recs.bch10, 0, sizeof(BCH10));
         strcpy(db_recs.bch10.primary_key.device_id, auth_tx->TLF01_details.terminal_id);
         strcpy(db_recs.bch10.primary_key.batch_nbr, "ACTIVE");

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_delete_active_bch10(&db_recs.bch10,err_msg);
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_DELETE, 2, BCH10_DATA,
                                 (float)duration, &TimingStats );
         }

         memcpy(&db_recs.bch01,primary_key, sizeof(primary_key));

         //check if CREDIT sale or DEBIT sale
         if (auth_tx->bin_type =='D')
         {
            strcpy(db_recs.bch01.total_debit_amt, auth_tx->TLF01_details.total_amount);
            if (atoi(db_recs.bch01.total_debit_amt) != 0)
               strcpy(db_recs.bch01.total_debit_cnt, "0001");
         }
         else if ( (auth_tx->bin_type == 'C') || (auth_tx->bin_type == 'E') )
         {
            strcpy(db_recs.bch01.total_credit_amt, auth_tx->TLF01_details.total_amount);
            if (atoi(db_recs.bch01.total_credit_amt) != 0)
               strcpy(db_recs.bch01.total_credit_cnt, "0001");
         }

         format_date(date_time);
         if (strlen(auth_tx->TLF01_details.date_yyyymmdd) != 0)
            strcpy(db_recs.bch01.open_date, auth_tx->TLF01_details.date_yyyymmdd);
         else
         {
            memset(db_recs.bch01.open_date, 0, sizeof(db_recs.bch01.open_date));
            strncpy(db_recs.bch01.open_date, date_time, 8);
         }

         if (strlen(auth_tx->TLF01_details.time_hhmmss) != 0)
            strcpy(db_recs.bch01.open_time, auth_tx->TLF01_details.time_hhmmss);
         else
         {
            memset(db_recs.bch01.open_time, 0, sizeof(db_recs.bch01.open_time));
            strncpy(db_recs.bch01.open_time, date_time + 8, 6);
         }

         strcpy(bch01_open_time,db_recs.bch01.open_time);
         strcpy(bch01_open_date,db_recs.bch01.open_date);
         strcpy(db_recs.bch01.batch_status,"A");
         strcpy(db_recs.bch01.merchant_id,auth_tx->TLF01_details.merchant_id);

         if (strcmp(auth_tx->TLF01_details.organization_id, "GES") == 0)
            strcpy(db_recs.bch01.visa_merchant_id,"GES");
         else
            strcpy(db_recs.bch01.visa_merchant_id,auth_tx->TLF01_details.visa_merchant_id);

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_insert_bch01(&db_recs.bch01,err_msg);
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_INSERT, 2, BCH01_DATA,
                                 (float)duration, &TimingStats );
         }

         if (result_code != PTEMSG_OK) return(PTEMSG_INSERT_FAILED);
         updates_to_db_made = true;
      }

      // bch01 record is found
      else if (result_code == PTEMSG_OK)
      {
         if (auth_tx->bin_type == 'D')
         {
            total = atol(db_recs.bch01.total_debit_amt)+atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_debit_amt, "%012d",total);
            if (atol(db_recs.bch01.total_debit_amt) != 0L)
               cnt = atoi(db_recs.bch01.total_debit_cnt) + 1;
            sprintf(db_recs.bch01.total_debit_cnt, "%04d",cnt);
         }
         else if ( (auth_tx->bin_type=='C') || (auth_tx->bin_type=='E') )
         {
            total = atol(db_recs.bch01.total_credit_amt)+atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_credit_amt, "%012d",total);
            if (atol(db_recs.bch01.total_credit_amt) != 0L)
               cnt = atoi(db_recs.bch01.total_credit_cnt) + 1;
            sprintf(db_recs.bch01.total_credit_cnt, "%04d",cnt);
         }

         //copy date and time values into temporary variables
         strcpy(bch01_open_time,db_recs.bch01.open_time);
         strcpy(bch01_open_date,db_recs.bch01.open_date);

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         if (result_code = db_update_bch01(&db_recs.bch01,err_msg) != PTEMSG_OK)
         {
            return(PTEMSG_UPDATE_FAILED);
         }
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_UPDATE, 2, BCH01_DATA,
                                 (float)duration, &TimingStats );
         }
         updates_to_db_made = true;
      }
      else
      {
         return(PTEMSG_UPDATE_FAILED);
      }

      memset(&db_recs.bch10, 0, sizeof(BCH10));
      strcpy(db_recs.bch10.open_date,bch01_open_date);
      strcpy(db_recs.bch10.open_time,bch01_open_time);
      strcpy(db_recs.bch10.primary_key.device_id,auth_tx->TLF01_details.terminal_id);
      strcpy(db_recs.bch10.primary_key.retrieval_ref_num,auth_tx->TLF01_details.retrieval_ref_num);
      strcpy(db_recs.bch10.primary_key.batch_nbr,  "ACTIVE");
      db_recs.bch10.tx_key = auth_tx->TLF01_details.tx_key;
      prepare_bch10_for_update(auth_tx);

      /* Convert message type to a request type, for standardization. */
      convert_msgtype_to_request( db_recs.bch10.message_type );

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      if ((result_code = db_insert_bch10(&db_recs.bch10,err_msg)) != PTEMSG_OK)
      {
         return(PTEMSG_INSERT_FAILED);
      }

      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_INSERT, 2, BCH10_DATA,
                              (float)duration, &TimingStats );
      }

      updates_to_db_made = true;
      if (auth_tx->TLF01_details.tx_key == AUTH_SALES_COMPLETION_RESPONSE)
      {
         memset(&db_recs.bch20, 0, sizeof(BCH20));
         strcpy(db_recs.bch20.primary_key.device_id, auth_tx->TLF01_details.terminal_id);
         strcpy(db_recs.bch20.primary_key.batch_nbr, "ACTIVE");
         strcpy(db_recs.bch20.merchant_id, auth_tx->TLF01_details.merchant_id);
         strcpy(db_recs.bch20.sys_trace_audit_num, auth_tx->TLF01_details.sys_trace_audit_num);

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         db_update_bch20_by_stan(&db_recs.bch20, err_msg);
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_UPDATE, 2, BCH20_DATA,
                                 (float)duration, &TimingStats );
         }
      }
   }
   return PTEMSG_OK;
}

BYTE process_auth_trans(pAUTH_TX auth_tx)
{
   BYTE   retval = PTEMSG_OK;
   CHAR   primary_key[16] = "";
   CHAR   date_time[16]   = "";
   BYTE   auth_number[7]  = "";
   BYTE   rrn[13]         = "";
   TLF01  tlf01;
   double         start_time;
   double         end_time;
   double         duration;

   /* See if this is a duplicate. */
   memcpy( &tlf01, &auth_tx->TLF01_details, sizeof(TLF01) );

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_look_for_duplicate( &tlf01, auth_number, rrn );
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                           (float)duration, &TimingStats );
   }
   if ( result_code == PTEMSG_OK)
   {
      /* A duplicate has been found.
       * Update Auth_Tx with original's auth number and RRN.
       * Rollback any previous DB updates (i.e. ACF01)
       * Return success!
       */
      memcpy( auth_tx->TLF01_details.auth_number, auth_number, 6 );
      memcpy( auth_tx->TLF01_details.retrieval_ref_num,  rrn, 12 );

      rollback_the_update();
   }
   else
   {
      memset(&db_recs.bch20, 0, sizeof(BCH20));
      strcpy(db_recs.bch20.primary_key.device_id, auth_tx->TLF01_details.terminal_id);
      strcpy(db_recs.bch20.primary_key.batch_nbr, "ACTIVE");
      strcpy(db_recs.bch20.primary_key.retrieval_ref_num, auth_tx->TLF01_details.retrieval_ref_num);

      format_date(date_time);

      strncpy(db_recs.bch20.open_date, date_time, 8);
      strncpy(db_recs.bch20.open_time,  date_time + 8, 6);

      strcpy(db_recs.bch20.merchant_id, auth_tx->TLF01_details.merchant_id);
      strcpy(db_recs.bch20.transaction_id, auth_tx->TLF01_details.primary_key.transaction_id);
      strcpy(db_recs.bch20.tran_date, auth_tx->TLF01_details.date_yyyymmdd);
      strcpy(db_recs.bch20.tran_time, auth_tx->TLF01_details.time_hhmmss);
      strcpy(db_recs.bch20.tran_amount, auth_tx->TLF01_details.total_amount);
      strcpy(db_recs.bch20.processing_code, auth_tx->TLF01_details.processing_code);
      strcpy(db_recs.bch20.response_code, auth_tx->TLF01_details.response_code);
      strcpy(db_recs.bch20.auth_number, auth_tx->TLF01_details.auth_number);
      strcpy(db_recs.bch20.message_type, auth_tx->TLF01_details.message_type);
      strcpy(db_recs.bch20.card_nbr, auth_tx->TLF01_details.card_num);
      strcpy(db_recs.bch20.invoice_nbr, auth_tx->TLF01_details.invoice_number);
      strcpy(db_recs.bch20.settle_file_prefix, auth_tx->BIN01_details.settle_file_prefix);
      strcpy(db_recs.bch20.product_code, auth_tx->TLF01_details.product_code);
      strcpy(db_recs.bch20.sys_trace_audit_num, auth_tx->TLF01_details.sys_trace_audit_num);
      strcpy(db_recs.bch20.ticket_nbr, auth_tx->TLF01_details.ticket_nbr);
	  	/* TF Phani-  Copy DE63 table Id 12- value */
	  strcpy( db_recs.bch20.product_codes[14].amount, auth_tx->TLF01_details.product_codes[14].amount);/*TF PHani*/
      strcpy(db_recs.bch20.odometer, auth_tx->TLF01_details.odometer);
      db_recs.bch20.bin_type = auth_tx->bin_type;
      db_recs.bch20.tx_key=auth_tx->TLF01_details.tx_key;
      strcpy(db_recs.bch20.pos_entry_mode, auth_tx->TLF01_details.pos_entry_mode);
      strcpy(db_recs.bch20.profile, auth_tx->TLF01_details.profile);
      strcpy(db_recs.bch20.exp_date, auth_tx->TLF01_details.exp_date);
      strcpy(db_recs.bch20.transmission_timestamp, auth_tx->TLF01_details.transmission_timestamp);
      strcpy(db_recs.bch20.mcard_banknet, auth_tx->TLF01_details.mcard_banknet);
      strcpy(db_recs.bch20.processed, "N");
      strcpy( db_recs.bch20.def_gross_amt, auth_tx->TLF01_details.def_gross_amt );
      strcpy( db_recs.bch20.term, auth_tx->TLF01_details.deferred_term_length );
	  strcpy( db_recs.bch20.product_codes[1].code, auth_tx->TLF01_details.product_codes[1].code);/*TF Ajay*/
	  if(IsFieldNull(db_recs.bch20.mcard_banknet)) /* To store AMEX tran ID -DE31*/
	  strcpy(db_recs.bch20.mcard_banknet,auth_tx->TLF01_details.visa_tran_id);

      /* Convert message type to a request type, for standardization. */
      convert_msgtype_to_request( db_recs.bch20.message_type );

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      if ((result_code= db_insert_bch20(&db_recs.bch20, err_msg)) != PTEMSG_OK)
         retval = PTEMSG_INSERT_FAILED;
      else
         updates_to_db_made = true;

      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_INSERT, 2, BCH20_DATA,
                              (float)duration, &TimingStats );
      }
   }
   return( retval );
}

BYTE process_refund_trans(pAUTH_TX auth_tx)
{
   CHAR primary_key[16] = "";
   LONG total;
   CHAR bch01_open_date[9]="";
   CHAR bch01_open_time[7]="";
   CHAR date_time[16] = "";
   INT cnt;
   BYTE   auth_number[7]  = "";
   BYTE   rrn[13]         = "";
   TLF01  tlf01;
   double         start_time;
   double         end_time;
   double         duration;

   /* See if this is a duplicate. */
   memcpy( &tlf01, &auth_tx->TLF01_details, sizeof(TLF01) );

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_look_for_duplicate( &tlf01, auth_number, rrn );
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                           (float)duration, &TimingStats );
   }

   if ( result_code == PTEMSG_OK)
   {
      /* A duplicate has been found.
       * Update Auth_Tx with original's auth number and RRN.
       * Rollback any previous DB updates (i.e. ACF01)
       * Return success!
       */
      memcpy( auth_tx->TLF01_details.auth_number, auth_number, 6 );
      memcpy( auth_tx->TLF01_details.retrieval_ref_num,  rrn, 12 );

      rollback_the_update();
      return PTEMSG_OK;
   }
   else
   {
      strcpy(primary_key, auth_tx->TLF01_details.terminal_id);
      strcpy(primary_key + sizeof(db_recs.tlf01.terminal_id),"ACTIVE");
      memset(&db_recs.bch01, 0, sizeof(BCH01));

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      result_code = db_select_bch01(primary_key, &db_recs.bch01, err_msg);
      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_SELECT, 2, BCH01_DATA,
                              (float)duration, &TimingStats );
      }

      if (result_code == PTEMSG_OK)                 
      {
         if (auth_tx->bin_type=='D')
         {
            total = atol(db_recs.bch01.total_debit_refund_amt)+atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_debit_refund_amt, "%012d",total);
            if (atol(db_recs.bch01.total_debit_refund_amt) != 0L)
               cnt = atoi(db_recs.bch01.total_debit_refund_cnt) + 1;
            sprintf(db_recs.bch01.total_debit_refund_cnt, "%04d",cnt);
         }
         else if ( (auth_tx->bin_type == 'C') || (auth_tx->bin_type == 'E') )
         {
            total = atol(db_recs.bch01.total_credit_refund_amt)+atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_credit_refund_amt, "%012d",total);
            if (atol(db_recs.bch01.total_credit_refund_amt) != 0L)
               cnt = atoi(db_recs.bch01.total_credit_refund_cnt) + 1;
            sprintf(db_recs.bch01.total_credit_refund_cnt, "%04d",cnt);
         }

         //copy values into temporary variables
         strcpy(bch01_open_time,db_recs.bch01.open_time);
         strcpy(bch01_open_date,db_recs.bch01.open_date);
         if (strcmp(auth_tx->TLF01_details.organization_id, "GES") == 0)
            strcpy(db_recs.bch01.visa_merchant_id,"GES");
         else
            strcpy(db_recs.bch01.visa_merchant_id,auth_tx->TLF01_details.visa_merchant_id);

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         if (result_code = db_update_bch01(&db_recs.bch01,err_msg) != PTEMSG_OK)
         {
            return(PTEMSG_UPDATE_FAILED);
         }

         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_UPDATE, 2, BCH01_DATA,
                                 (float)duration, &TimingStats );
         }
         updates_to_db_made = true;   
      }
      else if (result_code == PTEMSG_NOT_FOUND)
      {
         //Delete BCH10 if any ACTIVE
         memset(&db_recs.bch10, 0, sizeof(BCH10));
         strcpy(db_recs.bch10.primary_key.device_id,auth_tx->TLF01_details.terminal_id);
	      strcpy(db_recs.bch10.primary_key.batch_nbr,  "ACTIVE");

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_delete_bch10(&db_recs.bch10,err_msg);
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_DELETE, 2, BCH10_DATA,
                                 (float)duration, &TimingStats );
         }

         //create and Insert  BCH01
         memcpy(&db_recs.bch01,primary_key,sizeof(primary_key)); //copy the primary Key

         //check if CREDIT refund or DEBIT refund
         if (auth_tx->bin_type =='D')
         {
            strcpy(db_recs.bch01.total_debit_refund_amt, auth_tx->TLF01_details.total_amount);
            if (atoi(db_recs.bch01.total_debit_refund_amt) != 0)
               strcpy(db_recs.bch01.total_debit_refund_cnt, "0001");
         }
         else if ( (auth_tx->bin_type == 'C') || (auth_tx->bin_type == 'E') )
         {
            strcpy(db_recs.bch01.total_credit_refund_amt, auth_tx->TLF01_details.total_amount);
            if (atoi(db_recs.bch01.total_credit_refund_amt) != 0)
               strcpy(db_recs.bch01.total_credit_refund_cnt, "0001");
         }
         format_date(date_time);
         if (strlen(auth_tx->TLF01_details.date_yyyymmdd) != 0)
            strcpy(db_recs.bch01.open_date, auth_tx->TLF01_details.date_yyyymmdd);
         else
         {
            memset(db_recs.bch01.open_date, 0, sizeof(db_recs.bch01.open_date));
            strncpy(db_recs.bch01.open_date, date_time, 8);
         }
         if (strlen(auth_tx->TLF01_details.time_hhmmss) != 0)
            strcpy(db_recs.bch01.open_time, auth_tx->TLF01_details.time_hhmmss);
         else
         {
            memset(db_recs.bch01.open_time, 0, sizeof(db_recs.bch01.open_time));
            strncpy(db_recs.bch01.open_time,  date_time + 8, 6);
         }
         strcpy(bch01_open_time,db_recs.bch01.open_time);
         strcpy(bch01_open_date,db_recs.bch01.open_date);
         strcpy(db_recs.bch01.batch_status,"A");
         strcpy(db_recs.bch01.merchant_id,auth_tx->TLF01_details.merchant_id);
         if (strcmp(auth_tx->TLF01_details.organization_id, "GES") == 0)
            strcpy(db_recs.bch01.visa_merchant_id,"GES");
         else
            strcpy(db_recs.bch01.visa_merchant_id,auth_tx->TLF01_details.visa_merchant_id);

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_insert_bch01(&db_recs.bch01,err_msg);
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_INSERT, 2, BCH01_DATA,
                                 (float)duration, &TimingStats );
         }

         if (result_code != PTEMSG_OK) return(PTEMSG_INSERT_FAILED);
         updates_to_db_made = true;
      }
      else return(PTEMSG_INSERT_FAILED);

      //Insert REFUND transaction into BCH10 
      memset(&db_recs.bch10, 0, sizeof(BCH10));
      strcpy(db_recs.bch10.open_date,bch01_open_date);
      strcpy(db_recs.bch10.open_time,bch01_open_time);
      strcpy(db_recs.bch10.primary_key.device_id,auth_tx->TLF01_details.terminal_id);
      strcpy(db_recs.bch10.primary_key.retrieval_ref_num,auth_tx->TLF01_details.retrieval_ref_num);
      strcpy(db_recs.bch10.primary_key.batch_nbr,  "ACTIVE");
      db_recs.bch10.tx_key = auth_tx->TLF01_details.tx_key;
      prepare_bch10_for_update(auth_tx);

      /* Convert message type to a request type, for standardization. */
      convert_msgtype_to_request( db_recs.bch10.message_type );

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      if ((result_code= db_insert_bch10(&db_recs.bch10,err_msg))!= PTEMSG_OK)
      {
         return(PTEMSG_INSERT_FAILED);
      }
      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_INSERT, 2, BCH01_DATA,
                              (float)duration, &TimingStats );
      }
      updates_to_db_made = true;
   }
   return PTEMSG_OK;
}

BYTE process_void_trans(pAUTH_TX auth_tx)
{
   long total ;
   CHAR primary_key[16] = "";
   int cnt;
   BYTE   auth_number[7]  = "";
   BYTE   rrn[13]         = "";
   TLF01  tlf01;
   double         start_time;
   double         end_time;
   double         duration;

   /* See if this is a duplicate. */
   memcpy( &tlf01, &auth_tx->TLF01_details, sizeof(TLF01) );

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_look_for_duplicate( &tlf01, auth_number, rrn );
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                           (float)duration, &TimingStats );
   }

   if ( result_code == PTEMSG_OK)
   {
      /* A duplicate has been found.
       * Rollback any previous DB updates (i.e. ACF01)
       * Return success!
       */
      rollback_the_update();
      return PTEMSG_OK;
   }
   memset(&db_recs.bch10, 0, sizeof(BCH10));
   strcpy(db_recs.bch10.primary_key.device_id, auth_tx->TLF01_details.terminal_id);
   strcpy(db_recs.bch10.primary_key.batch_nbr, "ACTIVE");
   strcpy(db_recs.bch10.primary_key.retrieval_ref_num,auth_tx->TLF01_details.orig_retrieval_ref_num);     
   db_recs.bch10.tx_key = auth_tx->TLF01_details.tx_key;
   prepare_bch10_for_update(auth_tx);

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   if ((result_code= db_update_bch10(&db_recs.bch10, err_msg)) != PTEMSG_OK)
   {
      return(PTEMSG_UPDATE_FAILED);   
   }
   else
   { 
      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                              (float)duration, &TimingStats );
      }

      updates_to_db_made = true;
      strcpy(primary_key, auth_tx->TLF01_details.terminal_id);
      strcpy(primary_key + sizeof(db_recs.tlf01.terminal_id),"ACTIVE");
      memset(&db_recs.bch01,0,sizeof(BCH01));

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      result_code = db_select_bch01(primary_key,&db_recs.bch01,err_msg);
      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                              (float)duration, &TimingStats );
      }
      if ( result_code == PTEMSG_OK )
      {
         if (auth_tx->bin_type =='D')
         {
            total = atol(db_recs.bch01.total_debit_amt) - atol(auth_tx->TLF01_details.orig_amount);
            sprintf(db_recs.bch01.total_debit_amt, "%012d",total);
            cnt = atoi(db_recs.bch01.total_debit_cnt) - 1;
            sprintf(db_recs.bch01.total_debit_cnt, "%04d", cnt);                        
         }
         else
         {
            if ((auth_tx->TLF01_details.tx_key == AUTH_VOID_SALE_RESPONSE)         ||
                (auth_tx->TLF01_details.tx_key == AUTH_VOID_CASH_ADVANCE_RESPONSE) ||
                (auth_tx->TLF01_details.tx_key == AUTH_VOID_RELOAD_RESPONSE)       ||
                (auth_tx->TLF01_details.tx_key == AUTH_OFFLINE_VOID_SALE_RESPONSE))
            {
               total = atol(db_recs.bch01.total_void_credit_amt) + atol(auth_tx->TLF01_details.orig_amount);
               sprintf(db_recs.bch01.total_void_credit_amt, "%012d",total); 
               cnt = atoi(db_recs.bch01.total_void_credit_cnt) + 1;
               sprintf(db_recs.bch01.total_void_credit_cnt, "%04d",cnt); 

               total = atol(db_recs.bch01.total_credit_amt) - atol(auth_tx->TLF01_details.orig_amount);
               sprintf(db_recs.bch01.total_credit_amt, "%012d",total);
               cnt = atoi(db_recs.bch01.total_credit_cnt) - 1;
               sprintf(db_recs.bch01.total_credit_cnt, "%04d",cnt);         
            }
            else if( (auth_tx->TLF01_details.tx_key == AUTH_VOID_REFUND_RESPONSE) ||
                     (auth_tx->TLF01_details.tx_key == AUTH_OFFLINE_VOID_REFUND_RESPONSE))
            {
               total = atol(db_recs.bch01.total_void_credit_refund_amt) + atol(auth_tx->TLF01_details.orig_amount);
               sprintf(db_recs.bch01.total_void_credit_refund_amt, "%012d",total);                                                   
               cnt = atoi(db_recs.bch01.total_void_credit_refund_cnt) + 1;
               sprintf(db_recs.bch01.total_void_credit_refund_cnt, "%04d",cnt);  

               total = atol(db_recs.bch01.total_credit_refund_amt) - atol(auth_tx->TLF01_details.orig_amount);
               sprintf(db_recs.bch01.total_credit_refund_amt, "%012d",total);
               cnt = atoi(db_recs.bch01.total_credit_refund_cnt) - 1;
               sprintf(db_recs.bch01.total_credit_refund_cnt, "%04d",cnt);      
            }
         }

         strcpy(db_recs.bch01.merchant_id,auth_tx->TLF01_details.merchant_id);
         if (strcmp(auth_tx->TLF01_details.organization_id, "GES") == 0)
            strcpy(db_recs.bch01.visa_merchant_id,"GES");
         else
            strcpy(db_recs.bch01.visa_merchant_id,auth_tx->TLF01_details.visa_merchant_id);

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         if (result_code = db_update_bch01(&db_recs.bch01,err_msg) != PTEMSG_OK)
         {
            return(PTEMSG_UPDATE_FAILED);
         }
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                                 (float)duration, &TimingStats );
         }
         updates_to_db_made = true;
      }
   }
   return PTEMSG_OK;
}

BYTE process_adjustments(pAUTH_TX auth_tx)
{
   CHAR orig_amount[13];
   CHAR new_amount[13];
   long diff, total ;
   CHAR primary_key[16] = "";
   int cnt;
   BYTE   auth_number[7]  = "";
   BYTE   rrn[13]         = "";
   TLF01  tlf01;
   double         start_time;
   double         end_time;
   double         duration;

   /* See if this is a duplicate. */
   memcpy( &tlf01, &auth_tx->TLF01_details, sizeof(TLF01) );

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_look_for_duplicate( &tlf01, auth_number, rrn );
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                           (float)duration, &TimingStats );
   }

   if ( result_code == PTEMSG_OK)
   {
      /* A duplicate has been found.
       * Rollback any previous DB updates (i.e. ACF01)
       * Return success!
       */
      rollback_the_update();
      return PTEMSG_OK;
   }
   strcpy(orig_amount, auth_tx->TLF01_details.orig_amount);
   strcpy(new_amount, auth_tx->TLF01_details.total_amount);
   memset(&db_recs.bch10, 0, sizeof(BCH10));
   strcpy(db_recs.bch10.primary_key.device_id, auth_tx->TLF01_details.terminal_id);
   strcpy(db_recs.bch10.primary_key.batch_nbr, "ACTIVE");
   strcpy(db_recs.bch10.primary_key.retrieval_ref_num,auth_tx->TLF01_details.orig_retrieval_ref_num);     
   strcpy(auth_tx->TLF01_details.retrieval_ref_num,auth_tx->TLF01_details.orig_retrieval_ref_num);     
   db_recs.bch10.tx_key = auth_tx->TLF01_details.tx_key;
   prepare_bch10_for_update(auth_tx);

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   if ((result_code= db_update_bch10(&db_recs.bch10,err_msg))!= PTEMSG_OK)
   {
      return(PTEMSG_UPDATE_FAILED);   
   }
   else
   { 
      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_UPDATE, 2, BCH10_DATA,
                              (float)duration, &TimingStats );
      }

      updates_to_db_made = true;
      strcpy(primary_key, auth_tx->TLF01_details.terminal_id);
      strcpy(primary_key + sizeof(db_recs.tlf01.terminal_id), "ACTIVE");
      memset(&db_recs.bch01,0,sizeof(BCH01));

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      result_code = db_select_bch01(primary_key, &db_recs.bch01,err_msg);
      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                              (float)duration, &TimingStats );
      }

      if ( result_code == PTEMSG_OK )
      {
         if (auth_tx->bin_type =='D')
         {
            total = atol(db_recs.bch01.total_debit_amt) - atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_debit_amt, "%012d",total);
            cnt = atoi(db_recs.bch01.total_debit_cnt) - 1;
            sprintf(db_recs.bch01.total_debit_cnt, "%04d",cnt);                        
         }
         else
         {
            if (auth_tx->TLF01_details.tx_key == AUTH_SALE_ADJUSTMENT_RESPONSE)
            {
               diff = atol(orig_amount) - atol(new_amount);
               total = atol(db_recs.bch01.total_credit_amt) - (diff);
               sprintf(db_recs.bch01.total_credit_amt, "%012d",total);                                                   
            }
            else if (auth_tx->TLF01_details.tx_key == AUTH_REFUND_ADJUSTMENT_RESPONSE)
            {
               diff = atol(orig_amount) - atol(new_amount);
               total = atol(db_recs.bch01.total_credit_refund_amt) - (diff);
               sprintf(db_recs.bch01.total_credit_refund_amt, "%012d",total);
            }
         }

         strcpy(db_recs.bch01.merchant_id, auth_tx->TLF01_details.merchant_id);
         if (strcmp(auth_tx->TLF01_details.organization_id, "GES") == 0)
            strcpy(db_recs.bch01.visa_merchant_id,"GES");
         else
            strcpy(db_recs.bch01.visa_merchant_id, auth_tx->TLF01_details.visa_merchant_id);

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         if (result_code = db_update_bch01(&db_recs.bch01, err_msg) != PTEMSG_OK)
         {
            return(PTEMSG_UPDATE_FAILED);
         }
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_UPDATE, 2, BCH01_DATA,
                                 (float)duration, &TimingStats );
         }
         updates_to_db_made = true;
      }
   }
   return PTEMSG_OK;
}

BYTE process_reversal_non_void_trans(pAUTH_TX auth_tx, BYTE temp_tx_key)
{
   LONG total;
   CHAR primary_key[16] = "";
   INT cnt;
   BYTE   auth_number[7]  = "";
   BYTE   rrn[13]         = "";
   TLF01  tlf01;
   double         start_time;
   double         end_time;
   double         duration;

   /* See if this is a duplicate. */
   memcpy( &tlf01, &auth_tx->TLF01_details, sizeof(TLF01) );

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_look_for_duplicate( &tlf01, auth_number, rrn );
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                           (float)duration, &TimingStats );
   }

   if ( result_code == PTEMSG_OK)
   {
      /* A duplicate has been found.
       * Rollback any previous DB updates (i.e. ACF01)
       * Return success!
       */
      rollback_the_update();
      return PTEMSG_OK;
   }
   strcpy(primary_key,auth_tx->TLF01_details.terminal_id);
   strcpy(primary_key + sizeof(db_recs.tlf01.terminal_id), "ACTIVE");
   memset(&db_recs.bch01, 0, sizeof(BCH01));

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_select_bch01(primary_key, &db_recs.bch01, err_msg);                 
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, BCH01_DATA,
                           (float)duration, &TimingStats );
   }
   if ( result_code == PTEMSG_OK )
   {
      if (auth_tx->bin_type == 'D')
      {
         if (temp_tx_key == AUTH_REFUND_RESPONSE)
         {
            total = atol(db_recs.bch01.total_debit_refund_amt) - atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_debit_refund_amt, "%012d",total);
            cnt = atoi(db_recs.bch01.total_debit_refund_cnt) - 1;
            sprintf(db_recs.bch01.total_debit_refund_cnt, "%04d",cnt); 
         }
         else
         {
            total = atol(db_recs.bch01.total_debit_amt) - atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_debit_amt, "%012d",total);
            cnt = atoi(db_recs.bch01.total_debit_cnt) - 1;
            sprintf(db_recs.bch01.total_debit_cnt, "%04d",cnt); 
         }
      }
      else if ( (auth_tx->bin_type == 'C') || (auth_tx->bin_type == 'E') )
      {
         if (temp_tx_key == AUTH_REFUND_RESPONSE)
         {
            total = atol(db_recs.bch01.total_credit_refund_amt) - atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_credit_refund_amt, "%012d",total);
            cnt = atoi(db_recs.bch01.total_credit_refund_cnt) - 1;
            sprintf(db_recs.bch01.total_credit_refund_cnt, "%04d",cnt); 
         }
         else
         {
            total = atol(db_recs.bch01.total_credit_amt) - atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_credit_amt, "%012d",total);                                                   
            cnt = atoi(db_recs.bch01.total_credit_cnt) - 1;
            sprintf(db_recs.bch01.total_credit_cnt, "%04d",cnt); 
         }
      }

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      if (result_code = db_update_bch01(&db_recs.bch01,err_msg) != PTEMSG_OK)
      {
         return(PTEMSG_UPDATE_FAILED);
      }

      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                              (float)duration, &TimingStats );
      }
      updates_to_db_made = true;
   }
   else
   {
      return(PTEMSG_UPDATE_FAILED);
   }
   return PTEMSG_OK;
}

BYTE process_reversal_void_trans(pAUTH_TX auth_tx)
{
   int cnt;
   long total ;
   CHAR primary_key[16] = "";
   BYTE   auth_number[7]  = "";
   BYTE   rrn[13]         = "";
   TLF01  tlf01;
   double         start_time;
   double         end_time;
   double         duration;

   /* See if this is a duplicate. */
   memcpy( &tlf01, &auth_tx->TLF01_details, sizeof(TLF01) );

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_look_for_duplicate( &tlf01, auth_number, rrn );
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                           (float)duration, &TimingStats );
   }

   if ( result_code == PTEMSG_OK)
   {
      /* A duplicate has been found.
       * Rollback any previous DB updates (i.e. ACF01)
       * Return success!
       */
      rollback_the_update();
      return PTEMSG_OK;
   }
   memset(&db_recs.bch10, 0, sizeof(BCH10));
   strcpy(db_recs.bch10.primary_key.device_id, auth_tx->TLF01_details.terminal_id);
   strcpy(db_recs.bch10.primary_key.batch_nbr, "ACTIVE");
   strcpy(db_recs.bch10.primary_key.retrieval_ref_num,auth_tx->TLF01_details.orig_retrieval_ref_num);     
   prepare_bch10_for_update(auth_tx);
   if (OrigTxKey == AUTH_VOID_SALE_RESPONSE)
   {
      db_recs.bch10.tx_key = AUTH_SALE_RESPONSE;
      memcpy( db_recs.bch10.processing_code, "00", 2 );
   }
   else if (OrigTxKey == AUTH_VOID_REFUND_RESPONSE)
   {
      db_recs.bch10.tx_key = AUTH_REFUND_RESPONSE;
      memcpy( db_recs.bch10.processing_code, "20", 2 );
   }
   else if (OrigTxKey == AUTH_VOID_CASH_ADVANCE_RESPONSE)
   {
      db_recs.bch10.tx_key = AUTH_CASH_ADVANCE_RESPONSE;
      memcpy( db_recs.bch10.processing_code, "01", 2 );
   }

   /* SCR 12502 -ThoughtFocus */
   else if (OrigTxKey == AUTH_VOID_RELOAD_RESPONSE)
   {
      db_recs.bch10.tx_key = AUTH_RELOAD_RESPONSE;
      memcpy( db_recs.bch10.processing_code, "21", 2 );
   }
   else if (OrigTxKey == AUTH_OFFLINE_VOID_SALE_RESPONSE ||
            OrigTxKey == AUTH_SALE_ADJUSTMENT_RESPONSE)
   {
      db_recs.bch10.tx_key = AUTH_OFFLINE_SALE_RESPONSE;
      memcpy( db_recs.bch10.processing_code, "00", 2 );
   }
   else if (OrigTxKey == AUTH_OFFLINE_VOID_REFUND_RESPONSE ||
            OrigTxKey == AUTH_REFUND_ADJUSTMENT_RESPONSE)
   {
      db_recs.bch10.tx_key = AUTH_OFFLINE_REFUND_RESPONSE;
      memcpy( db_recs.bch10.processing_code, "20", 2 );
   }


   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   if ((result_code= db_update_bch10(&db_recs.bch10, err_msg))!= PTEMSG_OK)
   {
      return(PTEMSG_UPDATE_FAILED);
   }

   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_UPDATE, 2, BCH10_DATA,
                           (float)duration, &TimingStats );
   }

   updates_to_db_made = true;
   strcpy(primary_key,auth_tx->TLF01_details.terminal_id);
   strcpy(primary_key + sizeof(db_recs.tlf01.terminal_id),"ACTIVE");
   memset(&db_recs.bch01,0,sizeof(BCH01));

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_select_bch01(primary_key,&db_recs.bch01,err_msg);
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, BCH01_DATA,
                           (float)duration, &TimingStats );
   }

   if ( result_code == PTEMSG_OK )
   {
      if (auth_tx->bin_type=='D')
      {
         total = atol(db_recs.bch01.total_debit_amt) + atol(auth_tx->TLF01_details.total_amount);
         sprintf(db_recs.bch01.total_debit_amt, "%012d",total);
         cnt = atoi(db_recs.bch01.total_debit_cnt) + 1;
         sprintf(db_recs.bch01.total_debit_cnt, "%04d",cnt);
      }
      else if ( (auth_tx->bin_type == 'C') || (auth_tx->bin_type == 'E') )
      {
         total = atol(db_recs.bch01.total_credit_amt) + atol(auth_tx->TLF01_details.total_amount);
         sprintf(db_recs.bch01.total_credit_amt, "%012d",total);
         cnt = atoi(db_recs.bch01.total_credit_cnt) + 1;
         sprintf(db_recs.bch01.total_credit_cnt, "%04d",cnt);

         /* Deduct the void totals also */
		 /* SCR 12502 -ThoughtFocus */
       /* if (auth_tx->TLF01_details.tx_key == AUTH_VOID_SALE_RESPONSE)*/
		 if (auth_tx->TLF01_details.tx_key == AUTH_VOID_SALE_RESPONSE ||
             auth_tx->TLF01_details.tx_key == AUTH_VOID_RELOAD_RESPONSE)
         {
            total = atol(db_recs.bch01.total_void_credit_amt) - atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_void_credit_amt, "%012d",total);
            cnt = atoi(db_recs.bch01.total_void_credit_cnt) - 1;
            sprintf(db_recs.bch01.total_void_credit_cnt, "%04d",cnt);                                                   
         }
         else if (auth_tx->TLF01_details.tx_key == AUTH_VOID_REFUND_RESPONSE)
         {
            total = atol(db_recs.bch01.total_void_credit_refund_amt) - atol(auth_tx->TLF01_details.total_amount);
            sprintf(db_recs.bch01.total_void_credit_refund_amt, "%012d",total); 
            cnt = atoi(db_recs.bch01.total_void_credit_refund_cnt) - 1;
            sprintf(db_recs.bch01.total_void_credit_refund_cnt, "%04d",cnt);                                                   
         }
      }
      if (strcmp(auth_tx->TLF01_details.organization_id, "GES") == 0)
         strcpy(db_recs.bch01.visa_merchant_id,"GES");
      else
         strcpy(db_recs.bch01.visa_merchant_id,auth_tx->TLF01_details.visa_merchant_id);

      strcpy(db_recs.bch01.merchant_id,auth_tx->TLF01_details.merchant_id);

      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      if (result_code = db_update_bch01(&db_recs.bch01,err_msg) != PTEMSG_OK)
      {
         return(PTEMSG_UPDATE_FAILED);
      }
      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_UPDATE, 2, BCH01_DATA,
                              (float)duration, &TimingStats );
      }
      updates_to_db_made = true;
   }
   return PTEMSG_OK;
}

BYTE process_reversal(pAUTH_TX auth_tx)
{
   BYTE orig_tx_key ;
   BCH10 bch10 ;
   BCH20 bch20 ;
   BYTE   auth_number[7]  = "";
   BYTE   rrn[13]         = "";
   TLF01  tlf01;
   double         start_time;
   double         end_time;
   double         duration;

   /* See if this is a duplicate. */
   memcpy( &tlf01, &auth_tx->TLF01_details, sizeof(TLF01) );

   if ( DB_Timing_Flag == true )
      start_time = ptetime_get_time();

   result_code = db_look_for_duplicate( &tlf01, auth_number, rrn );
   if ( DB_Timing_Flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      update_timing_stats( ST1_DB_SELECT, 2, TLF01_DATA,
                           (float)duration, &TimingStats );
   }

   if ( result_code == PTEMSG_OK)
   {
      /* A duplicate has been found.
       * Rollback any previous DB updates (i.e. ACF01)
       * Return success!
       */
      rollback_the_update();
      return PTEMSG_OK;
   }
   else
      result_code = PTEMSG_OK;

   if ( 0 == strcmp(auth_tx->TLF01_details.handler_queue,"VOICE") )
   {
      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      if (db_delete_bch20_by_auth_nbr(&auth_tx->TLF01_details,err_msg) != PTEMSG_OK)
      {
         return(PTEMSG_DELETE_FAILED);
      }

      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_DELETE, 2, BCH20_DATA,
                              (float)duration, &TimingStats );
      }
   }
   else
   {
      orig_tx_key = get_orig_response_tx_key_for_reversal(auth_tx->TLF01_details.orig_message,
                                                          auth_tx->TLF01_details.processing_code,
                                                          auth_tx->TLF01_details.voice_auth);
      OrigTxKey = orig_tx_key;
      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      switch (orig_tx_key)
      {
         case AUTH_AUTHORIZATION_RESPONSE:
         case AUTH_PRE_AUTHORIZATION_RESPONSE:

            memset(&bch20,0,sizeof(BCH20));
            strcpy(bch20.primary_key.device_id,auth_tx->TLF01_details.terminal_id);
            strcpy(bch20.primary_key.batch_nbr, "ACTIVE");
            strcpy(bch20.sys_trace_audit_num,auth_tx->TLF01_details.sys_trace_audit_num);
            strcpy(bch20.merchant_id,auth_tx->TLF01_details.merchant_id);

            if (db_delete_bch20_by_stan (&bch20,err_msg) != PTEMSG_OK)
               result_code = PTEMSG_DELETE_FAILED;

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_DELETE, 2, BCH20_DATA,
                                    (float)duration, &TimingStats );
            }
            break;


         case AUTH_SALE_RESPONSE:
         case AUTH_REFUND_RESPONSE:
         case AUTH_CASH_ADVANCE_RESPONSE:
         case AUTH_OFFLINE_SALE_RESPONSE:
         case AUTH_QUASI_CASH_RESPONSE:

            result_code = process_reversal_non_void_trans(auth_tx,orig_tx_key);
            memset(&bch10,0,sizeof(BCH10));
            strcpy(bch10.primary_key.device_id,auth_tx->TLF01_details.terminal_id);
            strcpy(bch10.primary_key.batch_nbr, "ACTIVE");
            strcpy(bch10.sys_trace_audit_num,auth_tx->TLF01_details.sys_trace_audit_num);
            strcpy(bch10.merchant_id,auth_tx->TLF01_details.merchant_id);

            if (db_delete_bch10_by_stan (&bch10,err_msg) != PTEMSG_OK)
               result_code = PTEMSG_DELETE_FAILED;

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_DELETE, 2, BCH10_DATA,
                                    (float)duration, &TimingStats );
            }
            break;

         case AUTH_VOID_SALE_RESPONSE:
         case AUTH_VOID_REFUND_RESPONSE:
         case AUTH_VOID_CASH_ADVANCE_RESPONSE:
         /* SCR 12502 - ThoughtFocus
		  * Adding the case statement, to enable REVERSAL of AUTH_VOID_REFUND
		  * AUTH_OFFLINE_VOID_SALE, AUTH_OFFLINE_VOID_REFUND,
		  * AUTH_SALE_ADJUSTMENT, AUTH_REFUND_ADJUSTMENT 
		  */
		 case AUTH_VOID_RELOAD_RESPONSE:
		 case AUTH_OFFLINE_VOID_SALE_RESPONSE:
		 case AUTH_OFFLINE_VOID_REFUND_RESPONSE:
         /* SCR 12502 - ThoughtFocus
		  * Since AUTH_SALE_ADJUSTMENT, AUTH_REFUND_ADJUSTMENT function similar to
		  * VOIDs, process_reversal_void_trans is called for these transactions also.
		  */
		 case AUTH_SALE_ADJUSTMENT_RESPONSE:
         case AUTH_REFUND_ADJUSTMENT_RESPONSE:
            result_code = process_reversal_void_trans(auth_tx);
            break;

         default: 
            sprintf( err_msg,
                    "Unknown Message Type: %s, Processing Code: %s (%s)",
                     auth_tx->TLF01_details.message_type,
                     auth_tx->TLF01_details.processing_code,
                     ServiceName );
            result_code = PTEMSG_INVALID_DATATYPE;
            break;
       }
   }
   return result_code;
}

pPTE_MSG process_insert_msg(pPTE_MSG p_msg_in)
{
   pBYTE          p_data;
   pPTE_MSG_DATA  p_msg_data;
   pPTE_MSG       p_msg_out;
   pBYTE          p_current;
   BYTE           subtype2;
   BYTE           table_name[20]="";
   BYTE           rc;
   INT            len;
   CHAR           buffer[256];
   AUTH_TX        auth_tx;
   EMV_RAW        emvraw;
   double         start_time;
   double         end_time;
   double         duration;int itemp=0;
   BYTE           stip_result_code;
   CHAR			  amountbuff[13] = "";//praneeth added for converted amount swapping

   p_msg_out     = NULL_PTR;
   p_msg_data    = ptemsg_get_pte_msg_data(p_msg_in);
   p_data        = ptemsg_get_pte_msg_data_data(p_msg_data);
   memcpy( atp_buffer, p_data, sizeof(AUTH_TX) );
   memcpy( &auth_tx,   p_data, sizeof(AUTH_TX) );
   p_current     = atp_buffer + sizeof(AUTH_TX);
   app_data_type = ptemsg_get_pte_msg_data_app_data_type(p_msg_data);
   p_data = p_data + sizeof(AUTH_TX);
   subtype2 = ptemsg_get_msg_subtype2( p_msg_in );

   if (app_data_type  == TLF01_DATA)
   {
      /* Populate system_date field = date txn is inserted into database. */
      create_system_date( ((pTLF01)p_data)->system_date );

      memset(&db_recs.tlf01, 0, sizeof(db_recs.tlf01));
      memcpy(&db_recs.tlf01, (pTLF01)p_data, sizeof(TLF01));
/*	  memset(&db_recs.tlf01_stip,0, sizeof(db_recs.tlf01_stip));
	  memcpy(&db_recs.tlf01_stip, (pTLF01_STIP)p_data, sizeof(TLF01_STIP));*/

      /* Convert message type to a request type, for standardization. */
      convert_msgtype_to_request( db_recs.tlf01.message_type );

      if ( subtype2 == ST2_DB_UPDATE_TC_TABLES_ONLY )
      {
         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         /* Update EMV01 and insert into TLF01. */
         result_code = db_process_tc_crypto( &db_recs.tlf01,
                                             &auth_tx.EMV_details,
                                              table_name,
                                              err_msg );
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_UPDATE, subtype2, EMV01_DATA,
                                 (float)duration, &TimingStats );
         }

         if ( result_code != PTEMSG_OK )
         {
            memset( buffer, 0x00, sizeof(buffer) );
            sprintf( buffer,
                    "Failed database update of TC Upload, Table=%s, RRN=%s",
                     table_name,
                     auth_tx.TLF01_details.retrieval_ref_num );
            TxUtils_Send_Msg_To_Operator( 1, buffer, 1, WARN_MSG,
                                         "db_process_tc_crypto",2,WARNING_ERROR,
                                          auth_tx.TLF01_details.terminal_id,
                                          auth_tx.TLF01_details.card_num, 
                                          auth_tx.TLF01_details.merchant_id);

            TxUtils_Send_Msg_To_Operator( 1, err_msg, 1, WARN_MSG,
                                         "db_process_tc_crypto",2,WARNING_ERROR,
                                          auth_tx.TLF01_details.terminal_id,
                                          auth_tx.TLF01_details.card_num, 
                                          auth_tx.TLF01_details.merchant_id);
         }
         else
         {
            /* RAW EMV DATA */
            memset( &emvraw, 0x00, sizeof(EMV_RAW) );

            /* Determine the block size */
            len = genutil_bcd_to_int( auth_tx.EMV_details.emv_block, 2 ) + 2;

            /* Don't copy the length */
            memcpy( emvraw.RAW_DATA, auth_tx.EMV_details.emv_block, len );
            sprintf( emvraw.DATA_LENGTH, "%d", len );

            strcpy(emvraw.transaction_id, auth_tx.TLF01_details.primary_key.transaction_id);
            strcpy(emvraw.system_date,    ((pTLF01)p_data)->system_date );

            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            rc = db_insert_emvraw( &emvraw, err_msg );

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_INSERT, subtype2, EMV01_DATA,
                                    (float)duration, &TimingStats );
            }

            if ( rc != PTEMSG_OK )
            {
               memset( buffer, 0x00, sizeof(buffer) );
               strcpy( buffer, "TC Upload: Insert raw EMV data failed" );
               TxUtils_Send_Msg_To_Operator( 1, buffer, 1, WARN_MSG,
                                            "db_process_tc_crypto",
                                             2, WARNING_ERROR,
                                             auth_tx.TLF01_details.terminal_id,
                                             auth_tx.TLF01_details.card_num,
                                             auth_tx.TLF01_details.merchant_id);

               TxUtils_Send_Msg_To_Operator( 1, err_msg, 1, WARN_MSG,
                                            "db_process_tc_crypto",
                                             2, WARNING_ERROR,
                                             auth_tx.TLF01_details.terminal_id,
                                             auth_tx.TLF01_details.card_num,
                                             auth_tx.TLF01_details.merchant_id);
            }
         }
      }
      else
      {
         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_insert_tlf01(&db_recs.tlf01, err_msg);

		 if(( strcmp(db_recs.tlf01.response_code,"00") == 0 ) &&
			(strcmp(db_recs.tlf01.product_codes[1].code,STANDIN) == 0))
		 { 
			 strcpy(db_recs.tlf01.product_codes[7].code,auth_tx.ch_billing_amt);
			 strcpy(db_recs.tlf01.product_codes[7].amount,auth_tx.ch_billing_curr_code);
			 /* Store DE10 Billing Conversion rate in .TF Phani*/
			 strcpy(db_recs.tlf01.product_codes[8].amount, auth_tx.ch_billing_conv_rate);
			  	/* Store industry_code .TF Phani*/
			 strcpy(db_recs.tlf01.product_codes[8].code, auth_tx.industry_code);
			 /* TF phani - Updates for 0120 MCARD fields*/
			 /* DE 61 value - which need to be populated during 0120 from sbtach*/
			 strcpy(db_recs.tlf01.source_key,auth_tx.acceptor_term_name);
			  /* Store DE43 here so it gets logged to TLF01:
				*   Merchant Name         --> TLF01.card_holder_name
				*   City and Country Code --> TLF01.ncf01_retired_cwk
				*  TF Phani
				*/
			   if ( auth_tx.TLF01_details.card_holder_name[0] == 0x00 )
			   {
				  memcpy( auth_tx.TLF01_details.card_holder_name,
						  auth_tx.MCF01_details.name02,
						  22 );
			   }

			   if ( auth_tx.TLF01_details.ncf01_retired_cwk[0] == 0x00 )
			   {
				  memcpy( auth_tx.TLF01_details.ncf01_retired_cwk,
						  auth_tx.MCF01_details.city,
						  13 );
				  itemp = strlen(auth_tx.MCF01_details.city);
				 // memset(&auth_tx.TLF01_details.ncf01_retired_cwk[itemp],0x20,13-itemp);
				  memcpy( auth_tx.TLF01_details.ncf01_retired_cwk+13, "PHL", 3 );
			   }

			   //Storing converted currency and amount while dual currency //praneeth
			   if ( 0 == strcmp(db_recs.tlf01.host_start_time, "7.000") )
			   {
					strcpy( db_recs.tlf01.currency_code, "840" );
					if (strcmp(db_recs.tlf01.product_codes[9].amount, "")) 
					{
						strcpy(amountbuff,db_recs.tlf01.total_amount);
						strcpy(db_recs.tlf01.total_amount,db_recs.tlf01.product_codes[9].amount);
						strcpy(db_recs.tlf01.product_codes[9].amount,amountbuff);
					}
			   }
			   else if ( 0 == strcmp(db_recs.tlf01.host_start_time, "5.000") )
			   {
   					strcpy( db_recs.tlf01.currency_code, "608" );
					if (strcmp(db_recs.tlf01.product_codes[9].amount, "") )
					{
						strcpy(amountbuff,db_recs.tlf01.total_amount);
						strcpy(db_recs.tlf01.total_amount,db_recs.tlf01.product_codes[9].amount);
						strcpy(db_recs.tlf01.product_codes[9].amount,amountbuff);
					}
			   }
			 /* Need to update STAND in flag in case of VOID / Reverse.. TF PHANI */
			 if( db_recs.tlf01.tx_key == AUTH_VOID_SALE_RESPONSE || db_recs.tlf01.tx_key == AUTH_VOID_SALE )
			 {
				 strcpy(db_recs.tlf01.product_codes[1].code,VOIDED);
				 stip_result_code = db_update_tlf01_stip_void(&db_recs.tlf01, err_msg);

			 }
			 else if(db_recs.tlf01.tx_key == AUTH_REVERSAL_RESPONSE  || db_recs.tlf01.tx_key == AUTH_REVERSAL)
			 {
				 strcpy(db_recs.tlf01.product_codes[1].code,REVERSED);
				  stip_result_code = db_update_tlf01_stip_reversal(&db_recs.tlf01, err_msg);

			 }
			 else if(db_recs.tlf01.tx_key == AUTH_SALE_ADJUSTMENT_RESPONSE || db_recs.tlf01.tx_key == AUTH_SALE_ADJUSTMENT)
			 {
				 stip_result_code = db_update_tlf01_stip_adjust(&db_recs.tlf01, err_msg);
			 }
			 else
			 {		 
				stip_result_code = db_insert_tlf01_stip(&db_recs.tlf01, err_msg);
			 }
		 }
			
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_INSERT, subtype2, TLF01_DATA,
                                 (float)duration, &TimingStats );
         }


         /* If EMV txn, insert into EMV01 table. */
         memcpy( &auth_tx, atp_buffer, sizeof(AUTH_TX) );
         if ( auth_tx.EMV_details.currency_code[0] != 0x00 )
         {
            /* There is EMV data.  Insert it.
             * But do not change result code from TLF01 insert.
             */
            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            rc = store_emv_records( &auth_tx );

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_INSERT, subtype2, EMV01_DATA,
                                    (float)duration, &TimingStats );
            }

            /* Update Chip Condition Code in DCF01. */
            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            rc = update_chip_condition( &auth_tx );

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_UPDATE, subtype2, DCF01_DATA,
                                    (float)duration, &TimingStats );
            }
         }
      }
   }
   else if (app_data_type  == FGUARD_DATA)
   {
      result_code = db_insert_fguard( p_data, err_msg );
   }
   else
   {
      result_code = PTEMSG_INVALID_DATATYPE;
      sprintf(err_msg, "Unknown app_data_type for Insert request from %s", reply_que);
   }


   if (result_code == PTEMSG_OK)
   {
      updates_to_db_made = true;
      p_msg_out = ptemsg_build_msg(MT_DB_REPLY,
                                   msg_sub_type1,
                                   msg_sub_type2,
                                   reply_que,
                                   application_que_name,
                                   (pBYTE)atp_buffer,
                                   sizeof(AUTH_TX),
                                   app_data_type);

      if (p_msg_out == NULL_PTR)
      {
         result_code = PTEMSG_INSUFFICIENT_MEMORY;
         sprintf(err_msg, "Insufficient Memory to build Insert response to %s", reply_que);
      }
   }
   return(p_msg_out);
}

/******************************************************************************
 *
 *  NAME:         genutil_format_date
 *
 *  DESCRIPTION:  This function formats a date into YYYYMMDD format.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      temp - Formatted date
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 ******************************************************************************/
void genutil_format_date(pCHAR temp)
{
   struct timeb   time_structure;// Time for ftime
   time_t long_time_since_1970;  // Num of secs since 01/01/1970 A.D. 12:00 A.M.
   struct tm *current_time;      // Current time structure
   CHAR   temp1[3] = "";

   ftime(&time_structure);
   long_time_since_1970 = time_structure.time;
   current_time = localtime(&long_time_since_1970);
   current_time->tm_mon++;
   if (current_time->tm_year >= 70)
      current_time->tm_year += 1900;
   else
      current_time->tm_year += 2000;
   sprintf( temp, "%d", current_time->tm_year );
   sprintf( temp1,"%02d", current_time->tm_mon  );
   strcat( temp, temp1 );

   memset(temp1, 0, sizeof(temp1));
   sprintf( temp1, "%02d", current_time->tm_mday );
   strcat( temp, temp1 );

   memset(temp1, 0, sizeof(temp1));
   sprintf( temp1, "%02d", current_time->tm_hour );
   strcat( temp, temp1 );

   memset(temp1, 0, sizeof(temp1));
   sprintf( temp1, "%02d", current_time->tm_min );
   strcat( temp, temp1 );

   memset(temp1, 0, sizeof(temp1));
   sprintf( temp1, "%02d", current_time->tm_sec );
   strcat( temp, temp1 );

   return;
} /* genutil_format_date */

/*****************************************************************************

  Function:   genutil_bcd_to_int

  Description:
      Convert a bcd string into an integer value.
  Author: 
      unknown
  Inputs:
      p_bcd_data  -  pointer to the incoming bcd string
      bcd_len     -  length of the bcd string
  Outputs:
  Return values:
      INT         -  integer value of the bcd string
  Modified by:
      BGable      6/26/98
******************************************************************************/
INT genutil_bcd_to_int (pBYTE  p_bcd_data, INT bcd_len)
{
   INT   temp_int;
   INT   multiplier;
   INT   i;


   multiplier = 1;
   temp_int   = 0;
   
   for (i = (bcd_len-1); i >= 0; i--)
      {
      temp_int+= (p_bcd_data [i] & 0x0f) * multiplier;
      multiplier = multiplier * 10;
      temp_int+= (p_bcd_data [i] / 16) * multiplier;
      multiplier = multiplier * 10;
      }

   return (temp_int);
} /*genutil_bcd_to_int */
void rollback_the_update()
{
   dbcommon_rollback();
   dstimer_rollback();
   updates_to_db_made = false;

   return;
}  

BYTE process_network_request ( pAUTH_TX auth_tx , BYTE msg_sub_type2 )
{
   NCF30          ncf30;
   CHAR           date_time[16] = "";
   LONG           total;
   LONG           grand_total;
   CHAR           ncf21_open_date[9]="";
   CHAR           ncf21_open_time[7]="";
   CHAR           proc_code[7];
   CHAR           ncf21_keys[50] = "";
   CHAR           network_id[11] = "";
   CHAR           type[2] = "";
   INT            cnt;
   INT            len;
   BOOLEAN        cirrus   = false;
   BOOLEAN        debit    = false;
   BOOLEAN        credit   = false;
   BOOLEAN        both     = false;
   BOOLEAN        reversal = false;
   BOOLEAN        new      = false;
   double         start_time;
   double         end_time;
   double         duration;

   /* Set up keys for NCF21 record. */
   if ( msg_sub_type2 == ST2_ACQUIRER )
   {
      len = strlen (auth_tx->TLF01_details.handler_queue);
      strncpy( network_id, auth_tx->TLF01_details.handler_queue,
            len - 1 );

      strcat( type, "A"  );
   }
   else    if ( msg_sub_type2 == ST2_ISSUER )
   {
      strncpy( network_id, auth_tx->TLF01_details.authorizing_host_queue,
            sizeof(auth_tx->TLF01_details.authorizing_host_queue) - 2 );
      strcat( type, "I" );

   }

   if ( 0 == strcmp("VOICE",auth_tx->TLF01_details.handler_queue) )
   {
      strcpy( network_id, auth_tx->TLF01_details.issuer_id );
      type[0] = auth_tx->TLF01_details.entry_type;
      msg_sub_type2 = ST2_ACQUIRER;
   }

   /* Determine if Reversal */
   if ( (0 == strncmp( "04", auth_tx->TLF01_details.message_type, 2)) ||
        ( auth_tx->TLF01_details.tx_key == AUTH_ATM_CONFIRM_RESPONSE)  )
      reversal = true;

   if ( 0 == strcmp("nccirs", network_id) )
   {
      /* Only do NCF21 for Cirrus network.  Don't need totals for others. */
      memcpy(ncf21_keys,network_id,sizeof(auth_tx->TLF01_details.handler_queue)-1);

      strcat( ncf21_keys + sizeof(ncf30.primary_key.network_id), type );

      strcat( ncf21_keys + sizeof ( ncf30.primary_key.network_id )
                         + sizeof ( ncf30.primary_key.network_type ), "ACTIVE");

      /* Select totals record from NCF21 */
      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      result_code = db_select_ncf21( ncf21_keys, &db_recs.ncf21, err_msg );

      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_SELECT, 3, NCF21_DATA,
                              (float)duration, &TimingStats );
      }

      if ( PTEMSG_NOT_FOUND == result_code )
      {
         new = true;
         memset( &db_recs.ncf21, 0x00, sizeof(db_recs.ncf21) );
         strcpy( db_recs.ncf21.primary_key.network_id,    network_id   );
         strcpy( db_recs.ncf21.primary_key.network_type,  type );
         strcpy( db_recs.ncf21.primary_key.batch_number, "ACTIVE" );
         strcpy( db_recs.ncf21.credit_cnt,     "0" );
         strcpy( db_recs.ncf21.credit_rev_cnt, "0" );
         strcpy( db_recs.ncf21.credit_amt,     "0" );
         strcpy( db_recs.ncf21.credit_rev_amt, "0" );
         strcpy( db_recs.ncf21.debit_cnt,      "0" );
         strcpy( db_recs.ncf21.debit_rev_cnt,  "0" );
         strcpy( db_recs.ncf21.debit_amt,      "0" );
         strcpy( db_recs.ncf21.debit_rev_amt,  "0" );

         /* Get system date and time. */
         genutil_format_date( date_time );
         strncpy(db_recs.ncf21.open_date ,date_time, 8);
         strncpy(db_recs.ncf21.open_time ,date_time + 8, 6);

         result_code = PTEMSG_OK;
      }
      else
      {
         /* Values might get so big, they become negative. Set these to 0. */
         if ( db_recs.ncf21.credit_cnt[0] == '-' )
            strcpy( db_recs.ncf21.credit_cnt, "0" );

         if ( db_recs.ncf21.credit_rev_cnt[0] == '-' )
            strcpy( db_recs.ncf21.credit_rev_cnt, "0" );

         if ( db_recs.ncf21.credit_amt[0] == '-' )
            strcpy( db_recs.ncf21.credit_amt, "0" );

         if ( db_recs.ncf21.credit_rev_amt[0] == '-' )
            strcpy( db_recs.ncf21.credit_rev_amt, "0" );

         if ( db_recs.ncf21.debit_cnt[0] == '-' )
            strcpy( db_recs.ncf21.debit_cnt, "0" );

         if ( db_recs.ncf21.debit_rev_cnt[0] == '-' )
            strcpy( db_recs.ncf21.debit_rev_cnt, "0" );

         if ( db_recs.ncf21.debit_amt[0] == '-' )
            strcpy( db_recs.ncf21.debit_amt, "0" );

         if ( db_recs.ncf21.debit_rev_amt[0] == '-' )
            strcpy( db_recs.ncf21.debit_rev_amt, "0" );
      }

      if ( PTEMSG_OK == result_code )
      {
         /* Determine if Credit, Debit, or Both (Transfers) */
         strcpy( proc_code, auth_tx->TLF01_details.processing_code );
         if ( (proc_code[2] == '1')  ||  (proc_code[2] == '2') )
            debit = true;
         else
            credit = true;

         /* Get grand total. */
         grand_total = atol( db_recs.ncf21.total_amt );
         if ( strncmp(db_recs.ncf21.total_amt_type,"C",1) != 0)
         {
            grand_total=-grand_total;
         }

         /* Update totals according to credit or debit. */
         if ( credit || both )
         {
            if ( reversal )
            {
               cnt   = atoi( db_recs.ncf21.credit_rev_cnt );
               total = atol( db_recs.ncf21.credit_rev_amt );
               cnt++;
               total       = total+ atol( auth_tx->TLF01_details.reversal_amount );
               grand_total = grand_total - atol( auth_tx->TLF01_details.reversal_amount );
               sprintf( db_recs.ncf21.credit_rev_cnt, "%04d",  cnt         );
               sprintf( db_recs.ncf21.credit_rev_amt, "%015d", total       );
            }
            else
            {
               cnt   = atoi( db_recs.ncf21.credit_cnt );
               total = atol( db_recs.ncf21.credit_amt );
               cnt++;
               total  = total+ atol( auth_tx->TLF01_details.total_amount );
               grand_total= grand_total+ atol( auth_tx->TLF01_details.total_amount );
               sprintf( db_recs.ncf21.credit_cnt, "%04d",  cnt   );
               sprintf( db_recs.ncf21.credit_amt, "%015d", total );
            }
         }

         if ( debit || both )
         {
            if ( reversal )
            {
               cnt   = atoi( db_recs.ncf21.debit_rev_cnt );
               total = atol( db_recs.ncf21.debit_rev_amt );
               cnt++;
               total = total + atol( auth_tx->TLF01_details.reversal_amount );
               grand_total=grand_total + atol( auth_tx->TLF01_details.reversal_amount );
               sprintf( db_recs.ncf21.debit_rev_cnt, "%04d",  cnt   );
               sprintf( db_recs.ncf21.debit_rev_amt, "%015d", total );
            }
            else
            {
               cnt   = atoi( db_recs.ncf21.debit_cnt );
               total = atol( db_recs.ncf21.debit_amt );
               cnt++;
               total = total + atol( auth_tx->TLF01_details.total_amount );
               grand_total = grand_total - atol( auth_tx->TLF01_details.total_amount );
               sprintf( db_recs.ncf21.debit_cnt, "%04d",  cnt   );
               sprintf( db_recs.ncf21.debit_amt, "%015d", total );
            }
         }

         sprintf( db_recs.ncf21.total_amt, "%016d", grand_total );
         if ( 0 <= grand_total )
            strcpy( db_recs.ncf21.total_amt_type, "C" ); /* Credit */
         else
            strcpy( db_recs.ncf21.total_amt_type, "D" ); /* Debit  */

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         if ( new )
         {
            /* Insert new record into NCF21. */
            result_code = db_insert_ncf21( &db_recs.ncf21, err_msg );

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_INSERT, 3, NCF21_DATA,
                                    (float)duration, &TimingStats );
            }
         }
         else
         {
            /* Update record in NCF21. */
            result_code = db_update_ncf21( &db_recs.ncf21, err_msg );

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_UPDATE, 3, NCF21_DATA,
                                    (float)duration, &TimingStats );
            }
         }
      }
   }
   else
   {
      /* Get system date and time for NCF30 record. */
      memset( &db_recs.ncf21, 0x00, sizeof(NCF21) );
      genutil_format_date( date_time );
      memcpy(db_recs.ncf21.open_date ,date_time, 8);
      memcpy(db_recs.ncf21.open_time ,date_time + 8, 6);
      result_code = PTEMSG_OK;
   }

   /* Insert record into NCF30 */
   if ( PTEMSG_OK == result_code )
   {
      memset ( &ncf30, 0, sizeof ( NCF30 ) );
      strcpy ( ncf30.primary_key.network_id, network_id );
      strcpy ( ncf30.primary_key.network_type, type );
      strcpy ( ncf30.primary_key.retrieval_ref_num, auth_tx->TLF01_details.retrieval_ref_num );
      strcpy ( ncf30.card_nbr, auth_tx->TLF01_details.card_num );
      strcpy ( ncf30.primary_key.batch_number, "ACTIVE" );

      if ( reversal && (msg_sub_type2 == ST2_ACQUIRER))
      {
         strcpy ( ncf30.primary_key.retrieval_ref_num, auth_tx->TLF01_details.orig_retrieval_ref_num );

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_delete_ncf30( &ncf30, err_msg );

         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_DELETE, 3, NCF30_DATA,
                                 (float)duration, &TimingStats );
         }
      }
      else
      {
         strcpy ( ncf30.open_date, db_recs.ncf21.open_date );
         strcpy ( ncf30.open_time, db_recs.ncf21.open_time );
         strcpy ( ncf30.merchant_id, auth_tx->TLF01_details.merchant_id );
         strcpy ( ncf30.transaction_id, auth_tx->TLF01_details.primary_key.transaction_id );
         strcpy ( ncf30.device_id , auth_tx->TLF01_details.terminal_id );
         strcpy ( ncf30.card_nbr, auth_tx->TLF01_details.card_num );
         strcpy ( ncf30.message_type, auth_tx->TLF01_details.message_type );
         strcpy ( ncf30.processing_code, auth_tx->TLF01_details.processing_code );

         if( strcmp("",auth_tx->TLF01_details.reversal_amount) == 0)
            strcpy( ncf30.tran_amount, auth_tx->TLF01_details.total_amount );
         else
            strcpy( ncf30.tran_amount, auth_tx->TLF01_details.reversal_amount ); 

         strcpy ( ncf30.auth_number, auth_tx->TLF01_details.auth_number );
         strcpy ( ncf30.response_code, auth_tx->TLF01_details.response_code );
         strcpy ( ncf30.tran_date,auth_tx->TLF01_details.date_yyyymmdd);
         
         
         strcpy ( ncf30.tran_time, auth_tx->TLF01_details.time_hhmmss );
         strcpy ( ncf30.sys_trace_audit_nbr, auth_tx->TLF01_details.sys_trace_audit_num );
			if(auth_tx->TLF01_details.tx_key >= AUTH_QUASI_CASH_RESPONSE)
			ncf30.tx_key = (auth_tx->TLF01_details.tx_key - 100);
			else
			ncf30.tx_key = auth_tx->TLF01_details.tx_key;

         strcpy ( ncf30.invoice_nbr, auth_tx->TLF01_details.invoice_number );
		 /* store STIP approved txn as stndin in invoice no. 
		 Its usefull when aTP get Vodi/Reversal/Adjust txn for that. TF-Ajay 08-Jul-09 */
		 strcpy ( ncf30.invoice_nbr,auth_tx->TLF01_details.product_codes[1].code);
         strncpy ( ncf30.network_data, auth_tx->TLF01_details.mcard_banknet,12 );
         strcpy ( ncf30.currency_code, auth_tx->TLF01_details.currency_code );
         strcpy ( ncf30.acquiring_inst_id_code, auth_tx->TLF01_details.acquiring_id );
         strcpy ( ncf30.settlement_date, auth_tx->TLF01_details.settlement_date );
         strcpy ( ncf30.transmission_timestamp, auth_tx->TLF01_details.transmission_timestamp );
         strcpy ( ncf30.tran_fee_amount, auth_tx->TLF01_details.tran_fee_amount );

         if( ncf30.primary_key.retrieval_ref_num[0] == 0x00)
         {
            create_rrn( ncf30.primary_key.retrieval_ref_num );
         }

         /* Convert message type to a request type, for standardization. */
         convert_msgtype_to_request( ncf30.message_type );

         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_insert_ncf30( &ncf30, err_msg );

         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_INSERT, 3, NCF30_DATA,
                                 (float)duration, &TimingStats );
         }
      }
   }

   /* Rollback when any query fails ( either NCF21 / NCF30 ) */
   if ( result_code != PTEMSG_OK )
   {
      updates_to_db_made = true;
      rollback_the_update();
   }
   return ( result_code );
}

BYTE process_alldata_msg( pAUTH_TX p_auth_tx )
{
   TLF01          tlf01;
   CHAR           primary_key[16] = "";
   CHAR           transaction_id [21] = "";
   CHAR           date_time[16] = "";
   CHAR           bch01_open_date[9] = "";
   CHAR           bch01_open_time[7] = "";
   BYTE           deferred_txn;
   BYTE           rc;
   double         start_time;
   double         end_time;
   double         duration;
   int			  itemp;		
   double nConvertedTxAmount = 0.0 ;
   CHAR   strProcessingCode[20] = {0} ;
   BYTE           stip_result_code;
   CHAR			  amountbuff[13] = "";//praneeth added for converted amount swapping

   strncpy(strProcessingCode, p_auth_tx->TLF01_details.processing_code, 2) ;
   result_code = PTEMSG_OK;

   /* First check for a cash bonus program winner. If not a winner,
    * this portion of the update-all will be committed by itself. Only
    * the txn ctr in the cash bonus program will be updated. If there
    * is a problem with the rest of the update-all and a rollback is
    * performed, txn ctr does not get rolled back. But this is okay.
    *
    * If this is a cash bonus program winner, it does not get committed
    * until the update-all completes. This way, it can be rolled back
    * if needed.
    */
   if ( 0 == strcmp(p_auth_tx->TLF01_details.response_code,"00") )
   {
      /* Transaction is approved. */
      if (( 0 == strcmp(p_auth_tx->TLF01_details.dispensation.origin, "LO" )) &&
          ( msg_sub_type2 == 0 ))
      {
         /* Local origin. See if txn is cash bonus eligible.
          * If yes, check for a winner.
          */
         if ( !get_cash_bonus_result( p_auth_tx ) )
         {
            /* False = not a winner. Commit the change to the txn ctr. */
            updates_to_db_made = true;
            commit_the_update(); 
            updates_to_db_made = false;
         }
      }
   }
/*praneeth code*/

   /* See if OMC01 record needs to be updated. */
   if (p_auth_tx->TLF01_details.update_mask[0] & OMC01_MASK)
   {
	   if( atoi(p_auth_tx->TLF01_details.nbr_of_prod_codes) > 0)
	   {
		   result_code = db_update_OMC01_Repeats(p_auth_tx->TLF01_details.merchant_id,p_auth_tx->TLF01_details.card_num,p_auth_tx->TLF01_details.nbr_of_prod_codes, err_msg);
		   memset(p_auth_tx->TLF01_details.nbr_of_prod_codes,0x00,sizeof(p_auth_tx->TLF01_details.nbr_of_prod_codes));
	   }	   
	   if ( result_code == PTEMSG_OK )
		   strcat( update_all_status, "T1" );
	   else
         strcat( update_all_status, "T0" );
   }
/*end of praneeth code */
   /* See if card record needs to be updated. */
   if (p_auth_tx->TLF01_details.update_mask[0] & CCF02P_MASK)
   {
      /* Yes */
      if ( DB_Timing_Flag == true )
         start_time = ptetime_get_time();

      result_code = db_update_ccf02p(&p_auth_tx->CCF02P_details, err_msg);

      if ( DB_Timing_Flag == true )
      {
         end_time = ptetime_get_time();
         duration = end_time - start_time;
         update_timing_stats( ST1_DB_UPDATE, 1, CCF02P_DATA,
                              (float)duration, &TimingStats );
      }

      if ( result_code == PTEMSG_OK )
         strcat( update_all_status, "A1" );
      else
         strcat( update_all_status, "A0" );
   }

   if ((p_auth_tx->TLF01_details.update_mask[0]) & CCF03P_MASK)
   {
      if ( result_code == PTEMSG_OK )
      {
         /* Depending on ccf03_insert flag, either do a insert or an update */
         if (p_auth_tx->ccf03_insert)
         {
            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            result_code = db_insert_ccf03p(&p_auth_tx->CCF03P_details, err_msg) ;

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_INSERT, 1, CCF03P_DATA,
                                    (float)duration, &TimingStats );
            }

            if ( result_code == PTEMSG_OK )
               strcat( update_all_status, "B1" );
            else
               strcat( update_all_status, "B0" );
         }
         else
         {
            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            result_code = db_update_ccf03p(&p_auth_tx->CCF03P_details, err_msg) ;

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_UPDATE, 1, CCF03P_DATA,
                                    (float)duration, &TimingStats );
            }

            if ( result_code == PTEMSG_OK )
               strcat( update_all_status, "C1" );
            else
               strcat( update_all_status, "C0" );
         }
      }
   }

   if ((p_auth_tx->TLF01_details.update_mask[0]) & OFFUS_VELOCITY_MASK)
   {
      if ( result_code == PTEMSG_OK )
      {
         /* Depending on ccf03_insert flag, either do a insert or an update */
         if (p_auth_tx->offus_velocity_insert)
         {
            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            result_code = db_insert_offus_velocity(&p_auth_tx->offus_velocity_details, err_msg) ;

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_INSERT, 1, OFFUS_VELOCITY_DATA,
                                    (float)duration, &TimingStats );
            }

            if ( result_code == PTEMSG_OK )
               strcat( update_all_status, "D1" );
            else
               strcat( update_all_status, "D0" );
         }
         else
         {
            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            result_code = db_update_offus_velocity(&p_auth_tx->offus_velocity_details, err_msg) ;

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_UPDATE, 1, OFFUS_VELOCITY_DATA,
                                    (float)duration, &TimingStats );
            }

            if ( result_code == PTEMSG_OK )
               strcat( update_all_status, "E1" );
            else
               strcat( update_all_status, "E0" );
         }
      }
   }

   if (p_auth_tx->TLF01_details.update_mask[0] & ACF01_MASK)
   {
      if ( result_code == PTEMSG_OK )
      {
         /* Update BALANCE ACCOUNT(S) */
         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_update_acf01(&p_auth_tx->ACF01_details, err_msg) ;

         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_UPDATE, 1, ACF01_DATA,
                                 (float)duration, &TimingStats );
         }

         if (result_code == PTEMSG_OK)
         {
            /* Update Deferred Balance Account for any of the following txn types. */
            strcat( update_all_status, "F1" );
            if ((p_auth_tx->TLF01_details.tx_key == AUTH_DEFERRED_PURCHASE_AUTHORIZATION_RESPONSE) ||
                (p_auth_tx->TLF01_details.tx_key == AUTH_DEFERRED_PURCHASE_AUTHORIZATION_OVERRIDE_RESPONSE) ||
                (p_auth_tx->TLF01_details.tx_key == AUTH_REVERSAL_RESPONSE) ||
                (p_auth_tx->TLF01_details.tx_key == AUTH_VOID_SALE_RESPONSE) )
            {
               deferred_txn = false;

               /* If reversal or void, check to see if it is of a deferred txn. */
               if ( (p_auth_tx->TLF01_details.tx_key == AUTH_REVERSAL_RESPONSE ) ||
                    (p_auth_tx->TLF01_details.tx_key == AUTH_VOID_SALE_RESPONSE)  )
               {
                  if ( (p_auth_tx->TLF01_details.deferred_term_length[0] != 0x00) ||
                       (!strcmp(strProcessingCode, "70"))  )
                  {
                     /* Do this check because RSB Guarantor cards might have
                      * deferred data, but they are not treated as deferreds.
                      */
                     if ( p_auth_tx->BIN01_details.credit_subtype[0] != 'G' )
                     {
                        /* It is not an RSB card, so it is a deferred txn. */
                        deferred_txn = true;
                     }
                  }
               }
               else
               {
                  /* The other txn types are definitely deferreds. */
                  deferred_txn = true;
               }

               if ( deferred_txn == true )
               {
                  /* Update Deferred Balance Account */
                  if ( DB_Timing_Flag == true )
                     start_time = ptetime_get_time();

                  result_code = db_update_acf01_for_deferred_account( p_auth_tx,
                                                                      &p_auth_tx->ACF01_details,
                                                                      err_msg );

                  if ( DB_Timing_Flag == true )
                  {
                     end_time = ptetime_get_time();
                     duration = end_time - start_time;
                     update_timing_stats( ST1_DB_INSERT, 1, ACF01_DATA,
                                          (float)duration, &TimingStats );
                  }

                  if ( result_code == PTEMSG_OK )
                     strcat( update_all_status, "G1" );
                  else
                     strcat( update_all_status, "G0" );
               }
            }
         }
         else
            strcat( update_all_status, "F0" );
      }
   }

   if ( result_code != PTEMSG_OK )
   {
      result_code = PTEMSG_UPDATE_FAILED;
   }
   else if (strcmp(p_auth_tx->TLF01_details.response_code,"00")== 0)
   {
      if((strcmp(p_auth_tx->TLF01_details.dispensation.origin, "LO" ) == 0) &&
                (msg_sub_type2 == 0))
      {
         switch(p_auth_tx->TLF01_details.tx_key)
         {
            case AUTH_DEFERRED_PURCHASE_AUTHORIZATION_RESPONSE:

                  /* Deferred transactions from Voice are treated as Auths.
                   * Online deferreds are treated as credit sales.
                   */
                  if (0==strcmp(p_auth_tx->TLF01_details.handler_queue,"VOICE"))
                  {
                     result_code = process_auth_trans(p_auth_tx);
                     if ( result_code == PTEMSG_OK )
                        strcat( update_all_status, "H1" );
                     else
                        strcat( update_all_status, "H0" );
                  }
                  else
                  {
                     result_code = process_sale_trans(p_auth_tx);
                     if ( result_code == PTEMSG_OK )
                        strcat( update_all_status, "I1" );
                     else
                        strcat( update_all_status, "I0" );
                  }
            break;

            case AUTH_AUTHORIZATION_RESPONSE:
            case AUTH_PRE_AUTHORIZATION_RESPONSE:
            case AUTH_CARD_VERIFICATION_RESPONSE:
            case AUTH_CASH_ADVANCE_AUTHORIZATION_RESPONSE:
            case AUTH_CASH_ADVANCE_AUTHORIZATION_OVERRIDE_RESPONSE:		
            case AUTH_DEFERRED_PURCHASE_AUTHORIZATION_OVERRIDE_RESPONSE:
            case AUTH_AUTHORIZATION_OVERRIDE_RESPONSE	:	            
                     result_code = process_auth_trans(p_auth_tx);
                     if ( result_code == PTEMSG_OK )
                        strcat( update_all_status, "J1" );
                     else
                        strcat( update_all_status, "J0" );
            break;

            case AUTH_SALE_RESPONSE:
            case AUTH_CASH_ADVANCE_RESPONSE:
            case AUTH_SALES_COMPLETION_RESPONSE:
            case AUTH_OFFLINE_SALE_RESPONSE:
            case AUTH_QUASI_CASH_RESPONSE:
            case AUTH_RELOAD_RESPONSE:
                     result_code = process_sale_trans(p_auth_tx);
                     if ( result_code == PTEMSG_OK )
                        strcat( update_all_status, "K1" );
                     else
                        strcat( update_all_status, "K0" );
            break;

            case AUTH_REFUND_RESPONSE:
            case AUTH_OFFLINE_REFUND_RESPONSE:           
                     result_code = process_refund_trans(p_auth_tx);
                     if ( result_code == PTEMSG_OK )
                        strcat( update_all_status, "L1" );
                     else
                        strcat( update_all_status, "L0" );
            break;

            /* 12/06/99 according to Gabriel for VOID and ADJUSTMENT
             * we do not need to update RRN(replacing original with the new one)
             */
            case AUTH_VOID_SALE_RESPONSE:
            case AUTH_VOID_REFUND_RESPONSE:
            case AUTH_VOID_CASH_ADVANCE_RESPONSE:
            case AUTH_OFFLINE_VOID_SALE_RESPONSE:
            case AUTH_OFFLINE_VOID_REFUND_RESPONSE:
            case AUTH_VOID_RELOAD_RESPONSE:
                     if ((p_auth_tx->TLF01_details.tx_key == AUTH_VOID_SALE_RESPONSE) &&
                         (p_auth_tx->TLF01_details.deferred_term_length[0] != 0x00  )  )
                     {
                        /* This is the void of a deferred.
                         * If it is from Voice, do nothing here because it
                         * is in BCH20.
                         */
                        if (0!=strcmp(p_auth_tx->TLF01_details.handler_queue,"VOICE"))
                        {
                           result_code = process_void_trans(p_auth_tx);
                           if ( result_code == PTEMSG_OK )
                              strcat( update_all_status, "M1" );
                           else
                              strcat( update_all_status, "M0" );
                        }
                     }
                     else
                     {
                        result_code = process_void_trans(p_auth_tx);
                        if ( result_code == PTEMSG_OK )
                           strcat( update_all_status, "N1" );
                        else
                           strcat( update_all_status, "N0" );
                     }
            break;

            case AUTH_SALE_ADJUSTMENT_RESPONSE: 
            case AUTH_REFUND_ADJUSTMENT_RESPONSE: 
                     result_code = process_adjustments(p_auth_tx);
                     if ( result_code == PTEMSG_OK )
                        strcat( update_all_status, "O1" );
                     else
                        strcat( update_all_status, "O0" );
            break;

            case AUTH_REVERSAL_RESPONSE:
                     result_code = process_reversal(p_auth_tx);
                     if ( result_code == PTEMSG_OK )
                        strcat( update_all_status, "P1" );
                     else
                        strcat( update_all_status, "P0" );
            break;

            case AUTH_RELOAD_CONFIRM_RESPONSE:
                     /* Do not want to error out on Reload Confirms. */
                     memcpy( &tlf01, &p_auth_tx->TLF01_details, sizeof(TLF01) );

                     if ( DB_Timing_Flag == true )
                        start_time = ptetime_get_time();

                     if ( PTEMSG_OK != db_update_reload_confirm( &tlf01, err_msg))
                        TxUtils_Send_Msg_To_Operator(1, err_msg, 1, WARN_MSG,
                                                    "process_alldata_msg", 2, WARNING_ERROR,
                                                     p_auth_tx->TLF01_details.terminal_id,
                                                     p_auth_tx->TLF01_details.card_num, 
                                                     p_auth_tx->TLF01_details.merchant_id);

                     if ( DB_Timing_Flag == true )
                     {
                        end_time = ptetime_get_time();
                        duration = end_time - start_time;
                        update_timing_stats( ST1_DB_UPDATE, 1, TLF01_DATA,
                                             (float)duration, &TimingStats );
                     }
            break;

            default:
                     PRINT("unknown response received by updateds\n");
                     result_code = PTEMSG_INVALID_DATATYPE;
                     strcat( update_all_status, "Q0" );
                     sprintf( err_msg,
                             "Unknown tran type %c: for ALL_DATA request",
                              p_auth_tx->TLF01_details.tx_key);
            break;
         }
      }
      else if ((strcmp(p_auth_tx->TLF01_details.dispensation.origin, "RO" ) == 0) ||
               (msg_sub_type2 != 0 ))
      {
         result_code = process_network_request( p_auth_tx ,msg_sub_type2);
         if ( result_code == PTEMSG_OK )
            strcat( update_all_status, "R1" );
         else
            strcat( update_all_status, "R0" );
      }
      else
      {
         result_code = PTEMSG_INVALID_DATATYPE;
         strcat( update_all_status, "S0" );
      }
   }

   if ( result_code == PTEMSG_OK )
   {
      /* The above updates/inserts were successful.
       * Insert into TLF01 if record has not already been inserted.
       * Insert into TLF01 is part of update_all because EB uses
       * TLF01 as a source for settlement data.  So we cannot respond
       * to the device/network until we know the database has been
       * updated properly.  If the above updates/inserts succeed, but
       * insert into TLF01 fails, rollback the above updates/inserts;
       * transaction will be declined.
       */

      if ( p_auth_tx->host2_acquirer_cb_code[0] != '*' )
      {
         /* Populate system_date field - date txn is inserted into database. */
         memcpy( &tlf01, &p_auth_tx->TLF01_details, sizeof(TLF01) );
         create_system_date( tlf01.system_date );

         if ( p_auth_tx->TLF01_details.tran_finish_time[0] == 0x00 )
            ptetime_get_strtime( tlf01.tran_finish_time );

         /* Store status info for audit trail. */
         memcpy( tlf01.dcf01_retired_cwk,
                 update_all_status,
                 sizeof(update_all_status)-1 );

         memset(&db_recs.tlf01, 0, sizeof(db_recs.tlf01));
         memcpy(&db_recs.tlf01, &tlf01, sizeof(TLF01));

         /* Convert message type to a request type, for standardization. */
         convert_msgtype_to_request( db_recs.tlf01.message_type );

         /* Set flag to indicate to device/network
          * controllers TLF01 has been inserted.
          */
         p_auth_tx->host2_acquirer_cb_code[0] = '*';

         /* Insert into TLF01. */
         if ( DB_Timing_Flag == true )
            start_time = ptetime_get_time();

         result_code = db_insert_tlf01(&db_recs.tlf01, err_msg);

	/* Insert into TLF01_STIP table as well when inserting into TLF01 for STIP Tx - Girija Y ThoughtFocus */
		 if(( strcmp(db_recs.tlf01.response_code,"00") == 0 ) &&
			(strcmp(db_recs.tlf01.product_codes[1].code,STANDIN) == 0))
		 {
			 /* Need to update STAND in flag in case of VOID / Reverse.. TF PHANI */
			 strcpy(db_recs.tlf01.product_codes[7].amount, p_auth_tx->ch_billing_amt);
			 strcpy(db_recs.tlf01.product_codes[7].code, p_auth_tx->ch_billing_curr_code);
			/* Store DE10 Billing Conversion rate in .TF Phani*/
			 strcpy(db_recs.tlf01.product_codes[8].amount, p_auth_tx->ch_billing_conv_rate);
			 	/* Store industry_code .TF Phani*/
			 strcpy(db_recs.tlf01.product_codes[8].code, p_auth_tx->industry_code);
			 /* TF phani - Updates for 0120 MCARD fields*/
			 /* DE 61 value - which need to be populated during 0120 from sbtach*/
			 strcpy(db_recs.tlf01.source_key,p_auth_tx->acceptor_term_name);
	 //
			 /* Store DE43 here so it gets logged to TLF01:
				*   Merchant Name         --> TLF01.card_holder_name
				*   City and Country Code --> TLF01.ncf01_retired_cwk
				*  TF Phani
				*/
			   if ( db_recs.tlf01.card_holder_name[0] == 0x00 )
			   {
				  memcpy( db_recs.tlf01.card_holder_name,
						  p_auth_tx->MCF01_details.name02,
						  22 );
			   }

			   if ( db_recs.tlf01.ncf01_retired_cwk[0] == 0x00 )
			   {
				  memcpy( db_recs.tlf01.ncf01_retired_cwk,
						  p_auth_tx->MCF01_details.city,
						  13 );
				  itemp = strlen(p_auth_tx->MCF01_details.city);
				//  memset(&db_recs.tlf01.ncf01_retired_cwk[itemp],0x20,13-itemp);	
				  memcpy(&db_recs.tlf01.ncf01_retired_cwk[13], "PHL", 3 );
			   }


			   //Storing converted currency and amount while dual currency //praneeth
			   if ( 0 == strcmp(db_recs.tlf01.host_start_time, "7.000") )
			   {
					strcpy( db_recs.tlf01.currency_code, "840" );
					if (strcmp(db_recs.tlf01.product_codes[9].amount, "")) 
					{
						strcpy(amountbuff,db_recs.tlf01.total_amount);
						strcpy(db_recs.tlf01.total_amount,db_recs.tlf01.product_codes[9].amount);
						strcpy(db_recs.tlf01.product_codes[9].amount,amountbuff);
					}
			   }
			   else if ( 0 == strcmp(db_recs.tlf01.host_start_time, "5.000") )
			   {
   					strcpy( db_recs.tlf01.currency_code, "608" );
					if (strcmp(db_recs.tlf01.product_codes[9].amount, "") )
					{
						strcpy(amountbuff,db_recs.tlf01.total_amount);
						strcpy(db_recs.tlf01.total_amount,db_recs.tlf01.product_codes[9].amount);
						strcpy(db_recs.tlf01.product_codes[9].amount,amountbuff);
					}
			   }



	//
			 if( (db_recs.tlf01.tx_key == AUTH_VOID_SALE)||(db_recs.tlf01.tx_key ==AUTH_VOID_SALE_RESPONSE))
			 {
				 strcpy(db_recs.tlf01.product_codes[1].code,VOIDED);
				 result_code = db_update_tlf01_stip_void(&db_recs.tlf01, err_msg);

			 }
			 else if((db_recs.tlf01.tx_key == AUTH_REVERSAL)||(db_recs.tlf01.tx_key == AUTH_REVERSAL_RESPONSE ))
			 {
				  strcpy(db_recs.tlf01.product_codes[1].code,REVERSED);
				  /* For voice txn the stan is diffrent for sale and cancel sale txn
				  The query which is their in db_update_tlf01_stip_reversal not able to update original txn
				  so copy the original STAN into txn STAN TF-Ajay 10-Jul-2009 */
				  if(strcmp(db_recs.tlf01.handler_queue, "VOICE")==0)
				  {
					  strcpy(db_recs.tlf01.sys_trace_audit_num,db_recs.tlf01.orig_sys_trace_num);
				  }
				  result_code = db_update_tlf01_stip_reversal(&db_recs.tlf01, err_msg);
				  if(result_code != PTEMSG_OK  )
				  {/* TF Phani - This could be an Online approval/Offline reversal case*/
				   strcpy(err_msg,"");
				   result_code =db_insert_tlf01_stip(&db_recs.tlf01, err_msg);
				  }
			 }
			 else if((db_recs.tlf01.tx_key == AUTH_SALE_ADJUSTMENT)||(db_recs.tlf01.tx_key == AUTH_SALE_ADJUSTMENT_RESPONSE))
			 {
				 stip_result_code = db_update_tlf01_stip_adjust(&db_recs.tlf01, err_msg);
			 }
			 else
			 {
			     stip_result_code = db_insert_tlf01_stip(&db_recs.tlf01, err_msg);
			 }
		 }
		 
         if ( DB_Timing_Flag == true )
         {
            end_time = ptetime_get_time();
            duration = end_time - start_time;
            update_timing_stats( ST1_DB_INSERT, 1, TLF01_DATA,
                                 (float)duration, &TimingStats );
         }

         if ( result_code == PTEMSG_OK )
            strcat( update_all_status, "U1" );
         else
            strcat( update_all_status, "U0" );

         /* If EMV txn, insert into EMV01 table. */
         if ( p_auth_tx->EMV_details.currency_code[0] != 0x00 )
         {
            /* There is EMV data.  Commit the updates so far
             * to avoid a large rollback.  Then insert EMV records.
             * But do not change result code from TLF01 insert.
             */
            commit_the_update(); 

            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            rc = store_emv_records( p_auth_tx );

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_INSERT, 1, EMV01_DATA,
                                    (float)duration, &TimingStats );
            }

            if ( rc == PTEMSG_OK )
               strcat( update_all_status, "V1" );
            else
               strcat( update_all_status, "V0" );

            /* Update Chip Condition Code in DCF01. */
            if ( DB_Timing_Flag == true )
               start_time = ptetime_get_time();

            rc = update_chip_condition( p_auth_tx );

            if ( DB_Timing_Flag == true )
            {
               end_time = ptetime_get_time();
               duration = end_time - start_time;
               update_timing_stats( ST1_DB_UPDATE, 1, DCF01_DATA,
                                    (float)duration, &TimingStats );
            }

            if ( rc == PTEMSG_OK )
               strcat( update_all_status, "W1" );
            else
               strcat( update_all_status, "W0" );

            /* Commit the EMV inserts. */
            dbcommon_commit();
            dstimer_commit();
         }
      }
	  else
	{
   		 if((strcmp(p_auth_tx->TLF01_details.product_codes[1].code,STANDIN) == 0))
			 //p_auth_tx->
		{
			 if( (p_auth_tx->TLF01_details.tx_key == AUTH_REVERSAL)||(p_auth_tx->TLF01_details.tx_key == AUTH_REVERSAL_RESPONSE))
			 {strcpy(p_auth_tx->TLF01_details.product_codes[1].code,REVERSED);
			 result_code = db_update_tlf01_stip_reversal(&p_auth_tx->TLF01_details, err_msg);
			 }
			 else if( (p_auth_tx->TLF01_details.tx_key == AUTH_VOID_SALE)||(p_auth_tx->TLF01_details.tx_key == AUTH_VOID_SALE_RESPONSE))
			 {strcpy(p_auth_tx->TLF01_details.product_codes[1].code,VOIDED);
			 result_code = db_update_tlf01_stip_void(&p_auth_tx->TLF01_details, err_msg);
			 }else if( (p_auth_tx->TLF01_details.tx_key == AUTH_ADVICE)||(p_auth_tx->TLF01_details.tx_key == AUTH_ADVICE_RESPONSE))
		 	 {
		 	 	 stip_result_code = db_insert_tlf01_stip(&p_auth_tx->TLF01_details, err_msg);
		 	 }
			 if(result_code != PTEMSG_OK  )
			 {/* TF Phani - This could be an Online approval/Offline reversal case*/
				strcpy(err_msg,"");
				result_code =db_insert_tlf01_stip(&p_auth_tx->TLF01_details, err_msg);
			 }
				       dbcommon_commit();
		}

	}

   }
   else
   {
      /* The above updates/inserts failed.  Do not insert into TLF01 here,
       * because it will get rolled back.  Leave it to the calling application
       * set the response code to decline and insert into TLF01.
       */
   }

   /* Store status info for audit trail. */
   memcpy( p_auth_tx->TLF01_details.dcf01_retired_cwk,
           update_all_status,
           sizeof(update_all_status)-1 );

   return( result_code );
}

pPTE_MSG process_update_msg(pPTE_MSG p_msg_in)
{
   pBYTE          p_data;
   pPTE_MSG_DATA  p_msg_data;
   pPTE_MSG       p_msg_out;
   INT            retry;
   LONG           data_length;
   AUTH_TX        auth_tx;

   data_length   = sizeof(AUTH_TX);
   p_msg_out     = NULL_PTR;
   p_msg_data    = ptemsg_get_pte_msg_data(p_msg_in);
   p_data        = ptemsg_get_pte_msg_data_data(p_msg_data);
   memcpy( atp_buffer, p_data, data_length );
   memcpy( &auth_tx, p_data, data_length );
   app_data_type = ptemsg_get_pte_msg_data_app_data_type(p_msg_data);

   if (app_data_type == ALL_DATA)
   {
      result_code = process_alldata_msg( &auth_tx );
      memcpy( auth_tx.TLF01_details.dcf01_retired_cwk,
              update_all_status,
              sizeof(update_all_status)-1 );
      memcpy( atp_buffer, &auth_tx, data_length );
   }
   else if ( app_data_type == NCF21_DATA )
   {
      result_code = process_network_request( &auth_tx, msg_sub_type2 );
      memcpy( atp_buffer, &auth_tx, data_length );
   }
   else if ( app_data_type == TLF01_DATA )
   {
      result_code = db_update_tlf01( &auth_tx.TLF01_details, err_msg );
      memcpy( atp_buffer, &auth_tx, data_length );
   }
   else if ( app_data_type == FGUARD_DATA )
   {
      p_data = p_data + sizeof(AUTH_TX);

      /* This is a response from Fraudguard.
       * Update the record already in FGUARD from the request insert.
       * If record is not found, it means the insert has not yet
       * completed.  Wait, then try again.
       */
      retry = 0;
      do
      {
         if ( retry > 0 )
         {
            /* Wait 20 ms, then try again. */
            #ifdef WIN32
               Sleep( 20 );
            #else
               usleep( 20000 );
            #endif

            if ( retry == 5 )
            {
               #ifdef WIN32
                  Sleep( 100 );
               #else
                  usleep( 100000 );
               #endif
            }
         }
         result_code = db_update_fguard( (pFGUARD)p_data, err_msg );

      }while( (result_code == PTEMSG_NOT_FOUND) && (++retry < 6) );
   }
   else
   {
      result_code = PTEMSG_INVALID_DATATYPE;
      sprintf( err_msg,
              "Unknown app_data_type: %s for Update request from %s",
               app_data_type,reply_que);
   }

   if (result_code == PTEMSG_OK)
   {
      updates_to_db_made = true;
      p_msg_out = ptemsg_build_msg(MT_DB_REPLY,
                                   msg_sub_type1,
                                   msg_sub_type2,
                                   reply_que,
                                   application_que_name,
                                   (pBYTE)&auth_tx,
                                   data_length,
                                   app_data_type);

      if (p_msg_out == NULL_PTR)
      {
         result_code = PTEMSG_INSUFFICIENT_MEMORY;
         sprintf( err_msg,
                 "Insufficient Memory to build Update response to %s",
                  reply_que);
      }
   }
   return(p_msg_out);
}

/******************************************************************************
 *
 *  NAME:         CREATE_SYSTEM_DATE
 *
 *  DESCRIPTION:  This procedure creates the current system date into
 *                format YYYYMMDD.
 *
 *  AUTHOR:       Dennis Irby
 *
 *  INPUTS:       None
 *  OUTPUTS:      system_date  : Format = "YYYY0M0D"
 *  RTRN VALUE:   None
 *
 ******************************************************************************/
void create_system_date( pBYTE system_date ) 
{
   CHAR  time_date[25] = "";

   memset( system_date,  0x00, 9 );

   /* Get local time - Format = "YYYY-0M-0D-0H.0I.0S.JJJ" */
   ptetime_get_timestamp( time_date );

   /* Format it. */
   strncpy( system_date,  time_date,    4 ); 
   strncat( system_date, &time_date[5], 2 ); 
   strncat( system_date, &time_date[8], 2 );
   return;
}


/******************************************************************************
 *
 *  NAME:         CREATE_SYSTEM_TIME
 *
 *  DESCRIPTION:  This procedure creates the current system time into
 *                format hhmmss.jjj.
 *
 *  AUTHOR:       Dennis Irby
 *
 *  INPUTS:       None
 *  OUTPUTS:      system_time  : Format = "hhmmss.jjj"
 *  RTRN VALUE:   None
 *
 ******************************************************************************/
void create_system_time( pCHAR system_time ) 
{
   CHAR  time_date[25] = "";

   memset( system_time,  0x00, 11 );

   /* Get local time - Format = "YYYY-0M-0D-0H.0I.0S.JJJ" */
   ptetime_get_timestamp( time_date );

   /* Format it. */
   strncpy( system_time, &time_date[11], 2 ); 
   strncat( system_time, &time_date[14], 2 ); 
   strncat( system_time, &time_date[17], 6 );
   return;
}
/******************************************************************************
 *
 *  NAME:         CONVERT_MSGTYPE_TO_REQUEST
 *
 *  DESCRIPTION:  This procedure converts a message type from a response
 *                type into a request type.  For example, a sale response
 *                of 0210 will be converted to a sale request of 0200.
 *                message type is already a request, then it is not modified.
 *
 *  AUTHOR:       Dennis Irby
 *
 *  INPUTS:       msgtype - Message type
 *  OUTPUTS:      msgtype - Modified message type
 *  RTRN VALUE:   None
 *
 ******************************************************************************/
void convert_msgtype_to_request( pBYTE msgtype ) 
{
   if ( msgtype[2] == '1' )
      msgtype[2] = '0';

   else if ( msgtype[2] == '3' )
      msgtype[2] = '2';
   return;
}


/******************************************************************************
 *
 *  NAME:         STORE_EMV_RECORDS
 *
 *  DESCRIPTION:  This procedure stores each EMV tag as an individual
 *                record into the EMV01 table.
 *
 *  AUTHOR:       Dennis Irby
 *
 *  INPUTS:       p_auth_tx - Transaction Information
 *
 *  OUTPUTS:      None
 *
 *  RTRN VALUE:   0 if successful, else non-zero Oracle error code
 *
 ******************************************************************************/
BYTE store_emv_records( pAUTH_TX p_auth_tx )
{
   BYTE   b_len[4];
   CHAR   temp_len[4];
   CHAR   temp_str[256];
   CHAR   time_date[25] = "";
   BYTE   system_date[9]= "";
   BYTE   rc = PTEMSG_OK;
   INT    len;
   EMV01  emv01;
   EMV_RAW  emvraw;

   /* GET SYSTEM DATE */
   ptetime_get_timestamp( time_date );
   strncpy( system_date,  time_date,    4 ); /* YYYY-0M-0D-0H.0I.0S.JJJ */
   strncat( system_date, &time_date[5], 2 ); 
   strncat( system_date, &time_date[8], 2 ); /* YYYYMMDD */

   /* Set the constants */
   memset( emv01.transaction_id, 0x00, sizeof(emv01.transaction_id) );
   memset( emv01.system_date,    0x00, sizeof(emv01.system_date)    );

   memset( &emvraw,  0x00, sizeof(EMV_RAW)    );

   memcpy( emv01.transaction_id,
           p_auth_tx->TLF01_details.primary_key.transaction_id,
           sizeof(p_auth_tx->TLF01_details.primary_key.transaction_id) );
   memcpy( emv01.system_date, system_date, sizeof(system_date) );

   memcpy( emvraw.transaction_id,
           p_auth_tx->TLF01_details.primary_key.transaction_id,
           sizeof(p_auth_tx->TLF01_details.primary_key.transaction_id) );
   memcpy( emvraw.system_date, system_date, sizeof(system_date) );

   /* ------------------------------------- */
   /* Check each tag to see if it has data. */
   /* ------------------------------------- */

   /* CURRENCY CODE */
   if ( p_auth_tx->EMV_details.currency_code[0] != 0x00 )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "5F2A" );
      len = strlen( p_auth_tx->EMV_details.currency_code );
      sprintf( emv01.len, "%d", len );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.currency_code, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* ISSUER SCRIPT 1 */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.issuer_script_1[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memset( temp_len,        0x00, sizeof(temp_len)       );
      memset( b_len,           0x00, sizeof(b_len)          );

      memcpy( emv01.tag, p_auth_tx->EMV_details.issuer_script_1+2, 2 );

      /* Skip length and tag bytes to get the ASCII length of tag data. */
      memcpy( temp_len, p_auth_tx->EMV_details.issuer_script_1+4, 2 );
      len = hex_to_int( temp_len, 2 );
      if ( len > 0 )
      {
         sprintf( emv01.len, "%d", len );

         len = strlen( p_auth_tx->EMV_details.issuer_script_1+6 );
         memcpy( emv01.emv_data, p_auth_tx->EMV_details.issuer_script_1+6, len );

         rc = db_insert_emv01( &emv01, err_msg );
      }
   }

   /* ISSUER SCRIPT 2 */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.issuer_script_2[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F5B" );
      len = strlen( p_auth_tx->EMV_details.issuer_script_2+6 );
      if ( len > 0 )
      {
         sprintf( emv01.len, "%d", len );
         memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
         memcpy( emv01.emv_data, p_auth_tx->EMV_details.issuer_script_2+6, len );

         rc = db_insert_emv01( &emv01, err_msg );
      }
   }

   /* INTERCHANGE PROFILE */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.interchange_profile[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "82" );
      len = strlen( p_auth_tx->EMV_details.interchange_profile );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.interchange_profile, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* APPLICATION ID */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.app_id[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "84" );
      len = strlen( p_auth_tx->EMV_details.app_id );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.app_id, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* ISSUER AUTHENTICATION DATA */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.issuer_auth_data[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "91" );

      /* Skip binary length byte to get the ASCII length of tag data. */
      len = p_auth_tx->EMV_details.issuer_auth_data[0];
      sprintf( emv01.len, "%d", len*2 );

      len = strlen( p_auth_tx->EMV_details.issuer_auth_data+1 );
      if ( len > 0 )
      {
         memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
         memcpy( emv01.emv_data, p_auth_tx->EMV_details.issuer_auth_data+1, len );

         rc = db_insert_emv01( &emv01, err_msg );
      }
   }

   /* TERMINAL VERIFICATION RESULT */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.tvr[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "95" );
      len = strlen( p_auth_tx->EMV_details.tvr );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.tvr, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* TRANSACTION DATE */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.tran_date[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9A" );
      len = strlen( p_auth_tx->EMV_details.tran_date );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.tran_date, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* TRANSACTION TYPE */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.tran_type[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9C" );
      len = strlen( p_auth_tx->EMV_details.tran_type );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.tran_type, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* TRANSACTION AMOUNT */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.tran_amount[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F02" );
      len = strlen( p_auth_tx->EMV_details.tran_amount );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.tran_amount, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* OTHER AMOUNT */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.other_amount[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F03" );
      len = strlen( p_auth_tx->EMV_details.other_amount );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.other_amount, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* VERSION */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.version[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F09" );
      len = strlen( p_auth_tx->EMV_details.version );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.version, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* ISSUER APPLICATION DATA */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.iad[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F10" );
      len = strlen( p_auth_tx->EMV_details.iad );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.iad, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* COUNTRY CODE */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.country_code[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      /* Manually prepend a leading zero. Data structure is too small for it.*/
      strcpy( emv01.tag, "9F1A" );
      len = 4;
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      emv01.emv_data[0] = '0';
      memcpy( emv01.emv_data+1, p_auth_tx->EMV_details.country_code, 3 );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* SERIAL NUMBER */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.serial_number[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F1E" );
      len = strlen( p_auth_tx->EMV_details.serial_number );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.serial_number, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* APPLICATION CRYPTOGRAM */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.app_crypto[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F26" );
      len = strlen( p_auth_tx->EMV_details.app_crypto );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.app_crypto, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* CRYPTOGRAM INFORMATION DATA */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.crypto_info[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F27" );
      len = strlen( p_auth_tx->EMV_details.crypto_info );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.crypto_info, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* TERMINAL CAPABILITIES */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.terminal_capabilities[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F33" );
      len = strlen( p_auth_tx->EMV_details.terminal_capabilities );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.terminal_capabilities,len);

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* CVM RESULTS */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.cvm_results[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F34" );
      len = strlen( p_auth_tx->EMV_details.cvm_results );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.cvm_results, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* TERMINAL TYPE */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.terminal_type[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F35" );
      len = strlen( p_auth_tx->EMV_details.terminal_type );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.terminal_type, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* APPLICATION TRANSACTION COUTER */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.atc[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F36" );
      len = strlen( p_auth_tx->EMV_details.atc );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.atc, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* UNPREDICTABLE NUMBER */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.unpredictable_number[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F37" );
      len = strlen( p_auth_tx->EMV_details.unpredictable_number );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.unpredictable_number, len);

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* TRANSACTION SEQUENCE COUNTER */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.tran_sequence_ctr[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F41" );
      len = strlen( p_auth_tx->EMV_details.tran_sequence_ctr );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.tran_sequence_ctr, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* TRANSACTION CATEGORY CODE */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.tcc[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F53" );
      len = strlen( p_auth_tx->EMV_details.tcc );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.tcc, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* MERCHANT CATEGORY CODE */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.mcc[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "9F15" );
      len = strlen( p_auth_tx->EMV_details.mcc );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.mcc, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }

   /* PAN SEQUENCE NUMBER */
   if ( (rc == PTEMSG_OK) &&
        (p_auth_tx->EMV_details.pan_sequence_number[0] != 0x00) )
   {
      memset( &emv01.tag,      0x00, sizeof(emv01.tag)      );
      memset( &emv01.len,      0x00, sizeof(emv01.len)      );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );

      strcpy( emv01.tag, "5F34" );
      len = strlen( p_auth_tx->EMV_details.pan_sequence_number );
      sprintf( emv01.len, "%d", len );
      memset( &emv01.emv_data, 0x00, sizeof(emv01.emv_data) );
      memcpy( emv01.emv_data, p_auth_tx->EMV_details.pan_sequence_number, len );

      rc = db_insert_emv01( &emv01, err_msg );
   }


   /* RAW EMV DATA */
   if ( (rc == PTEMSG_OK) &&
        ((p_auth_tx->EMV_details.emv_block[0] != 0x00)  ||
         (p_auth_tx->EMV_details.emv_block[1] != 0x00))  )
   {
      /* Determine the block size */

	  if(strcmp(p_auth_tx->TLF01_details.handler_queue,"dcpisoA")== 0 )   
	  len = genutil_bcd_to_int( p_auth_tx->EMV_details.emv_block, 2 ) + 2;
	  else
	  { 	if (strcmp(p_auth_tx->BIN01_details.card_family,CARD_MASTERCARD) == 0)
			  len = genutil_bcd_to_int( p_auth_tx->EMV_details.emv_block, 2 ) + 2;
		  	else
		  	{	len  = p_auth_tx->EMV_details.emv_block[0];  	
		  		len++;
		  	}
	  }
      /* Don't copy the length */
      memcpy( emvraw.RAW_DATA , p_auth_tx->EMV_details.emv_block , len  );
      sprintf( emvraw.DATA_LENGTH, "%d", len );

      rc = db_insert_emvraw( &emvraw, err_msg );
   }

   if ( rc != PTEMSG_OK )
   {
      memset( temp_str, 0x00, sizeof(temp_str) );
      sprintf( temp_str,
              "Update EMV01 failed, tag %s: %s",
               emv01.tag, err_msg );
      TxUtils_Send_Msg_To_Operator( 1, temp_str, 1, WARN_MSG,
                                   "store_emv_records",
                                    2, WARNING_ERROR,
                                    p_auth_tx->TLF01_details.terminal_id,
                                    p_auth_tx->TLF01_details.card_num,
                                    p_auth_tx->TLF01_details.merchant_id );
   }

   return( rc );
}

/******************************************************************************
 *
 *  NAME:         UPDATE_CHIP_CONDITION
 *
 *  DESCRIPTION:  This procedure stores the value from EMV.chip_condition_code
 *                into DCF01.additional_pos_information.
 *
 *  AUTHOR:       Dennis Irby
 *
 *  INPUTS:       p_auth_tx - Transaction Information
 *
 *  OUTPUTS:      None
 *
 *  RTRN VALUE:   0 if successful, else non-zero Oracle error code
 *
 ******************************************************************************/
BYTE update_chip_condition( pAUTH_TX p_auth_tx )
{
   BYTE  rc;
   CHAR  temp_str[256];

   rc = db_udpate_chip_condition(p_auth_tx, err_msg);
   if ( rc != PTEMSG_OK )
   {
      memset( temp_str, 0x00, sizeof(temp_str) );
      sprintf( temp_str,
              "Update chip condition failed, %s",
               err_msg );
    /*  TxUtils_Send_Msg_To_Operator( 1, temp_str, 1, WARN_MSG,
                                   "update_chip_condition",
                                    2, WARNING_ERROR,
                                    p_auth_tx->TLF01_details.terminal_id,
                                    p_auth_tx->TLF01_details.card_num,
                                    p_auth_tx->TLF01_details.merchant_id );*/
   }
   return( PTEMSG_OK );
}

pPTE_MSG process_db_request(pPTE_MSG p_msg_in)
{
   pPTE_MSG       p_msg_out;
   BYTE           MsgSubtype1;
   BYTE           MsgSubtype2;
   CHAR           query_start_time[20]="";
   CHAR           query_end_time  [20]="";
   CHAR           errbuf[120];
   INT            ret_val;
   double         start_time;
   double         end_time;
   double         duration;

   MsgSubtype2 = ptemsg_get_msg_subtype2(p_msg_in);
   MsgSubtype1 = ptemsg_get_msg_subtype1(p_msg_in);

   memset(atp_buffer, 0, sizeof(atp_buffer));
   if ( ds_timer_flag == DS_TIMER_ON )
   {
      /* The functionality to check the time of a query is turned on.
       * Get the time before the query. Will check it after the query.
       */
      ptetime_get_strtime( query_start_time );
   }

   if ( DB_Timing_Flag == true )
   {
      /* The functionality to gather DB Query Timing Statistics is ON.
       * Get system time, then do again after the query.  This is
       * different than the above timings.  That one flags long queries;
       * this one gather stats.
       */
      start_time = ptetime_get_time();
   }

   switch (msg_sub_type1)
   {
      case ST1_DB_UPDATE: p_msg_out = process_update_msg(p_msg_in);
                          break;
      case ST1_DB_INSERT: p_msg_out = process_insert_msg(p_msg_in);
                          break;
      default:
        p_msg_out = NULL_PTR;
        result_code = PTEMSG_INVALID_SUBTYPE1;
        sprintf(err_msg, "Unknown subtype1 for database request from %s", reply_que);
        break;
   }

   if ( DB_Timing_Flag == true )
   {
      /* The functionality to gather DB Query Timing Statistics is ON.
       * Start time has been obtained. Now get end time and calculate
       * the duration and update the statistics.
       */
      end_time = ptetime_get_time();

      duration = end_time - start_time;

      update_timing_stats( MsgSubtype1, MsgSubtype2, app_data_type,
                           (float)duration, &TimingStats );
   }

   if ( ds_timer_flag == DS_TIMER_ON )
   {
      /* The functionality to check the time of a query is turned on.
       * See if the query exceeded desired time length.
       */
      ptetime_get_strtime( query_end_time );
      memset( errbuf, 0x00, sizeof(errbuf) );
      ret_val = compare_query_time_against_criteria( query_start_time,
                                                     query_end_time,
                                                     ds_timer_value,
                                                     p_msg_in,
                                                     ServiceName,
                                                     errbuf );
      if ( ret_val == false )
      {
         /* The query exceeded the time criteria.  Log informational message. */
         LogEvent( errbuf, INFO_MSG );
 		 //TxUtils_Send_Msg_To_Operator( 1, errbuf, 1, WARN_MSG,"Process DB Request-Updatds",4, INFO_ERROR, 0, 0, 0 );
      }
   }
   return(p_msg_out);
}

void process_monitor_request(pPTE_MSG p_msg_in)
{
   CHAR monitor_flag[100]="";
   pCHAR orig_comm;
   CHAR MonAdd[100]="";

   memset(atp_buffer, 0, sizeof(atp_buffer));
   switch (msg_sub_type1)
   {
      case ST1_MONITOR_UP: 
          orig_comm = ptemsg_get_msg_orig_comms_info(p_msg_in);
          WriteMemMonitorTable((BYTE *)orig_comm);  
          break;
      case ST1_MONITOR_DOWN  :
          WriteMemMonitorTable((BYTE *)monitor_flag); 
          break;
      default:
          result_code = PTEMSG_INVALID_SUBTYPE1;
          sprintf(err_msg, "Unknown subtype1 for database request from %s", reply_que);
          break;
   }
   return;
}


void commit_the_update()
{
   if (updates_to_db_made == true)
   {
      dbcommon_commit();
      dstimer_commit();
      updates_to_db_made = false;
   }
   return;
}

BYTE PinnacleMsgHandler(pPTE_MSG p_msg_in)
{
   LONG        i;
   LONG        num_messages;
   LONG        ipc_rcode;
   CHAR        temp_str [80];
   pPTE_MSG    p_cur_msg;
   pPTE_MSG    p_tmp_msg;
   pPTE_MSG    p_chn_out;
   pPTE_MSG    p_new_chn;
   pBYTE       p_data;
   pBYTE       p_data1;
   pPTE_MSG_DATA  p_msg_data;
   AUTH_TX     auth_tx;
   INT            ret_val;
   INT            num_sql;
   int         refresh_flag = 0;  /* If an error in update_mem_record or delete_mem_record,
                                     delete all recs. in mem and recreate all tables over again 
                                     from the database.
                                   */
   ptestats_accumulate_msg_stats(p_msg_in);
   result_code = PTEMSG_OK;

   p_cur_msg = p_msg_in;
   p_tmp_msg = NULL_PTR;
   p_chn_out = NULL_PTR;
   i = 1;

   num_messages = ptemsg_get_num_chained_messages(p_msg_in);
   p_msg_data    = ptemsg_get_pte_msg_data(p_msg_in);
   p_data        = ptemsg_get_pte_msg_data_data(p_msg_data);
   memcpy( &auth_tx, p_data, sizeof(AUTH_TX) );

   app_data_type = ptemsg_get_pte_msg_data_app_data_type(p_msg_data);
   p_data = p_data + sizeof(AUTH_TX);

   memset( update_all_status, 0x00, sizeof(update_all_status) );
   while ((i <= num_messages) && (p_cur_msg != NULL_PTR))
   {
      reply_que = ptemsg_get_msg_orig_queue(p_cur_msg);
      strcpy(orig_comm_inf, ptemsg_get_msg_orig_comms_info(p_cur_msg));
      app_data_type = 0;

      msg_sub_type1 = ptemsg_get_msg_subtype1(p_cur_msg);
      msg_sub_type2 = ptemsg_get_msg_subtype2(p_cur_msg);
      memset( err_msg, 0x00, sizeof(err_msg) );

      switch (ptemsg_get_msg_type(p_cur_msg))
      {
         case MT_DB_REQUEST: 
               p_tmp_msg  = process_db_request(p_cur_msg);
               p_msg_data = ptemsg_get_pte_msg_data(p_cur_msg);
               p_data1    = ptemsg_get_pte_msg_data_data(p_msg_data);
               memcpy( &auth_tx, p_data1, sizeof(AUTH_TX) );
               break;

         case MT_SYSTEM_REQUEST:
            ptesystm_system_msg_handler(p_cur_msg);
            if ( ST1_SYS_PING == ptemsg_get_msg_subtype1(p_msg_in) )
            {
               if ( ST2_NO_VERSION != ptemsg_get_msg_subtype2(p_msg_in) )
               {
                  /* When pinged, display application version on Monitor. */
                  sprintf( temp_str,
                          "Pinged -> Data Server: %s, version %s",
                           ServiceName, Version );
                  TxUtils_Send_Msg_To_Operator( 1, temp_str, 1, INFO_MSG,
                                               "PinnacleMsgHandler",
                                                0, INFO_ERROR, 0, 0, 0 );

                  /* Get Database Timing Parameters to gather
                   * statistics about each query.
                   */
                  memset( ReportTime, 0x00, sizeof(ReportTime) );
                  memset( temp_str,   0x00, sizeof(temp_str)   );
                  ret_val = get_timing_parameters( &DB_Timing_Flag,
                                                    ReportTime, 
                                                   &ForceReport,
                                                    temp_str );
                  LogEvent( temp_str, INFO_MSG );

                  if ( DB_Timing_Flag == true )
                  {
                     /* Get the time for when the DB Timing
                      * Statistical Report is to be logged.
                      */
                     NextReportTime = set_next_report_time_at_startup( ReportTime );

                     if ( ForceReport == true )
                     {
                        /* User wants to log the stats
                         * right now.  Log them then
                         * reset the statistics.
                         */
                        num_sql = log_timing_statistics_report( &TimingStats );
                        memset( temp_str, 0x00, sizeof(temp_str) );
                        sprintf( temp_str,
                                "%s logged stats for %d SQLs",
                                 app_name, num_sql );
                        LogEvent( temp_str, INFO_MSG );

                        reset_timing_stats( &TimingStats );
                     }
                  }
               }
            }
            break;

         case MT_SYS_MONITOR: 
               process_monitor_request(p_cur_msg);
               break;

         default :
            /*
               Received an unknown msg type.  If the request was destined for
               this dataserver, log an error because I can't process it.
               Otherwise, try to forward it on to the actual destination.
            */
            if ((strncmp(ptemsg_get_msg_dest_queue(p_cur_msg), application_que_name, strlen(application_que_name)) == 0) ||
                (strncmp(ptemsg_get_msg_dest_queue(p_cur_msg), control_que_name, strlen(control_que_name)) == 0)
               )
            {
               result_code = PTEMSG_INVALID_MSGTYPE;
               sprintf(err_msg, "Unknown msgtype for request from %s", reply_que);
            }
            else
            {
               sprintf(temp_str, "forwarding message to queue %s\n", 
                       ptemsg_get_msg_dest_queue(p_cur_msg));
               ptemsg_set_orig_comms_info(p_cur_msg, orig_comm_inf);
               ipc_rcode = pteipc_send(p_cur_msg, ptemsg_get_msg_dest_queue(p_cur_msg));

               if (ipc_rcode < 0)
               {
                  result_code = PTEMSG_COULD_NOT_FORWARD;
                  pteipc_get_errormsg(ipc_rcode, temp_str);
                  sprintf(err_msg, "error forwarding to queue %s: %s", 
                  ptemsg_get_msg_dest_queue(p_cur_msg), temp_str);
               }
            }
            break;
      }  /* switch msg_type */

      if (result_code != PTEMSG_OK) break;

      if (p_tmp_msg != NULL_PTR)
      {
         result_code = ptemsg_get_result_code(p_tmp_msg);

         if (result_code != PTEMSG_OK)
         {
            free(p_chn_out);
            p_chn_out = p_tmp_msg;
            p_tmp_msg = NULL_PTR;
            break;
         }

         if (p_chn_out == NULL_PTR)
         {
            p_chn_out = p_tmp_msg;
            p_tmp_msg = NULL_PTR;
         }
         else
         {
            p_new_chn = ptemsg_chain_message(p_chn_out, p_tmp_msg);

            if (p_new_chn == NULL_PTR)
            {
               result_code = PTEMSG_INSUFFICIENT_MEMORY;
               sprintf(err_msg, "Insufficient Memory to chain response to %s", reply_que);
               break;
            } 
            else
            {
               p_chn_out = p_new_chn;
               p_tmp_msg = NULL_PTR;
            }
         }
      }

      if ((++i) <= num_messages)
         p_cur_msg = ptemsg_get_chained_pte_msg(p_msg_in, i);
   }  /* while */


   /*
    * Be sure to free up the temp message.
    */
   if (p_tmp_msg != NULL_PTR)
   {
      free(p_tmp_msg);
      p_tmp_msg = NULL_PTR;
   }

   /*
    * If there was an error, back out the changes.
    * Otherwise commit the changes.
    */
   reply_que = ptemsg_get_msg_orig_queue(p_msg_in);

   if (result_code != PTEMSG_OK)
   {
      rollback_the_update();
      if (p_chn_out != NULL_PTR)
      {
         free(p_chn_out);
         p_chn_out = NULL_PTR;
      }

      /*
       * Try to create an error response message to send back to the 
       * originating application.  If it is a memory related error, this
       * may fail also (but I'll at least try).  Also log the error here
       * if this is a Voice transaction so that the error gets logged;
       * VoiceAuth does not log to syslog or Monitor.
       */
      if ( 0 == strcmp(auth_tx.TLF01_details.handler_queue, "VOICE") )
      {
         /* This is a voice transaction. Log any errors. */
         TxUtils_Send_Msg_To_Operator( 1, err_msg, 1, WARN_MSG,
                                      "Voice", 2, WARNING_ERROR,
                                       auth_tx.TLF01_details.terminal_id,
                                       auth_tx.TLF01_details.card_num,
                                       auth_tx.TLF01_details.merchant_id );
      }

      memcpy(atp_buffer + sizeof(AUTH_TX),  err_msg, strlen(err_msg) + 1);
      p_chn_out = ptemsg_build_msg(MT_DB_REPLY,        
                                    msg_sub_type1,
                                    msg_sub_type2,
                                    reply_que,
                                    application_que_name,
                                    (pBYTE) atp_buffer,
                                    strlen(err_msg) + 1 + sizeof(AUTH_TX), 
                                    app_data_type);

      if (p_chn_out == NULL_PTR)
      {
         TxUtils_Send_Msg_To_Operator(1, err_msg, 1, WARN_MSG, "PinnacleMsgHandler", 2, WARNING_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
         result_code = PTEMSG_INSUFFICIENT_MEMORY;
         sprintf(err_msg, "Insufficient Memory to build error response to %s", reply_que);
      }
   }
   else
   {
      commit_the_update(); 
   }

   if (p_chn_out != NULL_PTR)
   {
      if ((result_code == PTEMSG_OK) &&
          (ptemsg_get_type_of_reply_needed(p_msg_in) == PTEMSG_REPLY_ONLY_IF_FAILS))
      {
         free(p_chn_out);
         return(PTEMSG_OK);
      }

      ptemsg_set_result_code(p_chn_out, result_code);
      ptemsg_set_orig_comms_info(p_chn_out, orig_comm_inf);

      ipc_rcode = pteipc_send(p_chn_out, reply_que);
      free(p_chn_out);
      if (ipc_rcode < 0)
      {
         TxUtils_Send_Msg_To_Operator(1, err_msg, 1, WARN_MSG, "PinnacleMsgHandler", 2, WARNING_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
          result_code = PTEMSG_IPC_ERROR;
          pteipc_get_errormsg(ipc_rcode, temp_str);
          sprintf(err_msg, "error sending response to %s: %s", reply_que, temp_str);
      }
   }
   return(result_code);
}

BOOLEAN perform_startup()
{
   CHAR XipcInstanceName[12];
   INT      ret_val;
   CHAR     Buffer[300] = "";

   if (dbcommon_connect("equitable", "equitable", "equitable", "ORC1", err_msg) != PTEMSG_OK)
   {      printf   ( "%s", err_msg );

      TxUtils_Send_Msg_To_Operator(1, err_msg, 1, ERROR_MSG, "perform_startup", 4, FATAL_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
      return(false);
   }
   #ifdef _DEBUG
    printf("Connected to ORACLE\n");
   #endif

    GetAppName(app_name);
    GetXipcInstanceName(XipcInstanceName);

#ifndef WIN32

   /* Diagnostic code to trap the following signals. */
   sigset( SIGALRM, TrapFunction );
   sigset( SIGBUS,  TrapFunction );
   sigset( SIGEMT,  TrapFunction );
   sigset( SIGFPE,  TrapFunction );
   sigset( SIGILL,  TrapFunction );
   sigset( SIGIOT,  TrapFunction );
   sigset( SIGKILL, TrapFunction );
   sigset( SIGPIPE, TrapFunction );
   sigset( SIGPOLL, TrapFunction );
   sigset( SIGPWR,  TrapFunction );
   sigset( SIGQUIT, TrapFunction );
   sigset( SIGSEGV, TrapFunction );
   sigset( SIGSYS,  TrapFunction );
   sigset( SIGTRAP, TrapFunction );
   sigset( SIGUSR1, TrapFunction );
   sigset( SIGUSR2, TrapFunction );

#endif

   //if (pteipc_init_single_instance_app (app_name, XipcInstanceName) == false)
   if (!pteipc_init_multiple_instance_app(app_name, ServiceName, XipcInstanceName))
   {
      TxUtils_Send_Msg_To_Operator(1, "Failed to create XIPC queues", 1, ERROR_MSG, "perform_startup", 4, FATAL_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
      //pteipc_shutdown_single_instance_app();
      pteipc_shutdown_multiple_instance_app();
      dbcommon_disconnect(err_msg);
      return(false);
   }

   ret_val = get_dataserver_ini_timer_value( &ds_timer_flag, &ds_timer_value,
                                             ServiceName,     Buffer );
   if ( false == ret_val )
   {
      LogEvent( Buffer, WARN_MSG );
   }
   else if ( ds_timer_flag == DS_TIMER_ON )
   {
      sprintf( Buffer,
              "%s:Data Server timing of queries is turned on, value is %d",
               ServiceName, ds_timer_value );
      LogEvent( Buffer, INFO_MSG );
   }

   /* Get Database Timing Parameters to gather statistics about each query. */
   memset( ReportTime, 0x00, sizeof(ReportTime) );
   memset( Buffer,     0x00, sizeof(Buffer)     );
   ret_val = get_timing_parameters( &DB_Timing_Flag, ReportTime, &ForceReport, Buffer );
   LogEvent( Buffer, INFO_MSG );

   /* Get the time for when the DB Timing Statistical Report is to be logged. */
   if ( DB_Timing_Flag == true )
   {
      reset_timing_stats( &TimingStats );
      NextReportTime = set_next_report_time_at_startup( ReportTime );
   }

   ret_val = CreateSQL01_Table();
   if ( ret_val < 0 )
   {
      sprintf(Buffer, "Unable to create SQL01 in memory. Xipc err %d", ret_val);
      LogEvent( Buffer, WARN_MSG );
   }

   /* Get the message for cash bonus participants who do not win. */
   get_cash_bonus_ini_info();   
   return(true);
}

#ifndef WIN32

void TrapFunction( INT signum )
{
   CHAR Buffer[100];

   XIPC_TRAP_FUNCTION_TEST( TrapFunction, signum );

   memset( Buffer, 0x00, sizeof(Buffer) );
   sprintf( Buffer, "%s:  Caught signal %d", app_name, signum );
   LogEvent( Buffer, ALERT_MSG );
}

#endif

void MainProcessor()
{
   LONG     ipc_rcode;
   pPTE_MSG p_msg;
   CHAR     Buffer[256];
   CHAR     MonAdd[100]="";
   INT      num_sql;
   INT      err_ctr = 0;
   CHAR     strError[512] = {0} ;

	   GetAppName( AppName );
   sprintf( Buffer,
           "Starting the Service: %s, version %s",
            AppName, Version );
   LogEvent( Buffer, INFO_MSG );
	printf( "%s\n", Buffer );

   #ifdef _DEBUG
      pteipc_trace_on();
   #endif

   if (perform_startup() == false)
   {
      MainProcessDone = 1;
	  	     sprintf( Buffer,
           "Shutting down the Service: %s, version %s",
            AppName, Version );
		  LogEvent( Buffer, INFO_MSG );
			printf( "%s\n", Buffer );

      return;
   }

   sprintf( Buffer,
           "Starting the Service: %s, version %s",
            ServiceName, Version );
   LogEvent( Buffer, INFO_MSG );
   printf( "%s\n", Buffer );

   #ifdef _DEBUG
      printf("DataServer is ready. press <ENTER> to exit\n");
   #endif

   while (!EndProcessSignalled)
   {
      /* You are blocked here waiting for a message on either app queue or control que  */
      /* if there is no message on either que for the specified time, the blocking call returns   */
      p_msg = pteipc_receive(application_que_name, control_que_name, 
                             TIME_BETWEEN_CHECKS, &ipc_rcode);
      if (p_msg != NULL_PTR)
      {
         PinnacleMsgHandler(p_msg);
         free(p_msg);
      }
      else if (ipc_rcode != QUE_ER_TIMEOUT) 
      {
         pteipc_get_errormsg(ipc_rcode, err_msg);
         sprintf(Buffer, "Error on pteipc_receive %s", err_msg);
         TxUtils_Send_Msg_To_Operator(1, Buffer, 1, WARN_MSG, "MainProcessor", 2, WARNING_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);

         /* There is a problem with the queue.  Delay 1 second
          * so as to not flood Applnk's queue and syslog.
          */
         #ifdef WIN32
            Sleep( 1000 );
         #else
            usleep( 1000000 );
         #endif

         /* Inform Operators if service's queue is no longer readable. */
         if ( ++err_ctr > 10 )
         {
            err_ctr = 0;
            sprintf( strError,
                    "SHUT DOWN %s. UNABLE TO ACCESS QUEUE!!!!",
                     ServiceName );
            TxUtils_Send_Msg_To_Operator (1, strError, 1, ALERT_MSG,
                                         "MainProcessor", 4, FATAL_ERROR,0,0,0);
            #ifdef WIN32
               Sleep (5000);
            #else
               usleep (5000000);
            #endif
         }

         /* Comment the following out after the production stability
          * problem is resolved.
          */
         /* This line is to gather XIPC info *
         memset( XipcErrBuffer, 0x00, sizeof(XipcErrBuffer) );
         XipcSystemErrorReport( XipcErrBuffer, sizeof(XipcErrBuffer)-1 );
         LogEvent( XipcErrBuffer, ERROR_MSG );
         exit(1);
         */
      }
      else
      {
         /* The queue read has timed out.  This means there is no
          * activity for this application.  Take this opportunity
          * to see if it is time to log the database timing stats.
          */
         if ( is_it_report_time(NextReportTime) )
         {
            /* Time to report the DB timing measurement statistics. */
            num_sql = log_timing_statistics_report( &TimingStats );

            memset( Buffer, 0x00, sizeof(Buffer) );
            sprintf( Buffer,
                    "%s logged stats for %d SQLs",
                     app_name, num_sql );
            LogEvent( Buffer, INFO_MSG );

            reset_timing_stats( &TimingStats );
            NextReportTime = set_next_report_time_at_startup( ReportTime );
         }
      }
      dstimer_check_for_timeouts();
   }
   dstimer_shutdown();

   pteipc_shutdown_multiple_instance_app(); 
   #ifdef _DEBUG
      printf("pteipc shutdown successful\n");
   #endif

   if (dbcommon_disconnect(err_msg) != PTEMSG_OK)
      printf("%s\n", err_msg);
   else
      printf("Disconnected from ORACLE\n");
   MainProcessDone = 1;
}

void EndProcess()
{
   CHAR Buffer[100] = "";

   sprintf( Buffer, "Shutting down the %s Service, version %s",
            ServiceName, Version );
   LogEvent( Buffer, INFO_MSG );
   strcat( Buffer, "\n" );
   PRINT( Buffer );
   pteipc_sleep(3000);
}


/******************************************************************************
 *
 *  NAME:         GET_CASH_BONUS_RESULT
 *
 *  DESCRIPTION:  This function determines if a txn qualifies for the Cash
 *                Bonus program.  If yes, it calls a function to see if it
 *                is a winner.
 *
 *  INPUTS:       p_auth_tx - Transaction information
 *
 *  OUTPUTS:      None
 *
 *  RTRN VALUE:   true if txn is a Cash Bonus winner, else false
 *
 *  AUTHOR:       Dennis Irby
 *
 ******************************************************************************/
INT get_cash_bonus_result( pAUTH_TX p_auth_tx )
{
   INT   retval = false;
   INT   cash_bonus_result;
   CHAR  errbuf[100];

   /* Does transaction qualify for the Cash Bonus program? */
   if (p_auth_tx->TLF01_details.update_mask[0] & BON01_MASK)
   {
      /* Initialize Global Variables */
      CashBonusWinner = 0;  /* Init to "not a winner". */

      /* Go get all Cash Bonus Programs from BON02. */
      cash_bonus_result = db_process_cash_bonus_programs( p_auth_tx, errbuf );

      if ( cash_bonus_result == NO_CASH_WINNER )
      {
         memcpy( p_auth_tx->TLF01_details.response_text,
                 CashBonusNonWinnerMsg,
                 sizeof(p_auth_tx->TLF01_details.response_text)-1 );
      }
      else if ( cash_bonus_result == CASH_WINNER )
      {
         retval = true;
         if ( CashBonusWinner > 1 )
         {
            /* Multiple winner. Let's log the message going to terminal. */
            strcat( update_all_status, "T1" );
            TxUtils_Send_Msg_To_Operator(1, p_auth_tx->TLF01_details.response_text,
                                         1, WARN_MSG,
                                        "get_cash_bonus_result",3,WARNING_ERROR,
                                         p_auth_tx->TLF01_details.terminal_id, 
                                         p_auth_tx->TLF01_details.card_num, 
                                         p_auth_tx->TLF01_details.merchant_id);
         }
      }
      else if ( cash_bonus_result == CASH_PROBLEM )
      {
         strcat( update_all_status, "T0" );
         TxUtils_Send_Msg_To_Operator(1, errbuf, 1, WARN_MSG,
                                     "get_cash_bonus_result", 3, WARNING_ERROR,
                                      p_auth_tx->TLF01_details.terminal_id, 
                                      p_auth_tx->TLF01_details.card_num, 
                                      p_auth_tx->TLF01_details.merchant_id);

         strcpy( errbuf, "Warning: problem with Cash Bonus");
         TxUtils_Send_Msg_To_Operator(1, errbuf, 1, WARN_MSG,
                                  "get_cash_bonus_result", 3, WARNING_ERROR,
                                   p_auth_tx->TLF01_details.terminal_id, 
                                   p_auth_tx->TLF01_details.card_num, 
                                   p_auth_tx->TLF01_details.merchant_id);
      }
   }
   return( retval );
}


/******************************************************************************
 *
 *  NAME:         PERFORM_CASH_BONUS_PROCESSING
 *
 *  DESCRIPTION:  This function determines if a transaction is a winner in
 *                a Cash Bonus Program.
 *
 *  INPUTS:       p_auth_tx - Transaction information
 *                p_bon02   - Cash Bonus Program record
 *
 *  OUTPUTS:      err_msg - Text message of any system problems
 *
 *  RTRN VALUE:   CASH_WINNER, NO_CASH_WINNER, CASH_PROBLEM
 *
 *  AUTHOR:       Dennis Irby
 *
 ******************************************************************************/
INT perform_cash_bonus_processing(pAUTH_TX p_auth_tx,pBON02 p_bon02,pCHAR err_msg)
{
   #define  PESO         "608"
   #define  CRF01_TABLE  "Crf01Table"

   INT    retval = NO_CASH_WINNER;
   INT    amt_idx;
   INT    db_time_period;  // Indicates which time period is in database
   INT    cur_time_period; // Indicates which time period we are in
   XINT   rt_memaccess;
   LONG   rt_record;
   LONG   start_date; 
   LONG   end_date;
   LONG   tran_date;
   LONG   threshold;
   LONG   tran_ctr;
   LONG   tp;
   LONG   period_winners_max;
   LONG   period_winners_ctr;
   LONG   program_winners_max;
   LONG   program_winners_ctr;
   double low_amt;
   double high_amt;
   double conv_rate;
   double tran_amt;
   CHAR   system_date[50];
   CHAR   date_str[9];
   CRF01  crf01;
   INT    currency_code_size = sizeof(crf01.primary_key.currency_code);


   /*+-------------------------------------+
     | Check Cash Bonus Program date range |
     +-------------------------------------+*/

   /* Get Cash Bonus Program dates.
    * Switch date format from ddmmyyyy to yyyymmdd.
    */
   memset( date_str, 0x00, sizeof(date_str) );
   memcpy( date_str,   p_bon02->program_start_date+4, 4 ); /* YYYYY */
   memcpy( date_str+4, p_bon02->program_start_date+2, 2 ); /* MM    */
   memcpy( date_str+6, p_bon02->program_start_date,   2 ); /* DD    */
   start_date = Txutils_Calculate_Julian_Date( date_str );

   memset( date_str, 0x00, sizeof(date_str) );
   memcpy( date_str,   p_bon02->program_end_date+4, 4 ); /* YYYYY */
   memcpy( date_str+4, p_bon02->program_end_date+2, 2 ); /* MM    */
   memcpy( date_str+6, p_bon02->program_end_date,   2 ); /* DD    */
   end_date = Txutils_Calculate_Julian_Date( date_str );

   /* Get system date */
   memset( system_date, 0x00, sizeof(system_date) );
   memset( date_str,    0x00, sizeof(date_str   ) );
   ptetime_get_timestamp( system_date );
   get_date( system_date, date_str );
   tran_date = Txutils_Calculate_Julian_Date( date_str );

   /* Compare the dates. */
   if ( (tran_date >= start_date) && (tran_date <= end_date) )
   {
      /*+---------------------------------------------+
        | The Cash Bonus Program is currently active. |
        +---------------------------------------------+*/

      tran_ctr  = atol( p_bon02->tran_ctr );
      threshold = atol( p_bon02->tran_threshold );

      period_winners_max = atol( p_bon02->max_period_winners );
      period_winners_ctr = atol( p_bon02->period_win_ctr     );

      program_winners_max = atol( p_bon02->max_program_winners );
      program_winners_ctr = atol( p_bon02->program_win_ctr     );

      /* Do we look for a winner, or to reverse out a txn? */
      if ( (p_auth_tx->TLF01_details.tx_key == AUTH_REVERSAL) ||
           (p_auth_tx->TLF01_details.tx_key == AUTH_REVERSAL_RESPONSE) )
      {
         /* REVERSAL */
         if ( tran_ctr == 0 )
         {
            /* Last transaction was a winner. Decrement winner count. */
            tran_ctr = threshold - 1;

            period_winners_ctr--;
            if ( period_winners_ctr < 0 )
               period_winners_ctr = 0;

            sprintf( p_bon02->period_win_ctr,  "%d", period_winners_ctr  );

            program_winners_ctr--;
            if ( program_winners_ctr < 0 )
               program_winners_ctr = 0;

            sprintf( p_bon02->program_win_ctr, "%d", program_winners_ctr );
         }
         else
         {
            tran_ctr--;
         }

         if ( tran_ctr < 0 )
            tran_ctr = 0;

         sprintf( p_bon02->tran_ctr, "%d", tran_ctr );
      }
      else
      {
         /* Check to see if we have switched to a new time period. */
         db_time_period  = p_bon02->tag_id[0];
         cur_time_period = 1;
         tp = atoi( p_bon02->time_period );

         /* Take steps from start date until today.  Each step is
          * one time period.  See how many time periods it takes
          * to get to today.  That results in the current time period.
          */
         while( ((start_date + (tp-1)) + (tp * (cur_time_period-1))) < tran_date )
            cur_time_period++;

         /* Do we need to switch to a new time period? */
         if ( cur_time_period > db_time_period )
         {
            /* ------------------------------------------ */
            /* New Time Period. Reset Period Win Counter. */
            /* ------------------------------------------ */
            period_winners_ctr = 0;
            p_bon02->tag_id[0] = cur_time_period;
         }

         /* Check threshold to see if we have a winner. */
         tran_ctr++;
         if ( tran_ctr >= threshold )
         {
            /*+-----------------------------------------+
              |   WE  HAVE  A  POSSIBLE  WINNER !!!!!!  |
              +-----------------------------------------+*/

            /* Make sure we have not reached max winners for period. */
            if ( program_winners_ctr < program_winners_max )
            {
               if ( period_winners_ctr < period_winners_max )
               {
                  /* Winner count is OK.  Check purchase amounts.
                   * First convert to Peso if necessary.
                   */
                  tran_amt = atof(p_auth_tx->TLF01_details.total_amount)/100.0;
                  if ( 0 == strcmp("840",p_auth_tx->TLF01_details.currency_code))
                  {
                     /* --------------------------------- */
                     /* Need to convert from USD to Peso. */
                     /* --------------------------------- */
                     memset( &crf01, 0x00, sizeof(CRF01) );
                     rt_memaccess = MemAccess( CRF01_TABLE );
                     if ( rt_memaccess < 0)
                     {
                        conv_rate = atof(p_auth_tx->TLF01_details.conversion_rate);
                     }
                     else
                     {
                        strcpy( crf01.primary_key.currency_code, PESO );
                        rt_record = FindMemRecord( (pBYTE)&crf01, currency_code_size,
                                                   sizeof(CRF01), CRF01_TABLE );
                        if ( rt_record < 0 )
                        {
                           conv_rate = atof(p_auth_tx->TLF01_details.conversion_rate);
                        }
                        else
                        {
                           conv_rate = atof( crf01.conversion_rate );
                        }
                     }

                     if ( conv_rate > 0.0 )
                        tran_amt *= conv_rate;
                  }

                  /* Check amount against each BON02 amount range. */
                  for( amt_idx=0; amt_idx<5; amt_idx++ )
                  {
                     low_amt  = atof(p_bon02->amount_range[amt_idx].low_amount )/100.0;
                     high_amt = atof(p_bon02->amount_range[amt_idx].high_amount)/100.0;

                     if ( (low_amt <= tran_amt) && (tran_amt <= high_amt) )
                     {
                        /*+---------------------------------------------+
                          | WINNER - Need to check for previous winner? |
                          +---------------------------------------------+*/
                        retval = CASH_WINNER;
                        if ( p_bon02->multi_winners_allowed[0] != 'Y' )
                        {
                           /* Cardholder is not allowed to win this
                            * program more than once. Check for a
                            * previous win by this cardholder.
                            */
                           retval = db_select_bon03( p_auth_tx->TLF01_details.card_num,
                                                     p_bon02->cash_id );

                           if ( retval == PTEMSG_NOT_FOUND )
                           {
                              /* Cardholder has not won this program yet. */
                              retval = CASH_WINNER;
                           }
                           else
                           {
                              /* Cardholder has won this program previously.
                               * Not allowed to win more than once. Too bad!
                               * Reset the transaction counter so someone
                               * else can win.
                               */
                              tran_ctr--;
                              retval = NO_CASH_WINNER;
                           }
                        }

                        if ( retval == CASH_WINNER )
                        {
                           /*+-------------------------------------+
                             |   WE  HAVE  A  REAL  WINNER !!!!!!  |
                             +-------------------------------------+*/

                           p_auth_tx->TLF01_details.cash_bonus[0] = 'Y';

                           memcpy( p_auth_tx->TLF01_details.response_text,
                                   p_bon02->amount_range[amt_idx].resp_text,
                                   40 );

                           if(p_bon02->amount_range[amt_idx].win_type[0] == 'P')
                           {
                              /* Store Peso amount in reward amount. */
                              sprintf( p_auth_tx->BON01_details.maximum_reward,
                                      "%012.0f", tran_amt*100.0 );
                           }
                           else
                           {
                              strcpy( p_auth_tx->BON01_details.maximum_reward,
                                      p_bon02->amount_range[amt_idx].reward_amount );
                           }

                           /* Update the counters. */
                           tran_ctr = 0;

                           sprintf( p_bon02->period_win_ctr,  "%d", period_winners_ctr +1 );
                           sprintf( p_bon02->program_win_ctr, "%d", program_winners_ctr+1 );

                           TxUtils_Send_Msg_To_Operator(1, 
                                                        p_bon02->amount_range[amt_idx].resp_text,
                                                        1, INFO_MSG,
                                                       "perform_cash_bonus_processing",
                                                        0, INFO_ERROR,
                                                        p_auth_tx->TLF01_details.terminal_id,
                                                        p_auth_tx->TLF01_details.card_num, 
                                                        p_auth_tx->TLF01_details.merchant_id);
                        }
                     }
                  }
               }
            }
         }

         if ( tran_ctr > 9999999 )
            tran_ctr = 0;
      }

      sprintf( p_bon02->tran_ctr, "%d", tran_ctr );
   }
   return( retval );
}


/******************************************************************************
 *
 *  NAME:         STRING_REVERSE
 *
 *  DESCRIPTION:  This function reverses the order of characters within a
 *                string.  Similar to the non-ANSI function strrev.  Max
 *                length of string allowed here is 200 bytes.
 *
 *  INPUTS:       instr - string to be reversed.
 *
 *  OUTPUTS:      None
 *
 *  RTRN VALUE:   outstr - string with characters in reverse of instr
 *
 *  AUTHOR:       Dennis Irby
 *
 ******************************************************************************/
pCHAR string_reverse( pCHAR instr )
{
   INT   i;
   INT   len;
   CHAR  outstr[200]="";
   pCHAR p_str = NULL;

   len = strlen( instr );
   if ( len <= 200 )
   {
      p_str = instr+len-1;
      for( i=0; i<len; i++ )
      {
         outstr[i] = *p_str;
         p_str--;
      }
      p_str = outstr;
   }
   else
   {
      p_str = instr;
   }
   return( p_str );
}

/******************************************************************************
 *
 *  NAME:         GET_DATE
 *
 *  DESCRIPTION:  This procedure takes an input string that contains a date and
 *                time.  It copies the date portion into an output string,
 *                formatted slightly different.
 *
 *  INPUTS:       time_date : Format = "YYYY-0M-0D-0H.0I.0S.JJJ"
 *
 *  OUTPUTS:      date_str  : Format = "YYYY0M0D"
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Dennis Irby
 *
 ******************************************************************************/
void get_date( pCHAR time_date, pCHAR date_str )
{
   memset ( date_str,  0x00,         9 );
   strncpy( date_str,  time_date,    4 );
   strncat( date_str, &time_date[5], 2 );
   strncat( date_str, &time_date[8], 2 );
}

/*****************************************************************************

  Function:   hex_to_int

  Description:
      This function will deocde the hex characters into an integer.
  Author: 
      unknown
  Inputs:
      buf_ptr  - pointer to the ascii hex digits ('0' to '9', 'A' to 'F').
                 this buffer is not assumed, nor expected, to be a null
                 terminated string.
      buf_len  - number of digits in the buffer.
  Outputs:
      None
  Return values:
      INT   -  the integer decode result.
******************************************************************************/
INT hex_to_int (pCHAR buf_ptr, INT buf_len  )
{
   INT     index;
   INT     n = 0;

   for (index = 0; index < buf_len; index++, buf_ptr++) 
   {
      if (*buf_ptr >= '0'  &&  *buf_ptr <= '9')
         n = (n * 16) + ((INT) (*buf_ptr - '0'));

      else if (*buf_ptr >= 'A'  &&  *buf_ptr <= 'F')
         n = (n * 16) + ((INT) (*buf_ptr - 'A') + 10);

      else if (*buf_ptr >= 'a'  &&  *buf_ptr <= 'f')
         n = (n * 16) + ((INT) (*buf_ptr - 'A') + 10);

      else
         return (-1);  /* error*/
   } /* end of for*/

  return( n );
} /* genutil_hex_to_int */


/******************************************************************************
 *
 *  NAME:         CREATE_BON03_RECORD
 *
 *  DESCRIPTION:  This function uses transaction data and Cash Bonus
 *                program data to populate a BON03 record.
 *
 *  INPUTS:       p_auth_tx - Transaction information
 *                p_bon02   - Cash Bonus program information
 *
 *  OUTPUTS:      p_bon03   - Record to be inserted into BON03
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Dennis Irby
 *
 ******************************************************************************/
void create_bon03_record( pAUTH_TX p_auth_tx, pBON02 p_bon02, pBON03 p_bon03 )
{
   strcpy( p_bon03->transaction_id,     p_auth_tx->TLF01_details.primary_key.transaction_id );
   strcpy( p_bon03->cash_id,            p_bon02->cash_id );
   strcpy( p_bon03->tag_id,             p_bon02->tag_id  );
   strcpy( p_bon03->program_start_date, p_bon02->program_start_date );
   strcpy( p_bon03->program_end_date,   p_bon02->program_end_date   );
   strcpy( p_bon03->card_nbr,           p_auth_tx->TLF01_details.card_num    );
   strcpy( p_bon03->merchant_id,        p_auth_tx->TLF01_details.merchant_id );
   strcpy( p_bon03->terminal_id,        p_auth_tx->TLF01_details.terminal_id );
   strcpy( p_bon03->auth_number,        p_auth_tx->TLF01_details.auth_number );
   strcpy( p_bon03->tran_date,          p_auth_tx->TLF01_details.date_yyyymmdd );
   strcpy( p_bon03->tran_time,          p_auth_tx->TLF01_details.time_hhmmss   );
   strcpy( p_bon03->tran_amount,        p_auth_tx->TLF01_details.total_amount  );
   strcpy( p_bon03->resp_text,          p_auth_tx->TLF01_details.response_text );
   strcpy( p_bon03->invoice_number,     p_auth_tx->TLF01_details.invoice_number);
   strcpy( p_bon03->retrieval_ref_num,  p_auth_tx->TLF01_details.retrieval_ref_num);
   strcpy( p_bon03->card_holder_name,   p_auth_tx->TLF01_details.card_holder_name );
   strcpy( p_bon03->reward_amount,      p_auth_tx->BON01_details.maximum_reward   );
   return;
}


/******************************************************************************
 *
 *  NAME:         get_cash_bonus_ini_info
 *
 *  DESCRIPTION:  This function reads information from the TF.ini file.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      CashBonusNonWinnerMsg - (Global)
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Dennis Irby
 *
 ******************************************************************************/
void get_cash_bonus_ini_info()
{
   INT   ret_code;
   CHAR  sectionname  [MAX_APP_NAME_SIZE] = "";
   CHAR  filename     [MAX_APP_NAME_SIZE] = "";
   CHAR  tmpstr       [MAX_APP_NAME_SIZE] = "";
   CHAR  message      [MAX_APP_NAME_SIZE] = "";
   CHAR  default_msg[] = "Thank You for using your Equitable Card";


   /* Determine directory and filename of the .ini file. */
   memset( tmpstr, 0x00, MAX_APP_NAME_SIZE );
   GetPinnacleConfigDirectory(tmpstr);
   sprintf(filename, "%stf.ini", tmpstr);

   /* Get the message to send to the terminal for non-winners. */
   strcpy( sectionname, "CASH_BONUS" );
   ret_code = GetPrivateProfileString(
                   sectionname,               /* points to section name       */
                  "NON_WINNER_MSG",           /* points to key name           */
                   default_msg,               /* points to default string     */
                   message,                   /* points to destination buffer */
                   sizeof(message) - 1,       /* size of destination buffer   */
                   filename                   /* points to ini filename       */
            );

   if ( message[0] == 0x00 )
      strcpy( CashBonusNonWinnerMsg, default_msg );
   else
      strcpy( CashBonusNonWinnerMsg, message );
   return;
}








/* Do not remove the following lines. These are the Custom build settings for the Pro C pre-compiler */
/*proc $(ProjDir)\$(InputName).pc dbms=native sqlcheck=semantics userid=atp/atp@atp include=$(ProjDir)\..\..\include*/
/*$(ProjDir)\$(InputName).c*/

