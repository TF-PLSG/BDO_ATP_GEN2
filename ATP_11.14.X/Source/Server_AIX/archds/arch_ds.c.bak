/******************************************************************************

   Module: archds.c

   Title: Archive Server Dataserver Routines

   Description: 

   $Log:   N:\POS\PVCS6.6\EPICPORTZ\PTE\Equitable\archds\arch_ds.c  $1025

 
******************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <sys/timeb.h>
#include <signal.h>

#include "basictyp.h"
#include "pte.h"
#include "pteipc.h"
#include "ptemsg.h"
#include "ptestats.h"
#include "ptesystm.h"
#include "ptetimer.h"
#include "ptetime.h"
#include "ntutils.h"
#include "logger.h"

#include "dbcommon.h"
#include "arch_database.h"
#include "dc_dbstruct.h"
#include "dc_database.h"
#include "memmnger.h"
#include "dstimer.h"
#include "txutils.h"
#include "timings.h"

#include "archds.h"

PRIVATE BYTE         MsgSubtype2;
PRIVATE BYTE         MsgSubtype1;
PRIVATE BYTE         result_code;
PRIVATE BOOLEAN      updates_to_db_made = false;
PRIVATE CHAR         ErrorMsg  [100];
        CHAR         AppName   [MAX_APP_NAME_SIZE];
PRIVATE CHAR         last_trid [MAX_TRAN_ID_SIZE];
PRIVATE pCHAR        reply_que;
PRIVATE CHAR         orig_comm_inf[MAX_ORIG_INFO_SIZE];
PRIVATE CHECKPOINT   checkpoint_rec;
PRIVATE CHAR         AtpBuffer[65000];
PRIVATE BYTE         app_data_type;
PRIVATE CHAR         applnk_que_name[8]="applnkA";

BOOLEAN   in_refeed_mode    = false;
CHAR      Version[] = "ATP_5.18.0";   //TF veena version update    

INT ds_timer_flag;
INT ds_timer_value;

PRIVATE union
{
  
   TLF01_GUI_LIST      Tlf01_Gui_List;
   BCH01_GUI_LIST	   Bch01_Gui_List;
   BCH10_GUI_LIST	   Bch10_Gui_List;
   BCH11_GUI_LIST	   Bch11_Gui_List;
   BCH20_GUI_LIST	   Bch20_Gui_List;
   MCF01_REPORT_LIST   Mcf01_Gui_List;
   CCF01_REPORT_LIST   Ccf01_Gui_List;
   PAF01_REPORT_LIST   Paf01_Gui_List;
   FGUARD_GUI_LIST     Fguard_Gui_List;

   
}db_lists;


PRIVATE struct
{
   TLF01    tlf01;
   FGUARD   fguard;
   EMV_RAW  emvraw;
   FG_RAW   fgraw;

} db_recs;

extern int volatile EndProcessSignalled;
extern int volatile MainProcessDone;
extern CHAR ServiceName[]; //TF PHANI
void TrapFunction( INT signum );

BYTE db_get_tlf01_gui_list_dynamic_new (pTLF01_LIMITS    Tlf01_ptr, 
                                        pTLF01_GUI_LIST  Tlf01_Gui_List,
                                        pCHAR            ErrorMsg );

BYTE db_get_fguard_gui_list_dynamic( pTLF01_LIMITS    Tlf01_ptr,
                                     pFGUARD_GUI_LIST Fguard_Gui_List,
                                     BYTE             subtype2,
                                     pCHAR            ErrorMsg );

BYTE db_get_tlf01_stip_gui_list_for_standin (pTLF01_LIMITS    Tlf01_ptr,        // ThoughtFocus Girija Y
                                        pTLF01_GUI_LIST  Tlf01_Gui_List,
                                        pCHAR            ErrorMsg );
INT  does_process_exist( pCHAR appname, pINT pid );

/* Database Timing Measurements */
TIMINGS_LIST  TimingStats;
INT           DB_Timing_Flag; /* True = Do DB Timing Stats, False = don't do */
INT           ForceReport;
double        NextReportTime;
CHAR          ReportTime[5];


#ifdef _DEBUG
   #define PRINT( X ) printf( X )
#else
   #define PRINT( X )
#endif


/*
 * These defines control whether the dataserver is using logger-reply
 * and whether it should be doing checkpointing.
 *
 * Possible combinations:
 *    a) using logger-reply with checkpoints
 *    b) using logger-reply without checkpoints
 *    c) using neither.
 *
 * note: cannot use checkpoints without logger-reply!!!!!
 *
 */ 
// 12-07-98 gabriel
//#define USING_LOGGER_REPLY
//#define USING_CHECKPOINTS

#ifndef USING_LOGGER_REPLY
   #undef USING_CHECKPOINTS
#endif


/*************************************************************************************/
/*************************************************************************************/
BOOLEAN perform_startup ()
{
   CHAR     XipcInstanceName[12];
   INT      ret_val;
   INT      instance_exists = false;
   INT      queues_exist    = false;
   INT      continue_with_startup = true;
   INT      pid=0;
   CHAR     Buffer[300] = "";

   memset (last_trid, 0, sizeof(last_trid));

   /* Try to initialise the xipc stuff */
   GetAppName          (AppName);
   GetXipcInstanceName (XipcInstanceName);

      /* Try to connect to the database */
      if (dbcommon_connect ("equitable", "equitable", "equitable", "ORCL", ErrorMsg) != PTEMSG_OK)
      {printf   ( "%s", ErrorMsg );
         TxUtils_Send_Msg_To_Operator(1, ErrorMsg, 1, ERROR_MSG,
                                     "perform_startup", 4, FATAL_ERROR,
                                      NULL_PTR, NULL_PTR, NULL_PTR);
         return (false);
      }
      printf ("Connected to ORACLE\n");

      #ifndef WIN32

         /* Diagnostic code to trap the following signals. */
         sigset( SIGALRM, TrapFunction );
         sigset( SIGBUS,  TrapFunction );
         sigset( SIGEMT,  TrapFunction );
         sigset( SIGFPE,  TrapFunction );
         sigset( SIGILL,  TrapFunction );
         sigset( SIGIOT,  TrapFunction );
         sigset( SIGKILL, TrapFunction );
         sigset( SIGPIPE, TrapFunction );
         sigset( SIGPOLL, TrapFunction );
         sigset( SIGPWR,  TrapFunction );
         sigset( SIGQUIT, TrapFunction );
         sigset( SIGSEGV, TrapFunction );
         sigset( SIGSYS,  TrapFunction );
         sigset( SIGTRAP, TrapFunction );
         sigset( SIGUSR1, TrapFunction );
         sigset( SIGUSR2, TrapFunction );

      #endif

     
#ifdef _DEBUG   
   if (pteipc_init_single_instance_app (AppName, XipcInstanceName) == false)
#else
   if( !pteipc_init_multiple_instance_app( AppName, ServiceName, XipcInstanceName ) )
#endif
      {     
         TxUtils_Send_Msg_To_Operator(1, "Failed to create XIPC queues", 1,
                                      ERROR_MSG, "perform_startup", 4,
                                      FATAL_ERROR, NULL_PTR, NULL_PTR,NULL_PTR);
#ifdef _DEBUG
      pteipc_shutdown_single_instance_app(); 
#else
      pteipc_shutdown_multiple_instance_app();
#endif
         dbcommon_disconnect (ErrorMsg);
         return (false);
      }

      #ifdef USING_LOGGER_REPLY

         /* send restart command to TFLogger */
         if (SendRestartCmd (ErrorMsg) == false)
         {
            TxUtils_Send_Msg_To_Operator(1,
                                    "Error sending restart command to TFLogger",
                                     1, ERROR_MSG, "perform_startup", 3,
                                     INFO_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);

            dstimer_shutdown ();
#ifdef _DEBUG
      pteipc_shutdown_single_instance_app(); 
#else
      pteipc_shutdown_multiple_instance_app();
#endif
            dbcommon_disconnect (ErrorMsg);
            return (false);
         }

         #ifdef USING_CHECKPOINTS

            /* get the checkpoint record from the database */
            if (dbcommon_select_checkpoint (AppName, &checkpoint_rec, ErrorMsg) != PTEMSG_OK)
            {
               TxUtils_Send_Msg_To_Operator(1, ErrorMsg, 1, ERROR_MSG,
                                           "perform_startup", 2, INFO_ERROR,
                                            NULL_PTR, NULL_PTR, NULL_PTR);

               dstimer_shutdown ();
#ifdef _DEBUG
      pteipc_shutdown_single_instance_app(); 
#else
      pteipc_shutdown_multiple_instance_app();
#endif
               dbcommon_disconnect (ErrorMsg);
               return (false);
            }

            /* 
             * refeed from my last known trid.
             */
            strncpy (last_trid, checkpoint_rec.checkpoint_trid, sizeof(last_trid));

            if (perform_refeed (checkpoint_rec.checkpoint_trid) == false)
            {
               dstimer_shutdown ();
#ifdef _DEBUG
      pteipc_shutdown_single_instance_app(); 
#else
      pteipc_shutdown_multiple_instance_app();
#endif
               dbcommon_disconnect (ErrorMsg);
               return (false);
            }
         #endif
      #endif

      ret_val = get_dataserver_ini_timer_value( &ds_timer_flag, &ds_timer_value,
                                                AppName,         Buffer );
      if ( false == ret_val )
      {
         LogEvent( Buffer, WARN_MSG );
      }
      else if ( ds_timer_flag == DS_TIMER_ON )
      {
         sprintf( Buffer,
                 "%s:Data Server timing of queries is turned on, value is %d",
                  AppName, ds_timer_value );
         LogEvent( Buffer, INFO_MSG );
      }

   /* Get Database Timing Parameters to gather statistics about each query. */
   memset( ReportTime, 0x00, sizeof(ReportTime) );
   memset( Buffer,     0x00, sizeof(Buffer)     );
   ret_val = get_timing_parameters( &DB_Timing_Flag, ReportTime, &ForceReport, Buffer );
   LogEvent( Buffer, INFO_MSG );

   /* Get the time for when the DB Timing Statistical Report is to be logged. */
   if ( DB_Timing_Flag == true )
   {
      reset_timing_stats( &TimingStats );
      NextReportTime = set_next_report_time_at_startup( ReportTime );
   }

   ret_val = CreateSQL01_Table();
   if ( ret_val < 0 )
   {
      sprintf(Buffer, "Unable to create SQL01 in memory. Xipc err %d", ret_val);
      LogEvent( Buffer, WARN_MSG );
   }

   return( true );
}
      
/*************************************************************************************/
/*************************************************************************************/
pPTE_MSG process_get_gui_list_msg( pPTE_MSG p_msg_in )
{
   BYTE           subtype2;
   LONG           data_len;
   pBYTE          p_data;
   pPTE_MSG_DATA  p_msg_data;
   pPTE_MSG       p_msg_out;
   pBYTE          p_current;


   p_msg_out     = NULL_PTR;
   p_msg_data    = ptemsg_get_pte_msg_data( p_msg_in );
   p_data        = ptemsg_get_pte_msg_data_data( p_msg_data );

   memcpy( AtpBuffer, p_data, sizeof(AUTH_TX) );

   p_current     = AtpBuffer + sizeof(AUTH_TX);
   data_len      = ptemsg_get_pte_msg_data_data_length( p_msg_data );
   app_data_type = ptemsg_get_pte_msg_data_app_data_type( p_msg_data );
   p_data        = p_data + sizeof(AUTH_TX);

   switch( app_data_type )
   {
      case ARCH01_DATA:
		 if( ptemsg_get_msg_subtype2 (p_msg_in) == TLF01_DATA )
		 {
			 PRINT( "request to retrieve tlf01 gui list\n" );
			 if( ( result_code = db_get_tlf01_gui_list_dynamic_new( (pTLF01_LIMITS)p_data, &db_lists.Tlf01_Gui_List, ErrorMsg ) ) == PTEMSG_OK )
			 {
				 memcpy(p_current, (BYTE *)&db_lists.Tlf01_Gui_List, sizeof( db_lists.Tlf01_Gui_List ));
				 p_msg_out = ptemsg_build_msg( MT_DB_REPLY,
					 ptemsg_get_msg_subtype1 (p_msg_in),
					 ptemsg_get_msg_subtype2 (p_msg_in),
					 reply_que,
					 application_que_name,
					 (pBYTE)AtpBuffer,
					 sizeof(AUTH_TX) + sizeof(db_lists.Tlf01_Gui_List),
					 ARCH01_DATA);
				 
			 }
		 }
		 else if( ptemsg_get_msg_subtype2 (p_msg_in) == BCH01_DATA )
		 {
		 	if( ( result_code = db_get_bch01_gui_list( (pBCH01) p_data, &db_lists.Bch01_Gui_List, ErrorMsg) ) == PTEMSG_OK )
	 		{
	 			memcpy(p_current, (BYTE *)&db_lists.Bch01_Gui_List, sizeof( db_lists.Bch01_Gui_List ));
				 p_msg_out = ptemsg_build_msg( MT_DB_REPLY,
					 ptemsg_get_msg_subtype1 (p_msg_in),
					 ptemsg_get_msg_subtype2 (p_msg_in),
					 reply_que,
					 application_que_name,
					 (pBYTE)AtpBuffer,
					 sizeof(AUTH_TX) + sizeof(db_lists.Bch01_Gui_List),
					 ARCH01_DATA);
				 
	 		}
		 }
         else if( ptemsg_get_msg_subtype2 (p_msg_in) == BCH11_DATA )
		 {
		 	if( ( result_code = db_get_bch11_gui_list( (pBCH01) p_data, &db_lists.Bch11_Gui_List, ErrorMsg) ) == PTEMSG_OK )
	 		{
	 			memcpy(p_current, (BYTE *)&db_lists.Bch11_Gui_List, sizeof( db_lists.Bch11_Gui_List ));
				 p_msg_out = ptemsg_build_msg( MT_DB_REPLY,
					 ptemsg_get_msg_subtype1 (p_msg_in),
					 ptemsg_get_msg_subtype2 (p_msg_in),
					 reply_que,
					 application_que_name,
					 (pBYTE)AtpBuffer,
					 sizeof(AUTH_TX) + sizeof(db_lists.Bch11_Gui_List),
					 ARCH01_DATA);
				 
	 		}
		 }
         else if( ptemsg_get_msg_subtype2 (p_msg_in) == BCH20_DATA )
		 {
		 	if( ( result_code = db_get_bch20_gui_list( (pBCH01) p_data, &db_lists.Bch20_Gui_List, ErrorMsg) ) == PTEMSG_OK )
	 		{
	 			memcpy(p_current, (BYTE *)&db_lists.Bch20_Gui_List, sizeof( db_lists.Bch20_Gui_List ));
				 p_msg_out = ptemsg_build_msg( MT_DB_REPLY,
					 ptemsg_get_msg_subtype1 (p_msg_in),
					 ptemsg_get_msg_subtype2 (p_msg_in),
					 reply_que,
					 application_que_name,
					 (pBYTE)AtpBuffer,
					 sizeof(AUTH_TX) + sizeof(db_lists.Bch20_Gui_List),
					 ARCH01_DATA);
				 
	 		}
		 }
		 else
		 {
		 	result_code = PTEMSG_INVALID_DATATYPE;
         	sprintf (ErrorMsg, "Unknown msg subtype %d for GetList request from %s", ptemsg_get_msg_subtype2 (p_msg_in), reply_que);
		 }
         break;


      default:

         // unknown app_data_type received. Log Event and return error message to client
         result_code = PTEMSG_INVALID_DATATYPE;
         sprintf (ErrorMsg, "Unknown datatype for GetList request from %s", reply_que);
         break;
   }


   if ((result_code == PTEMSG_OK) && (p_msg_out == NULL_PTR) )
   {
      result_code = PTEMSG_INSUFFICIENT_MEMORY;
      sprintf (ErrorMsg, "Insufficient Memory to build GetAll response to %s", reply_que);
   }

   return (p_msg_out);
}
/*************************************************************************************/
/*************************************************************************************/
pPTE_MSG process_select_msg( pPTE_MSG p_msg_in )
{
   pBYTE          p_data;
   pPTE_MSG_DATA  p_msg_data;
   pPTE_MSG       p_msg_out;
   CHAR           temp[150];
   pBYTE          p_current;
   pAUTH_TX       auth_tx;

   p_msg_out     = NULL_PTR;
   p_msg_data    = ptemsg_get_pte_msg_data( p_msg_in );
   p_data        = ptemsg_get_pte_msg_data_data( p_msg_data );
   memcpy(AtpBuffer, p_data, sizeof(AUTH_TX));
   p_current     = AtpBuffer + sizeof(AUTH_TX);
   app_data_type = ptemsg_get_pte_msg_data_app_data_type( p_msg_data );
   
   auth_tx = (pAUTH_TX)p_data;
   p_data = p_data + sizeof(AUTH_TX);
   switch( app_data_type )
   {
      case ARCH01_DATA:
         PRINT( "request to retrieve tlf01 record\n" );
         PRINT("\n");
         if(ptemsg_get_msg_subtype2 (p_msg_in) ==  TLF01_DATA)
         {
            if ( ( result_code = db_select_tlf01( ( pCHAR)p_data, &db_recs.tlf01, ErrorMsg ) ) == PTEMSG_OK )             
            {
            	/* continue to look for EMV data -  don't care success or not.
            	 * if fail, db_recs.emvraw will be all ZEROs.
            	 */
            	//db_select_emvraw( ( pCHAR)p_data, &db_recs.emvraw, ErrorMsg );
            	memset((BYTE *)&db_recs.emvraw, 0, sizeof( db_recs.emvraw ));

            	memcpy(p_current, (BYTE *)&db_recs.tlf01, sizeof( db_recs.tlf01 ));

				p_current = p_current + sizeof( db_recs.tlf01 );
				memcpy(p_current, (BYTE *)&db_recs.emvraw, sizeof( db_recs.emvraw ));
               
            	p_msg_out = ptemsg_build_msg( MT_DB_REPLY,
                                          ptemsg_get_msg_subtype1 (p_msg_in),
                                          ptemsg_get_msg_subtype2 (p_msg_in),
                                          reply_que,
                                          application_que_name,
                                          (pBYTE)AtpBuffer,
                                          sizeof(AUTH_TX) + sizeof(db_recs.tlf01) + sizeof( db_recs.emvraw ),
                                          ARCH01_DATA);

            	sprintf(temp, "TLF01 transaction_id : %s\n", db_recs.tlf01.primary_key.transaction_id);
            	PRINT(temp);
            }
         }
         break;

      default:

         /* unknown app_data_type received. Log Event and return error message to client */
         result_code = PTEMSG_INVALID_DATATYPE;
         sprintf (ErrorMsg, "Unknown app_data_type for Select request from %s", reply_que);
         break;

   }


   if ((result_code == PTEMSG_OK) && (p_msg_out == NULL_PTR) )
   {
      result_code = PTEMSG_INSUFFICIENT_MEMORY;
      sprintf (ErrorMsg, "Insufficient Memory to build Select response to %s", reply_que);
   }

   return (p_msg_out);
}

/*************************************************************************************/
/*************************************************************************************/
pPTE_MSG process_db_request ( pPTE_MSG p_msg_in )
{
   pPTE_MSG       p_msg_out;
   CHAR           query_start_time[20]="";
   CHAR           query_end_time  [20]="";
   CHAR           errbuf[120];
   INT            ret_val;
   double         start_time;
   double         end_time;
   double         duration;
  
   MsgSubtype2 = ptemsg_get_msg_subtype2 (p_msg_in);
   MsgSubtype1 = ptemsg_get_msg_subtype1(p_msg_in);

   memset(AtpBuffer, 0, sizeof(AtpBuffer));
   if ( ds_timer_flag == DS_TIMER_ON )
   {
      /* The functionality to check the time of a query is turned on.
       * Get the time before the query. Will check it after the query.
       */
      ptetime_get_strtime( query_start_time );
   }

   if ( DB_Timing_Flag == true )
   {
      /* The functionality to gather DB Query Timing Statistics is ON.
       * Get system time, then do again after the query.  This is
       * different than the above timings.  That one flags long queries;
       * this one gather stats.
       */
      start_time = ptetime_get_time();
   }

   switch (ptemsg_get_msg_subtype1 (p_msg_in))
   {

    case ST1_DB_GET_GUI_LIST      : p_msg_out = process_get_gui_list_msg (p_msg_in);
                                      break;
    case ST1_DB_SELECT            : p_msg_out = process_select_msg       (p_msg_in);
                                      break;

      /*case ST1_DELETE_BY_DATE       : p_msg_out = process_db_cleanup       (p_msg_in);
                                      break;*/
      default:
         p_msg_out   = NULL_PTR;
         result_code = PTEMSG_INVALID_SUBTYPE1;
         sprintf (ErrorMsg, "Unknown subtype1 for database request from %s", reply_que);
         break;
   }

   if ( DB_Timing_Flag == true )
   {
      /* The functionality to gather DB Query Timing Statistics is ON.
       * Start time has been obtained. Now get end time and calculate
       * the duration and update the statistics.
       */
      end_time = ptetime_get_time();

      duration = end_time - start_time;

      update_timing_stats( MsgSubtype1, MsgSubtype2, app_data_type,
                           (float)duration, &TimingStats );
   }

   if ( ds_timer_flag == DS_TIMER_ON )
   {
      /* The functionality to check the time of a query is turned on.
       * See if the query exceeded desired time length.
       */
      ptetime_get_strtime( query_end_time );
      memset( errbuf, 0x00, sizeof(errbuf) );
      ret_val = compare_query_time_against_criteria( query_start_time,
                                                     query_end_time,
                                                     ds_timer_value,
                                                     p_msg_in,
                                                     AppName,
                                                     errbuf );
      if ( ret_val == false )
      {
         /* The query exceeded the time criteria.  Log informational message. */
         LogEvent( errbuf, INFO_MSG );
      }
   }
   return (p_msg_out);
}

/*************************************************************************************/
/*************************************************************************************/
BYTE PinnacleMsgHandler ( pPTE_MSG p_msg_in )
{
   LONG        i;
   LONG        num_messages;
   LONG        ipc_rcode;
   CHAR        temp_str [80];
   pPTE_MSG    p_cur_msg;
   pPTE_MSG    p_tmp_msg;
   pPTE_MSG    p_chn_out;
   pPTE_MSG    p_new_chn;
   pBYTE       p_data;
   pPTE_MSG_DATA  p_msg_data;
   INT            ret_val;
   INT            num_sql;
   int         refresh_flag = 0;  // If an error in update_mem_record or delete_mem_record,
                              // delete all recs. in mem and recreate all tables over again 
                              // from the database.

   #ifdef USING_CHECKPOINTS
      pCHAR       p_msg_trid;
   #endif


   ptestats_accumulate_msg_stats (p_msg_in);

   result_code = PTEMSG_OK;

   #ifdef USING_CHECKPOINTS
      if ( (result_code = validate_last_trid (p_msg_in)) != PTEMSG_OK )
         return (result_code);
   #endif

   p_cur_msg    = p_msg_in;
   p_tmp_msg    = NULL_PTR;
   p_chn_out    = NULL_PTR;
   i            = 1;
   num_messages = ptemsg_get_num_chained_messages (p_msg_in);
   /* Added for UpdateMemRecord stuff */
   p_msg_data    = ptemsg_get_pte_msg_data( p_msg_in );
   p_data        = ptemsg_get_pte_msg_data_data( p_msg_data );
   app_data_type = ptemsg_get_pte_msg_data_app_data_type( p_msg_data );
   //p_data = p_data + sizeof(AUTH_TX);
  
   while ( (i <= num_messages) && (p_cur_msg != NULL_PTR) )
   {
      reply_que = ptemsg_get_msg_orig_queue (p_cur_msg);
      strcpy(orig_comm_inf, ptemsg_get_msg_orig_comms_info( p_cur_msg ));
      app_data_type = 0;
    
      switch( ptemsg_get_msg_type( p_cur_msg ) )
      {
         case MT_TIMER_REQUEST  : p_tmp_msg = dstimer_process_request (p_cur_msg,
                                                                       &updates_to_db_made);       
                                  break;            
         case MT_SYSTEM_REQUEST : ptesystm_system_msg_handler (p_cur_msg);
                                  if ( ST1_SYS_PING == ptemsg_get_msg_subtype1(p_msg_in) )
                                  {
                                     if ( ST2_NO_VERSION != ptemsg_get_msg_subtype2(p_msg_in) )
                                     {
                                        /* When pinged, display application version on Monitor. */
                                        sprintf( temp_str,
                                                "Pinged -> Data Server: %s, version %s",
                                                 AppName, Version );
                                        TxUtils_Send_Msg_To_Operator( 1, temp_str, 1, INFO_MSG,
                                                                     "PinnacleMsgHandler",
                                                                      0, INFO_ERROR, 0, 0, 0 );

                                        /* Get Database Timing Parameters to gather
                                         * statistics about each query.
                                         */
                                        memset( ReportTime, 0x00, sizeof(ReportTime) );
                                        memset( temp_str,   0x00, sizeof(temp_str)   );
                                        ret_val = get_timing_parameters( &DB_Timing_Flag,
                                                                          ReportTime, 
                                                                         &ForceReport,
                                                                          temp_str );
                                        LogEvent( temp_str, INFO_MSG );

                                        if ( DB_Timing_Flag == true )
                                        {
                                           /* Get the time for when the DB Timing
                                            * Statistical Report is to be logged.
                                            */
                                           NextReportTime = set_next_report_time_at_startup( ReportTime );

                                           if ( ForceReport == true )
                                           {
                                              /* User wants to log the stats
                                               * right now.  Log them then
                                               * reset the statistics.
                                               */
                                              num_sql = log_timing_statistics_report( &TimingStats );
                                              memset( temp_str, 0x00, sizeof(temp_str) );
                                              sprintf( temp_str,
                                                      "%s logged stats for %d SQLs",
                                                       AppName, num_sql );
                                              LogEvent( temp_str, INFO_MSG );

                                              reset_timing_stats( &TimingStats );
                                           }
                                        }
                                     }
                                  }
                                  break;

         case MT_DB_REQUEST     : p_tmp_msg = process_db_request (p_cur_msg);
                                  break;

         default :
            /*
             * Received an unknown msg type.  If the request was destined for
             * this dataserver, log an error because I can't process it.
             * Otherwise, try to forward it on to the actual destination.
             */
            if ( (strncmp (ptemsg_get_msg_dest_queue (p_cur_msg),
                           application_que_name, strlen(application_que_name)) == 0) ||
                 (strncmp (ptemsg_get_msg_dest_queue (p_cur_msg),
                           control_que_name,     strlen(control_que_name)    ) == 0)   )
            {
               result_code = PTEMSG_INVALID_MSGTYPE;
               sprintf (ErrorMsg, "Unknown msgtype for request from %s", reply_que);
            }
            else
            {
               /*
                * Forward the request to its destination (if not in refeed mode).
                */
               if (in_refeed_mode == false)
               {
                  sprintf (temp_str, "forwarding message to queue %s\n", 
                           ptemsg_get_msg_dest_queue (p_cur_msg));
                  PRINT (temp_str);

                  ptemsg_set_orig_comms_info( p_cur_msg, orig_comm_inf );
                  ipc_rcode = pteipc_send (p_cur_msg, ptemsg_get_msg_dest_queue (p_cur_msg));

                  if (ipc_rcode < 0)
                  {
                     result_code = PTEMSG_COULD_NOT_FORWARD;
                     pteipc_get_errormsg (ipc_rcode, temp_str);
                     sprintf  (ErrorMsg, "error forwarding to queue %s: %s", 
                               ptemsg_get_msg_dest_queue (p_cur_msg), temp_str);
                  }
               }
            }

            break;
      }  /* switch msg_type */


      if (result_code != PTEMSG_OK)
         break;

      if (p_tmp_msg != NULL_PTR)
      {
         result_code = ptemsg_get_result_code (p_tmp_msg);
         
         if (result_code != PTEMSG_OK)
         {
            free (p_chn_out);
            p_chn_out = p_tmp_msg;
            p_tmp_msg = NULL_PTR;
            break;
         }
         
         if (p_chn_out == NULL_PTR)
         {
            p_chn_out = p_tmp_msg;
            p_tmp_msg = NULL_PTR;
         }
         else
         {
            p_new_chn = ptemsg_chain_message (p_chn_out, p_tmp_msg);

            if (p_new_chn == NULL_PTR)
            {
               result_code = PTEMSG_INSUFFICIENT_MEMORY;
               sprintf  (ErrorMsg, "Insufficient Memory to chain response to %s", reply_que);
               break;
            }
            else
            {
               p_chn_out = p_new_chn;
               p_tmp_msg = NULL_PTR;
            }
         }
      }

      if ((++i) <= num_messages)
         p_cur_msg = ptemsg_get_chained_pte_msg (p_msg_in, i);
   }  /* while */


   /*
    * Be sure to free up the temp message.
    */
   if (p_tmp_msg != NULL_PTR)
   {
      free (p_tmp_msg);
      p_tmp_msg = NULL_PTR;
   }

   #ifdef USING_CHECKPOINTS
      /*
       * Update the checkpoint.
       */
      if (result_code == PTEMSG_OK)
      {
         p_msg_trid = ptemsg_get_current_msg_tran_id (p_msg_in);

         if (p_msg_trid [0] != '\0')
         {
            strncpy (checkpoint_rec.checkpoint_trid, p_msg_trid, sizeof(checkpoint_rec.checkpoint_trid));
            strncpy (last_trid, p_msg_trid, sizeof(last_trid));

            result_code = dbcommon_update_checkpoint (&checkpoint_rec, ErrorMsg);
         }
      }
   #endif

   /*
    * If there was an error, back out the changes.
    * Otherwise commit the changes.
    */
   reply_que = ptemsg_get_msg_orig_queue (p_msg_in);
      
   //}

   if (p_chn_out != NULL_PTR)
   {
      /*
       * If in refeed mode, don't send the response.
       */
      if (in_refeed_mode == true)
         return (PTEMSG_OK);

      /*
       * If the result is OK, don't send the response if they don't want it.
       */
      if ( (result_code                                == PTEMSG_OK                 ) &&
           (ptemsg_get_type_of_reply_needed (p_msg_in) == PTEMSG_REPLY_ONLY_IF_FAILS) )
      {
         free (p_chn_out);
         return (PTEMSG_OK);
      }

      ptemsg_set_result_code (p_chn_out, result_code);
      ptemsg_set_orig_comms_info( p_chn_out, orig_comm_inf );

      /*
       * Send the response.
       */
      ipc_rcode = pteipc_send (p_chn_out, reply_que);

      free (p_chn_out);

      if (ipc_rcode < 0)
      {
         //printf   ("%s\n", ErrorMsg);
         //LogEvent (ErrorMsg, WARN_MSG );
         /*The following function writes the message both to the Sys.Monitor and EventLog */
         TxUtils_Send_Msg_To_Operator(1, ErrorMsg, 1, WARN_MSG, "PinnacleMsgHandler", 2, WARNING_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
         result_code = PTEMSG_IPC_ERROR;
         pteipc_get_errormsg (ipc_rcode, temp_str);
         sprintf (ErrorMsg, "error sending response to %s: %s", reply_que, temp_str);
      }
   }
   //Database errors (ex: select failed) are no more sent to Eventlog
   /*if (result_code != PTEMSG_OK)
   {
      printf   ("%s\n", ErrorMsg);
      LogEvent (ErrorMsg, WARN_MSG );
   }*/

   return (result_code);
}

/*************************************************************************************/
/*************************************************************************************/

#ifndef WIN32

void TrapFunction( INT signum )
{
   CHAR Buffer[100];

   XIPC_TRAP_FUNCTION_TEST( TrapFunction, signum );

   memset( Buffer, 0x00, sizeof(Buffer) );
   sprintf( Buffer, "%s:  Caught signal %d", AppName, signum );
   LogEvent( Buffer, ALERT_MSG );
}

#endif

void MainProcessor()
{
   LONG     ipc_rcode;//, xipc_code;
   pPTE_MSG p_msg;
   CHAR     Buffer[256];
   CHAR     MonAdd[100]="";
   INT      num_sql;
   INT      err_ctr = 0;
   CHAR     strError[512] = {0} ;
   GetAppName( AppName );
   sprintf( Buffer,
           "Starting the Service: %s, version %s",
            AppName, Version );
   LogEvent( Buffer, INFO_MSG );
	printf( "%s\n", Buffer );

   #ifdef _DEBUG
      pteipc_trace_on();
   #endif

   if (perform_startup () == false)
   {
      MainProcessDone = 1;
	  	     sprintf( Buffer,
           "Shutting down the Service: %s, version %s",
            AppName, Version );
		  LogEvent( Buffer, INFO_MSG );
			printf( "%s\n", Buffer );

      return;
   }

   sprintf( Buffer,
           "Starting the Service: %s, version %s",
            AppName, Version );
   LogEvent( Buffer, INFO_MSG );
   printf( "%s\n", Buffer );

   printf( "DataServer is ready. press <ENTER> to exit\n" );

   while( !EndProcessSignalled )
   {
      /* You are blocked here waiting for a message on either app queue or
       * control queue.  If there is no message on either queue for the
       * specified time, the blocking call returns.
       */
      p_msg = pteipc_receive( application_que_name, control_que_name, 
                              TIME_BETWEEN_CHECKS, &ipc_rcode );

      if( p_msg != NULL_PTR )
      {
         err_ctr = 0;
         PinnacleMsgHandler( p_msg );
         free (p_msg);
      }
      else
      {
         if( ipc_rcode != QUE_ER_TIMEOUT ) 
         {
            pteipc_get_errormsg ( ipc_rcode, ErrorMsg );
            sprintf ( Buffer,
                     "Error on pteipc_receive %s, error code: %ld",
                      ErrorMsg, ipc_rcode );
            TxUtils_Send_Msg_To_Operator(1, Buffer, 1, ALERT_MSG,
                                        "MainProcessor", 4, FATAL_ERROR,
                                         NULL_PTR, NULL_PTR, NULL_PTR);


            /* There is a problem with the queue.  Delay 1 second
             * so as to not flood Applnk's queue and syslog.
             */
            #ifdef WIN32
               Sleep( 1000 );
            #else
               usleep( 1000000 );
            #endif

            /* Inform Operators if service's queue is no longer readable. */
            if ( ++err_ctr > 10 )
            {
               err_ctr = 0;
               sprintf( Buffer,
                       "SHUT DOWN %s. UNABLE TO ACCESS QUEUE!!!!",
                        AppName );
               TxUtils_Send_Msg_To_Operator (1, Buffer, 1, ALERT_MSG,
                                            "MainProcessor", 4, FATAL_ERROR,
                                             NULL_PTR, NULL_PTR, NULL_PTR);
               #ifdef WIN32
                  Sleep (5000);
               #else
                  usleep (5000000);
               #endif
            }
         }
         else
         {
            in_refeed_mode = false;

            /* The queue read has timed out.  This means there is no
             * activity for this application.  Take this opportunity
             * to see if it is time to log the database timing stats.
             */
            if ( is_it_report_time(NextReportTime) )
            {
               /* Time to report the DB timing measurement statistics. */
               num_sql = log_timing_statistics_report( &TimingStats );

               memset( Buffer, 0x00, sizeof(Buffer) );
               sprintf( Buffer,
                       "%s logged stats for %d SQLs",
                        AppName, num_sql );
               LogEvent( Buffer, INFO_MSG );

               reset_timing_stats( &TimingStats );
               NextReportTime = set_next_report_time_at_startup( ReportTime );
            }
         }
      }
      dstimer_check_for_timeouts ();
   }

   dstimer_shutdown ();

   /* shut down ipc */
//   pteipc_shutdown_single_instance_app();  /* Changed single to multiple instance - Girija Y ThoughtFocus */
     pteipc_shutdown_multiple_instance_app(); 

   printf ("pteipc shutdown successful\n");

   /* disconnect from database */
   if (dbcommon_disconnect (ErrorMsg) != PTEMSG_OK)
      printf ( "%s\n", ErrorMsg );
   else
      printf ( "Disconnected from ORACLE\n" );

   /* signal that we are ready for shutdown */
   MainProcessDone = 1;
}


/*************************************************************************************/
/*************************************************************************************/
void EndProcess()
{
   CHAR Buffer[100] = "";

   sprintf( Buffer, "Shutting down the %s Service, version %s",
            AppName, Version );
   LogEvent( Buffer, INFO_MSG );
   strcat( Buffer, "\n" );
   PRINT( Buffer );

   pteipc_sleep (3000);
}


#ifndef WIN32

/******************************************************************************
 *
 *  NAME:         DOES_PROCESS_EXIST
 *
 *  DESCRIPTION:  This function determines if this application is already
 *                running.  It does this by checking to see if there are
 *                more than 2 processes running by this name: one for this
 *                process and one for a previous process.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      pid = Process ID of a previous process already running.
 *
 *  RTRN VALUE:   True if there is another process running by the same name
 *
 *  AUTHOR:       Dennis Irby
 *
 ******************************************************************************/
INT does_process_exist( pCHAR appname, pINT pid )
{
   INT    ret_val = false;
   INT    ctr;
   INT    my_pid;
   INT    found_pid;
   FILE  *fptr;
   CHAR   s_pid[9]="";
   CHAR   list_processes[100]="";
   CHAR   get_pid_cmd[200]="";
   CHAR   buffer[200]="";

   /* ----------------------------------------------------------------------- */
   /* Determine if there are multiple process Ids out there for this process. */
   /* ----------------------------------------------------------------------- */

   /* Create Unix command to list all processes for this app. */
   sprintf( list_processes,
           "ps -ef | grep -i %s | grep -v grep",
            appname );

   /* Run the command, creating a file pointer to the output. */
   ctr = 0;
   if ((fptr = popen(list_processes,"r")) != NULL )
   {
      while( fgets(buffer,100,fptr) != NULL )
         ctr++;

      pclose( fptr );
   }

   if ( ctr > 1 )
   {
      /* ------------------------ */
      /* There are multiple PIDs. */
      /* ------------------------ */
      ret_val = true;

      /* There are more than 1 processes for this app.
       * 1.  First get pid of this app.
       * 2.  Get pid of other app.  Return this one.
       */
      my_pid = getpid();

      /* Get PID of app that was already running (assuming just 1 other). */
      sprintf( get_pid_cmd,
              "ps -ef | fgrep %s | fgrep -v grep \
               | awk '{ while( sub(/^[ ]/,\"\") );while (gsub(/[ ]{2,}/,\" \",$0));\
               ;split($0,a,/[ ]/); print a[2] }'",
               appname );

      /* Run the command to get the Process ID. */
      if ((fptr = popen(get_pid_cmd,"r")) != NULL )
      {
         while( fgets(s_pid,8,fptr) != NULL )
         {
            found_pid = atoi( s_pid );

            if ( my_pid != found_pid )
            {
               /* Found it. Let's get out of the loop. */
               *pid = found_pid;
               break;
            }
         }
         pclose( fptr );
      }
   }
   return( ret_val );
}



#endif



/* Do not remove the following lines. These are the Custom build settings for the Pro C pre-compiler */
/*proc $(ProjDir)\$(InputName).pc dbms=native sqlcheck=semantics userid=atp/atp@atp include=$(ProjDir)\..\..\include*/
/*$(ProjDir)\$(InputName).c*/
