/*******************************************************************
*
* Copyright (c) 2006, Hypercom, Inc.
* All Rights Reserved.
*
* MODULE:      amexmain.c
*  
* TITLE:       Main function for the amex network handler      
*  
* DESCRIPTION: This module will handle all incoming messages from
*               the terminal and the host.
*
* APPLICATION: 
*
* AUTHOR:      B Gable
*
* REVISION HISTORY:
*
* $Log:   N:\POS\PVCS6.6\EPICPORTZ\PTE\Equitable\ncamex\amexmain.c  $

	  
   Rev 1.57 Jul 13, 2009 TF-Ajay
	Changed the version to 4.4.1.21. 

	 Rev 1.56 Jul 13, 2009 TF-Ajay
	Changed the version to 4.4.1.20. 

		Rev 1.55 Mar 04, 2009 Girija Y - ThoughtFocus, Bangalore
	Changed the version to 4.4.1.18.Changed the code to pass flds 48 for 1120 msg.

	  Rev 1.54 Feb 24 2009 Girija Y - ThoughtFocus, Bangalore
	Changed the version to 4.4.1.15.changed
	the code to allow queue "ncpos2A".Changed the code for passing response code to host.
	

      Rev 1.53 Oct 06 2008 Girija Y - ThoughtFocus, Bangalore
	Changed the version to 4.4.1.12.changed
	the code to pass required field 53,12,13,45 to cadencie host.
	Rel 08-11-1.
   
	  Rev 1.52   Sep 22 2008 17:16:45   Girija Y ThoughtFocus, Bangalore
   Updated version to 4.4.1.8
   Changed the code to pass field 45 and field 35.
   Rel 08-31

	  Rev 1.51   Sep 12 2008 19:16:45   Girija Y ThoughtFocus, Bangalore
   Updated version to 4.4.1.7
   Changed the code to pass field 44(Address verification) to cadencie host and
   store field 44 from the response (1110 message) and pass to equitable host.
   Rel 08-31

	  Rev 1.50   Sep 05 2008 17:27:54   Girija Y ThoughtFocus, Bangalore
   Updated version to 4.4.1.6
   Changed the code to fix issues for the fields 4,7,12,25,30,50,56 
   to support cadencie link for AMEX.
   Rel 08-11

      Rev 1.49   Feb 28 2006 09:50:54   dirby
   Updated version to 4.4.1.4
   SCR 20104
   
      Rev 1.48   Jan 11 2006 14:58:00   dirby
   Updated version to 4.4.1.3
   SCR 19211
   
      Rev 1.47   Nov 09 2005 16:40:54   dirby
   Updated version to 4.4.1.2
   SCR 17010
   
      Rev 1.46   Apr 05 2005 14:55:38   dirby
   Updated version to 4.4.1.1
   SCR 12785
   
      Rev 1.45   Sep 27 2004 18:17:44   dirby
   Updated version to 4.4.0.2
   
      Rev 1.44   Jul 08 2004 17:31:52   dirby
   Updated to 4.4.0.1
   SCRs 1287 & 1388
   
      Rev 1.43   May 27 2004 17:42:00   dirby
   Updated version to 4.3.0.1
   SCR 1380
   
      Rev 1.42   Jan 16 2004 13:37:08   dirby
   Updated version to 4.2.0.3
   SCR 1200
   
      Rev 1.41   Jan 15 2004 16:40:32   dirby
   Implemented Online Card Updates (1304/1314).
   SCR 1200
   
      Rev 1.40   Feb 19 2003 16:49:30   dirby
   Updated version to 4.2.0.1
   SCR 955
   
      Rev 1.39   Feb 04 2003 16:12:12   dirby
   Updated version to 4.1.1.3
   SCR 1009
   
      Rev 1.38   Nov 12 2002 13:32:08   dirby
   Updated version to 4.1.1.2
   SCR 845
   
      Rev 1.37   Aug 22 2002 12:10:30   dirby
   Updated version to 4.1.1.1
   SCR 255
   
      Rev 1.36   Jul 03 2002 15:32:46   dirby
   Updated version to 4.0.3.1
   Added code to display version when pinged.
   SCR 621
   
      Rev 1.35   Feb 01 2002 11:25:02   dirby
   Updated version to 4.0.2.1
   SCR 525
   
      Rev 1.34   Jan 23 2002 14:11:14   dirby
   1.  Initialized some string arrays in send_transaction_statistics.
        Not initializing them caused ncamex to not know who to 
       respond to.
   2.  Updated version to 4.0.1.2
   SCR 592
   
      Rev 1.33   Jan 16 2002 16:37:14   dirby
   Modified start up to open trace file prior to issuing an auto logon.
   SCR 546
   
      Rev 1.32   Jan 16 2002 15:13:32   dirby
   Added transaction tracing functionality.
   SCR 546
   
      Rev 1.31   Jan 14 2002 18:08:04   dirby
   Modified the transaction statistic functions to keep statistics
   on number of approved, declined, timed out, and reversed
   txns.  These stats are displayed on Monitor.
   SCR 484
   
      Rev 1.30   Dec 12 2001 09:32:42   dirby
   Modified to set host state to DOWN when shutting down.
   Updated version to 4.0.1.1
   SCR 488
   
      Rev 1.29   Nov 03 2001 13:57:08   dirby
   Updated version to 4.0.0.1
   
      Rev 1.28   Mar 02 2001 10:54:36   dirby
   Updated version to 3.2.2.7
   
      Rev 1.27   Feb 06 2001 08:55:20   dirby
   Updated version to 3.2.2.6
   
      Rev 1.26   Jan 26 2001 14:39:06   dirby
   1.  Updated version to 3.2.2.5
   2.  Removed some error processing code that is redundant.
   3.  Removed some obsolete comments.
   4.  Realigned the whole module to stay within 80 columns.
   
      Rev 1.25   Jan 09 2001 13:45:48   dirby
    
   
      Rev 1.24   Sep 07 2000 12:59:54   dirby
   Updated version number to 3.2.2.3
   
      Rev 1.23   Aug 25 2000 13:59:36   dirby
   Removed some error handling code after returning from function
   'incoming_host_message'.  Errors are handled inside that function.
   The code removed would duplicate this error handling and attempt
   to send a second error response to the host.  It also did this with an
   empty auth_tx structure.  This caused unpredictable  and confusing
   errors.
   
      Rev 1.22   Aug 23 2000 12:46:30   dirby
   Added code to support transaction statistics for Monitor.
   
   
      Rev 1.21   Aug 15 2000 15:05:06   dirby
   Added code to get the Issuer record from NCF01 at startup.
   It contains some fields needed for processing.
   
      Rev 1.20   Aug 08 2000 13:36:08   dirby
   Version 3.2.2.1
   
      Rev 1.19   Aug 01 2000 15:21:44   dirby
   Removed a redundant info message.
   Changed a strncpy to strcpy for ncf01.network_id.
   
      Rev 1.18   Jul 30 2000 15:37:00   dirby
   Modified to display version number at startup and shutdown.
   
      Rev 1.17   Apr 10 2000 14:48:02   ddabberu
   Globals Variables si, tpdu_id defined.
   and checks made based on them.
   
   
      Rev 1.16   Mar 16 2000 21:37:46   ddabberu
   modified to support AMEX 99.2 specs
   
      Rev 1.15   Jan 04 2000 14:12:50   ddabberu
   printing appName in the error message
   
      Rev 1.14   Dec 03 1999 14:58:00   svelaga
   corrected the updateds que-name
   
      Rev 1.13   Nov 17 1999 14:21:28   dirby
   Modified code for the following reasons:
   1.  Use Update Data Server for updating non-network tables.
   2.  Implement new reversal strategy.
   
      Rev 1.12   Oct 27 1999 16:25:14   dirby
   Removed an extraneous 'free' under message type MT_SYSTEM_REPLY.
   
      Rev 1.11   Aug 05 1999 14:48:32   egable
   Correct another error.
   
      Rev 1.10   Aug 05 1999 14:45:40   egable
   Correct errors found with new MFC.
   
      Rev 1.9   Jul 29 1999 21:49:22   egable
   Correct an error path.
   
      Rev 1.8   Jul 09 1999 13:47:38   egable
   Send all messages to system log and verify
   that the length of appname isn't too long.
   
      Rev 1.7   19 Apr 1999 09:51:54   dirby
   The result of a Pin Translation printed an error message if it was
   successful.  Changed to display it for pin translation failure.
   
      Rev 1.6   Mar 31 1999 15:31:54   egable
   Allow logoff and echo tests and update the 
   monitor to show offline when shut down.
   
      Rev 1.5   Mar 16 1999 13:06:38   egable
   Changes to debug amex problems
   
      Rev 1.4   Feb 27 1999 16:10:18   egable
   Correct an error in the error processing code.
   
      Rev 1.3   Feb 26 1999 11:36:18   egable
   Correct ncf01 select ('A', not 'I')
   
      Rev 1.2   Feb 26 1999 11:29:54   egable
   Correct error in path where monitor sends
   a log in to host message
   
      Rev 1.1   Feb 25 1999 15:24:50   egable
   On startup, determine if autologon, if it is, send
   a logon message to host.  Also accept logon
   message from monitor.
   
      Rev 1.0   Feb 23 1999 09:17:44   egable
   Initial Release
*
*******************************************************************/

#include <stdlib.h>
#include <stdio.h>

#include "basictyp.h"
#include "pte.h"
#include "ptemsg.h"
#include "pteipc.h"
#include "ptestats.h"
#include "ptesystm.h"
#include "ntutils.h"

#include "app_info.h"
#include "equitdb.h"
#include "nc_dbstruct.h"
#include "amexmain.h"
#include "amexutil.h"
#include "amextran.h"
#include "memmnger.h"
#include "txutils.h"
#include "txtrace.h"
#include "diskio.h"


extern CHAR  ServiceName[12];
extern CHAR  tpdu_id[];

extern INT  volatile EndProcessSignalled;
extern INT  volatile MainProcessDone;

extern CHAR  LOGON_REQUEST[];    
extern CHAR  LOGOFF_REQUEST[];  
extern CHAR  ECHO_REQUEST[]; 


/************************************************
    GLOBAL DECLARATIONS
 ************************************************/

NCF01    ncf01;

CHAR  cur_app_name    [MAX_APP_NAME_SIZE];
CHAR  oprmon_que_name []           = "oprmonI";
CHAR  dialog_que_name []           = "dialogA";
CHAR  authorizer_que_name[]        = "txcntlA";
CHAR  updateds_que_name[]          = "updatdsA";
CHAR  SHARED_MEMORY_TBL[12];

CHAR   AppName[8] = "";
CHAR   Version[] = "ATP_5.18.1"; 
							  

/* Online Updates */
AMEX_ONLINE_UPDATES  Online_Updates;

/* Statistics for Monitor */
TXN_COUNTS     Txn_Counts;
MONITOR_STATS  Monitor_Stats;

/* Txn Tracing Info */
CHAR   DirPath[MAX_APP_NAME_SIZE];
CHAR   TraceFile[MAX_APP_NAME_SIZE];
INT    Tracing;
FILE   TraceFile_fp;
FILE   *pTraceFile_fp;
FILE   **ppTraceFile_fp;

/*****************************************************************************

  Function:    PinnacleMsgHandler  

  Description: This function will bring in a PTE message and determine where
               it should be routed.
  Author: 
      unknown
  Inputs:
      p_msg_in - the incoming PTE message
  Outputs:
      None
  Return values:
      None
  Modified by:
      BGable      6/30/98
******************************************************************************/
void PinnacleMsgHandler( pPTE_MSG p_msg_in )
{

   pPTE_MSG_DATA     p_msg_data = NULL_PTR;
   BYTE        subtype1;
   AUTH_TX     auth_tx;
   CHAR        buffer[100];


   pPTE_MSG p_cur_msg;
   pPTE_MSG p_msg_out;
   pBYTE    p_data_data = NULL_PTR;


   p_cur_msg = p_msg_in;
	p_msg_out = NULL_PTR;

   ptestats_accumulate_msg_stats(p_msg_in);

	switch( ptemsg_get_msg_type(p_cur_msg) )
	{
		case MT_AUTH_RESPONSE: 
          /* Response coming in via the authorizer */
		    (void)process_incoming_message(p_msg_in);
			 break;

      case MT_INCOMING: 
			 /* Reply from the external host */
	       (void)incoming_host_message(p_msg_in);
          break;

      case MT_TIMER_TIMEOUT: 
          /* Reply about timeout of ptemsg */
          (void)process_timeout_msg(p_msg_in);
          break;

      case MT_SYS_MONITOR:
         
         switch( ptemsg_get_msg_subtype1(p_cur_msg) )
         {
            case ST1_LOGON:
                // Request from Monitor to send LogOn 
                memset (&auth_tx, 0, sizeof(AUTH_TX));
                if (false == perform_host_logon_request(LOGON_REQUEST,
                                                        SOURCE_IS_OPERATOR,
                                                        &auth_tx))
                {
                   TxUtils_Send_Msg_To_Operator(1,
                                    "Error executing host LogOn request",
                                     1, INFO_MSG, "PinnacleMsgHandler", 0,
                                     INFO_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
                }
               break;

            case ST1_LOGOFF:
                // Request from Monitor to send LogOff 
               memset (&auth_tx, 0, sizeof(AUTH_TX));
               if (false == perform_host_logon_request(LOGOFF_REQUEST,
                                                       SOURCE_IS_OPERATOR,
                                                       &auth_tx))
                {
                   TxUtils_Send_Msg_To_Operator(1,
                                    "Error executing host LogOff request",
                                     1, INFO_MSG, "PinnacleMsgHandler", 0,
                                     INFO_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
                }
                break;

            case ST1_ECHOTEST:
                // Request from Monitor to send LogOn 
                memset (&auth_tx, 0, sizeof(AUTH_TX));
                if (false == perform_host_logon_request(ECHO_REQUEST,
                                                        SOURCE_IS_OPERATOR,
                                                        &auth_tx))
                {
                   TxUtils_Send_Msg_To_Operator(1,
                                    "Error executing host Echo Test",
                                     1, INFO_MSG, "PinnacleMsgHandler", 0,
                                     INFO_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
                }
                break;
  
            case ST1_NETWORK_QUERY:
                /* Request from Monitor to send status information */
                if (false == send_network_status_to_monitor())
                {
                   TxUtils_Send_Msg_To_Operator(0,
                                    "Error sending network status to monitor",
                                     1, INFO_MSG, "PinnacleMsgHandler", 0,
                                     INFO_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
                }
                break;
  
            default:
                break;
         }
            break;
        

		case MT_SYSTEM_REQUEST: 
         PRINT("MT_SYSTEM_REQUEST  \n" );
         ptesystm_system_msg_handler(p_msg_in);
		 process_encryption_flag( p_msg_in );
         if ( ST1_SYS_PING == ptemsg_get_msg_subtype1(p_msg_in) )
         {
            if ( Tracing == TRACE_ON )
            {
               /* Flush the trace file buffer when service is pinged. */
               if ( false == flush_file(ppTraceFile_fp) )
               {
                  Tracing = TRACE_OFF;
                  sprintf( buffer,
                    "%s: Unable to flush trace file buffer. Turning Trace off.",
                     ServiceName );
                  TxUtils_Send_Msg_To_Operator(1, buffer,
                                 1,INFO_MSG,"PinnacleMsgHandler",3,INFO_ERROR,
                                 0,0,0);
                  (void)close_trace_file( ppTraceFile_fp );
               }
            }

            /* When pinged, display application version on Monitor. */
            sprintf( buffer,
                    "Pinged -> Network Controller Service: %s, version %s",
                     ServiceName, Version );
            TxUtils_Send_Msg_To_Operator( 1, buffer, 1, INFO_MSG,
                                         "PinnacleMsgHandler",
                                          0, INFO_ERROR, 0, 0, 0 );
         }
         break;

      case MT_SYSTEM_REPLY: 
         PRINT("MT_SYSTEM_REPLY  \n" );
         break;

      case MT_DB_REPLY:
            if (PTEMSG_OK == ptemsg_get_result_code(p_msg_in))
            {
               hhutil_parse_db_ok(p_msg_in);
            }
            else
            {
               hhutil_parse_db_error(p_msg_in);
            }
          break;

      case MT_TIMER_REPLY:
         PRINT("MT_TIMER_REPLY  \n" );
         if (PTEMSG_OK == ptemsg_get_result_code(p_msg_in))
         {
            subtype1 = ptemsg_get_msg_subtype1(p_msg_in);
            if (ST1_TIMER_READ == subtype1)
            {
               (void)incoming_host_message_timer_reply(p_msg_in);
            }
            else if (ST1_TIMER_START == subtype1)
            {
               send_request_to_host_timer_reply(p_msg_in);
            }

         }
         break;


      case MT_GET_STATS:
         (void)send_transaction_statistics( p_msg_in );
         break;

      case MT_RESET_STATS:
         (void)reset_transaction_statistics( p_msg_in );
         break;

      case MT_INCOMING_GUI:
         /* GUI is initiating an 1304 message for Amex: Online File Update. */

		  (void)process_file_update_request( p_msg_in );
      break;

      case MT_NSP_XLATETOANSI_RESPONSE:

         // Response from a translate key
	      p_msg_data = ptemsg_get_pte_msg_data(p_msg_in);
         p_data_data = ptemsg_get_pte_msg_data_data(p_msg_data);
	      memcpy(&auth_tx, p_data_data, sizeof(AUTH_TX));
         if ( false == process_incoming_message_continued( &auth_tx ) )  
         {
            TxUtils_Send_Msg_To_Operator(1,
                             "Error processing incoming security request",
                              1, WARN_MSG, "PinnacleMsgHandler", 3,
                              WARNING_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
         }
      break;


      default :
         TxUtils_Send_Msg_To_Operator(1,
                          "Unknown message type received",
                           1, WARN_MSG, "PinnacleMsgHandler", 3,
                           WARNING_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
			break;
	}  /* switch msg_type */

} /* PinnacleMsgHandler */

/*****************************************************************************

  Function:    MainProcessor

  Description: This function will start up and shutdown ncamex, as well as
               check for and bring in new PTE messages.
  Author: 
      unknown
  Inputs:
      None
  Outputs:
      None
  Return values:
      None
  Modified by:
      BGable      6/30/98
******************************************************************************/
void MainProcessor()
{
	pPTE_MSG	p_msg;
	LONG		ret_code;
   INT      rc;
	CHAR		ErrorMsg[100];
	CHAR		Buffer[256];
   CHAR     err_msg[200];
   AUTH_TX  auth_tx;
   NCF01    ncf01_i;
    
	GetAppName( AppName );

   GetAppName (cur_app_name);
   GetXipcInstanceName( Buffer );
   sprintf( Buffer,
           "Starting the Network Controller Service: %s, version %s",
            ServiceName, Version );
   LogEvent( Buffer, INFO_MSG );
   printf( "%s\n", Buffer );

#ifdef _DEBUG   
   if( !pteipc_init_single_instance_app( AppName, "pte_ipc" ) ) 
#else
   if( !pteipc_init_multiple_instance_app( AppName, ServiceName, Buffer ))
#endif
	{
      TxUtils_Send_Msg_To_Operator (1, "Failed to create XIPC queues", 1,
                                    ERROR_MSG, "MainProcessor", 4, FATAL_ERROR,
                                    NULL_PTR, NULL_PTR, NULL_PTR);
	
		/* pteipc_shutdown_single_instance_app(); */
		pteipc_shutdown_multiple_instance_app();
		MainProcessDone = 1;
		return;
	}

   if (strlen(AppName) > (sizeof(ncf01.primary_key.network_id)-2) )
	{
      sprintf(Buffer,
             "Error - the name of the application: %s  must be %d characters or less",
              AppName,(sizeof(ncf01.primary_key.network_id)-2));
      TxUtils_Send_Msg_To_Operator (1, Buffer, 1, WARN_MSG, "MainProcessor", 3,
                                    WARNING_ERROR, NULL_PTR, NULL_PTR,NULL_PTR);
#ifdef _DEBUG
      pteipc_shutdown_single_instance_app(); 
#else
      pteipc_shutdown_multiple_instance_app();
#endif
		MainProcessDone = 1;
		return;
	}

   /*  Create a table to be used for sahred memory between multiple
       instances of this Network Control Module.  It contains three 
       fields:  # of consecutive timeouts, # of active transactions, 
       and the current state of the host.
   */
   memset(SHARED_MEMORY_TBL, 0, sizeof(SHARED_MEMORY_TBL));
   strcpy(SHARED_MEMORY_TBL,cur_app_name);
   strcat(SHARED_MEMORY_TBL,"Table");
   ret_code = create_generic_table( SHARED_MEMORY_TBL);
   if ( MEMACCESSERROR == ret_code )
   {
      // Table already exists.
      PRINT ("Shared memory table already exists. \n");
   }
   else if ( 0 == ret_code )
   {
      // Table was successfully created.  Initialize host counters and state. 
      ret_code = WriteGenericTable( SHARED_MEMORY_TBL, "0", "0", ONLINE );
      if ( 0 != ret_code)
      {
         /* Error creating the table.  It must already exist. */
         TxUtils_Send_Msg_To_Operator (1, "Unable to write to shared memory", 1,
                                       WARN_MSG, "MainProcessor", 3,
                                       WARNING_ERROR, NULL_PTR,
                                       NULL_PTR, NULL_PTR);
      }
   }
   else
   {
         /* Error creating the table.   */
         TxUtils_Send_Msg_To_Operator(1, "Unable to create to shared memory", 1,
                                      WARN_MSG, "MainProcessor", 3,
                                      WARNING_ERROR, NULL_PTR,
                                      NULL_PTR, NULL_PTR);
   }
  
   /* Initialize transaction statistics */
   (void)reset_stats( &Txn_Counts );

   /* Determine if transaction tracing should be turned on. */
   rc = get_trace_ini_info( AppName, DirPath, ErrorMsg );
   if ( rc == 0 )
   {
      Tracing = TRACE_ON;

      /* Open the transaction trace file. */
      memset( TraceFile, 0x00, sizeof(TraceFile) );

      pTraceFile_fp  = &TraceFile_fp;
      ppTraceFile_fp = &pTraceFile_fp;

      if (false == open_trace_file(AppName,DirPath,ppTraceFile_fp,TraceFile))
      {
         Tracing = TRACE_OFF;
         sprintf( ErrorMsg,
                 "Unable to open trace file %s. Tracing is off",
                  TraceFile );
         TxUtils_Send_Msg_To_Operator(1,ErrorMsg,
                                      1,INFO_MSG,"MainProcessor",2,INFO_ERROR,
                                      0,0,0);
      }
      else
         TxUtils_Send_Msg_To_Operator(1,"Tracing is turned ON",
                                      1,INFO_MSG,"MainProcessor",2,INFO_ERROR,
                                      0,0,0);
   }
   else
   {
      Tracing = TRACE_OFF;
      if ( rc == -1 )
      {
         TxUtils_Send_Msg_To_Operator(1,ErrorMsg,
                                      1,INFO_MSG,"MainProcessor",2,INFO_ERROR,
                                      0,0,0);
      }
      TxUtils_Send_Msg_To_Operator(1,"Tracing is turned off",
                                   1,INFO_MSG,"MainProcessor",0,INFO_ERROR,
                                   0,0,0);
   }

   /* Get Acquiring network record. */
   memset(&ncf01, 0, sizeof(NCF01));
   strcpy(ncf01.primary_key.network_id, AppName );
   ncf01.primary_key.network_type[0] = 'A';
   if (hhutil_get_ncf01_cfg( &ncf01, err_msg) != PTEMSG_OK)
   {
      sprintf(Buffer, "Error on select of NCF01: %s", err_msg);
      TxUtils_Send_Msg_To_Operator (1, Buffer, 1, WARN_MSG, "MainProcessor", 3,
                                    WARNING_ERROR, NULL_PTR, NULL_PTR,NULL_PTR);
   }

   /* Get Issuing network record */
   memset(&ncf01_i, 0, sizeof(NCF01));
   strcpy(ncf01_i.primary_key.network_id, AppName );
   ncf01_i.primary_key.network_type[0] = 'I';
   if (hhutil_get_ncf01_cfg( &ncf01_i, err_msg) == PTEMSG_OK)
   {
      /* Copy some information from Issuer record into Acquirer record. */
      strcpy( ncf01.forwarding_inst_id_code,  ncf01_i.forwarding_inst_id_code  );
      strcpy( ncf01.max_consecutive_timeouts, ncf01_i.max_consecutive_timeouts );
      strcpy( ncf01.request_timer,            ncf01_i.request_timer            );
      strcpy( ncf01.max_active_txns,          ncf01_i.max_active_txns          );
      strcpy( ncf01.acquirer_inst_id_code,    ncf01_i.acquirer_inst_id_code    );
   }

   if (0 == strcmp(ncf01.auto_logon,"1"))
   {
      // set up a logon request to the host in auth_tx 
      memset(&auth_tx, 0, sizeof(AUTH_TX));
      perform_host_logon_request(LOGON_REQUEST, SOURCE_IS_OPERATOR, &auth_tx);
   }

   if (false == send_network_status_to_monitor())
   {
      TxUtils_Send_Msg_To_Operator(0,"Error sending network status to monitor",
                                   1, INFO_MSG, "PinnacleMsgHandler", 0,
                                   INFO_ERROR, NULL_PTR, NULL_PTR, NULL_PTR);
   }

   while( !EndProcessSignalled )
	{

		/* You are blocked here waiting for a message on either app queue or control que  */
		/* if there is no message on either que for 5 seconds, the blocking call returns   */

		/* The following line will be used to get messages from the queue. For now the
		   message is automatically created here, but this will be removed */
	   p_msg = pteipc_receive( application_que_name, control_que_name, 5, &ret_code ); 

			                 
		if( p_msg != NULL_PTR )
		{
			PinnacleMsgHandler( p_msg );
			free (p_msg); 
		}
		else if( ret_code != QUE_ER_TIMEOUT ) 
		{
			pteipc_get_errormsg( ret_code, ErrorMsg );
         sprintf( Buffer, "Error on pteipc_receive %s", ErrorMsg );
         TxUtils_Send_Msg_To_Operator (1, Buffer, 1, ERROR_MSG, "MainProcessor",
                                       4, FATAL_ERROR, NULL_PTR, NULL_PTR,
                                       NULL_PTR);
		}
	}

   WriteGenericTable( SHARED_MEMORY_TBL, "0", "0", DOWN );
   (void)send_network_status_to_monitor();

#ifdef _DEBUG
      pteipc_shutdown_single_instance_app(); 
#else
      pteipc_shutdown_multiple_instance_app();
#endif
	MainProcessDone = 1;
}



/*****************************************************************************

  Function:    EndProcess   

  Description: This function will output a message to notify the user that ncamex
               is being shut down.
  Author: 
      unknown
  Inputs:
      None
  Outputs:
      None
  Return values:
      None
  Modified by:
      BGable      6/30/98
******************************************************************************/
void EndProcess()
{
   CHAR Buffer[100] = "";

   if ( Tracing == TRACE_ON )
   {
      if ( false == close_trace_file( ppTraceFile_fp ))
      {
         sprintf( Buffer, "Unable to close trace file %s", TraceFile );
         TxUtils_Send_Msg_To_Operator(1,Buffer,
                                      1,INFO_MSG,"EndProcess",2,INFO_ERROR,
                                      0,0,0);
      }
   }

   sprintf( Buffer, "Shutting down the %s Service, version %s",
            ServiceName, Version );
   LogEvent( Buffer, INFO_MSG );
   strcat( Buffer, "\n" );
   PRINT( Buffer );
}


