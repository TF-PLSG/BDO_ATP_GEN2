/*******************************************************************************
*
*  Copyright (c) 2011, TF, Inc. All Rights Reserved.
*
*  MODULE:           dbf.c
*
*  TITLE:            Credit/Debit DBF TLF Files
*
*  DESCRIPTION:      This module creates
*
*
*  APPLICATION:      BDO
*
*  AUTHOR:           Phani
*
*  REVISION HISTORY:
*
* $   initial version release
*
*******************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <memory.h>
#include <math.h>

#include "basictyp.h"
#include "pte.h"
#include "ptemsg.h"
#include "pteipc.h"
#include "ptestats.h"
#include "ptesystm.h"
#include "ntutils.h"

#include "app_info.h"
#include "equitdb.h"
#include "dc_dbstruct.h"
#include "dbf.h"
#include "txutils.h"
#include "dc_database.h"
#include "memmnger.h"
#include "ptetimer.h"
#include "ptetime.h"
#include "dbcommon.h"
#include "timings.h"

#define MAX_FIELDS		66
#define MAX_FIELDS_SIZE	2112	/*66 * 32*/
#define MAX_HEADER_SIZE	32		/* 32*/

/***** External variables */

extern volatile INT  EndProcessSignalled;
extern volatile INT  MainProcessDone;
extern int           Start();
extern void          Stop ();

/***** Global variables *****/
static CHAR		trands_que_name[] = "devdsA";

TLF01			auth_tx_total;

static CHAR		cutoff_date[9];
static CHAR		path[30] = "";  /*hold root directory path*/

static CHAR		dbf_filename[256] = "";    /* dump file name */
FILE			*dbfFilePtr = 0;	         /* dump file ptr */


static CHAR		dir_str  [128];
extern CHAR		ExeName[100];

CHAR			EndProcessFlag;
CHAR			AppName[12];
CHAR			lError_Msg[300];
CHAR			Version[] = "ATP_5.18.0"; 
CHAR			version_msb = 5;
CHAR			version_lsb = 14;
/* Globals used in the Exception File processing = records over 45 days old */
INT   ExceptionFlag = true;  /* Default so old records DO get processed */

INT   TempExRecCnt;
INT   ExceptRecCnt;
INT   ExceptFile = false;
INT   ExceptError;
CHAR  ExceptDate[9];
CHAR  CurrentDate[9];


/* Database Timing Measurements */
TIMINGS_LIST  TimingStats;
INT           DB_Timing_Flag; /* True = Do DB Timing Stats, False = don't do */
INT           ForceReport;
CHAR          ReportTime[5];

PRIVATE CHAR   global_err_str[100];
PRIVATE INT    global_err_code;
BYTE	des_key[200];
BYTE	cur_key[200];
BYTE	recs[4];

/******************************************************************************
*
*  NAME:         GET_DATE
*
*  DESCRIPTION:  This procedure takes an input string that contains a date and
*                time.  It copies the date portion into an output string,
*                formatted slightly different.
*
*  INPUTS:       time_date : Format = "YYYY-0M-0D-0H.0I.0S.JJJ"
*
*  OUTPUTS:      date_str  : Format = "YYYY0M0D"
*
*  RTRN VALUE:   None
*
*  AUTHOR:       Dennis Irby
*
******************************************************************************/
void get_date( pCHAR time_date, pCHAR date_str )
{
	memset ( date_str,  0x00,         9 );
	strncpy( date_str,  time_date,    4 );
	strncat( date_str, &time_date[5], 2 );
	strncat( date_str, &time_date[8], 2 );
}

/*******************************************************************************
*
*  FUNCTION:         main
*
*  DESCRIPTION:      This function gets the initial parameters.
*
*  INPUTS:           INT argc - number of parameters
*                    pCHAR argv[1] - path and filename
*
*  OUTPUTS:          None
*
*  RETURN VALUE:     None
*
*  AUTHOR:           Darcy Person
*
*******************************************************************************/
int main(int argc, char *argv[])
{
	char filename[256] = {0};
	sprintf(filename,DBF_FILE_INI);
	WORD key[] = {0x13A7, 0x6135, 0x9CDF, 0xA852};
						CHAR msgbuf[100] = "";

	CHAR correct_hours [24] [3] = {"00", "01", "02", "03", "04", "05",
		"06", "07", "08", "09", "10", "11",
		"12", "13", "14", "15", "16", "17",
		"18", "19", "20", "21", "22", "23"};

	CHAR correct_files [16] [7] = {"ALL", "all", "CREDIT", "credit",
		"DEBIT", "debit", "RAFFLE", "raffle",
		"A", "a", "C", "c", "D", "d", "R", "r"};

	CHAR correct_codes [16] [2] = {"A", "A", "C", "C", "D", "D", "R", "R",
		"A", "A", "C", "C", "D", "D", "R", "R"};

	int               hour_index;
	int               file_index;

	/*** Initialize global variables ***/
	memset(cutoff_date,  0, sizeof(cutoff_date));

	EndProcessFlag = false;
#ifndef WIN32
	strcpy(ExeName, argv[0]);
#endif

	/*** 1st Parameter - base file name ***/

	if(strlen(argv[1]) == 2)
	{
		if(argv[1][0] == '-')
		{
			switch(argv[1][1])
			{
				case 'k':
					if(strlen(argv[2]) > 8)
					{
						printf("\nERROR!!!\n");
						printf("DES key should not exceed more than 8 characters\n");
						return 0;
					}
					if(strlen(argv[2]) > 0)
					{

						memcpy(des_key, argv[2], 8);
						printf("\n");
						printf("original key = %s\n",des_key);
						des_encryption( (unsigned char *)(des_key),
											strlen(des_key), key, 1 );
						WritePrivateProfileString(
						"SECURITY",  /* pointer to section name*/
						"KEY",		 /* pointer to key name*/
						des_key ,    /* pointer to string to add*/
						filename	 /* pointer to initialization filename*/
						);
						printf("Encrypted key = %s\n",des_key);
						printf("Key successfully set\n");
						return 0;

					}
					else
					{
							printf("\nPlesae supply a key to set\n");
							return 0;
					}
					break;
				case 'f':
					//Descryption
					if(argc == 3)
					{
						if(strlen(argv[2]) > 0)
						{
							GetPrivateProfileString(
							"SECURITY",  /* pointer to section name*/
							"KEY",		 /* pointer to key name*/
							"",		/*default string */
							cur_key ,    /* pointer to read string into*/
							200,	/*buffer size*/
							filename	 /* pointer to initialization filename*/
							);
							des_decryption( (unsigned char *)(cur_key ),
												strlen(cur_key ), key, 1 );

							//printf("key = %s\n",cur_key);

							dbf_decrypt_file(argv[2]);
							return 0;

						}
						else
						{
								printf("\nPlesae give the dbf filename to decrypt.\n");
								return 0;
						}
					}
					else if(argc == 5)
					{
						if(strlen(argv[2]) > 0)
						{
							if(argv[3][1] == 'd')
							{
								if(strlen(argv[4]) > 0)
								{
									if(strlen(argv[4]) <=8)
									{
										strcpy(cur_key, argv[4]);
										dbf_decrypt_file(argv[2]);
										return 0;

									}
									else
									{
										printf("DES key should not exceed more than 8 characters.\n");
										return 0;
									}
								}
								else
								{
									printf("Please give key which was used for encrypting the file.\n");
									return 0;
								}
							}
							else
							{
								printf("Invalid syntax.\n");
								return 0;
							}
						}
						else
						{
								printf("\nPlesae give the dbf filename to decrypt.\n");
								return 0;
						}

					}
					else
					{
						printf("Invalid syntax.\n");
						return 0;
					}
					break;
				default:
					break;
			}
		}
		else
		{
			printf("\n\n");
			printf("Error in 2nd parameter.\n");
			printf("\n");
			return 0;
		}
	}
	else
	{
		if (strlen(argv[1]) != 8)
		{
			printf("\n\n");
			printf("Error in 2nd parameter.\n");
			printf("Date must be in YYYYMMDD format.\n");
			printf("\n");
			return 0;
		}
	}

	/*** 2nd Parameter - cutoff date ***/
	if (strcmp(argv[1], ",") != 0)
	{

	}
	strcpy(cutoff_date, argv[1]);
	/** Get the DES key and decrypt**/

	GetPrivateProfileString(
    "SECURITY",	            /*  points to section name  */
    "KEY",              /*  points to key name  */
    "DEFAULT",               /*  points to default string  */
    des_key,                         /*  points to destination buffer  */
    sizeof(des_key),             /*  size of destination buffer  */
    filename                        /*  points to initialization filename  */
   );
	if(strcmp(des_key, "DEFAULT") != 0)
	{
		des_decryption(des_key, strlen(des_key), key, 1);
		//printf("Decrypted key = %s\n", des_key);
		
	}
	else
	{
		printf("Key not found\n");
		return 0;
	}
	if(!Start())
		printf("Error starting ServiceManager\n\n" );

	Stop();

} /* main */

long get_first_block_size()
{
	long size = 0;
	WORKING_DBF_TLF01 w_dbf_tlf01;
	size = sizeof(w_dbf_tlf01.transaction_id) +
		sizeof(w_dbf_tlf01.entry_type) +
		sizeof(w_dbf_tlf01.acquirer_id) +
		sizeof(w_dbf_tlf01.terminal_id) +
		sizeof(w_dbf_tlf01.response_text) +
		sizeof(w_dbf_tlf01.card_num_len);
	return size;
}

BOOLEAN dbf_decrypt_file(char *filename)
{
	WORKING_DBF_TLF01 w_dbf_tlf01;
	BYTE header[10000] = {0};
	BOOLEAN bRet = 0;

	if(filename == NULL || strlen((char *)cur_key) == 0)
		return -1;

	char tmpFile[128] = {0};
	sprintf(tmpFile,"tmp_%s",filename);
	FILE *tmpPtr =NULL;

	FILE *fptr = fopen(filename,"rb");
	if(fptr == NULL)
		return -1;
	int card_size = sizeof(w_dbf_tlf01.card_num);
	long block_1 = get_first_block_size();
	long block_2 = sizeof(WORKING_DBF_TLF01) - block_1 - card_size;
	long count = 0;
	if(fptr != NULL)
	{
		rewind(fptr);
		printf("Decrypting the records......\n");
		memset(&w_dbf_tlf01, 0, sizeof(WORKING_DBF_TLF01));
		fread(header,1,MAX_HEADER_SIZE + MAX_FIELDS_SIZE +1, fptr);
		if(header[12] == 0x00)
		{
			tmpPtr = fopen(tmpFile,"wb");
			if(tmpPtr != NULL)
			{
				header[12] = 0x11;
				fwrite(header,1,MAX_HEADER_SIZE + MAX_FIELDS_SIZE +1, tmpPtr);
				while(!feof(fptr))
				{
					bRet = 1;
					fread(&w_dbf_tlf01, 1, sizeof(WORKING_DBF_TLF01), fptr);
					//printf("%s\n",w_dbf_tlf01.card_num);
					int i;
						for(i=0;i<sizeof(w_dbf_tlf01.card_num);i++)
						{
							if(w_dbf_tlf01.card_num[i] == 0x20)
								w_dbf_tlf01.card_num[i] = 0x00;
						}

					des_decryption(w_dbf_tlf01.card_num,strlen(w_dbf_tlf01.card_num),cur_key,1);
						for(i=0;i<sizeof(w_dbf_tlf01.card_num);i++)
						{
							if(w_dbf_tlf01.card_num[i] == 0x00)
								w_dbf_tlf01.card_num[i] = 0x20;
						}

					fwrite(&w_dbf_tlf01, 1, sizeof(WORKING_DBF_TLF01), tmpPtr);
					memset(&w_dbf_tlf01, 0, sizeof(WORKING_DBF_TLF01));
					count++;
				}
				if(bRet != 1)
				{
					remove(tmpFile);
				}
				fclose(tmpPtr);
			}
		}
		else
		{
			printf("The file '%s' is already decrypted.\n",filename);
			bRet = 0;
		}
		fclose(fptr);
	}


	if(bRet == 1)
	{

		tmpPtr =fopen(tmpFile,"rb");
		if(tmpPtr == NULL)
				return -1;
		fptr = fopen(filename,"wb");
		if(fptr == NULL)
				return -1;
		while(!feof(tmpPtr))
		{
			fread(header,10000,1,tmpPtr);
			fwrite(header,10000,1,fptr);
		}
		fclose(fptr);
		fclose(tmpPtr);
		remove(tmpFile);
		printf("%ld records decrypted.\n",count);

	}

		return bRet;
}

BOOLEAN tlf01_handler(pTLF01 tlf01_ptr)
{
	return true;
}

double Char2Hex(char *lpHex)
{
	double hexValue = 0;
	int len = strlen(lpHex);
	double temp = 0;
	double base = 16;
int i = 0;
	for(i=len-1; i>=0;i--)
	{
		switch(lpHex[i])
		{
		case '0':
			temp = 0;
			break;
		case '1':
			temp = 1 * (pow(base,len-i-1));
			break;
		case '2':
			temp = 2 * (pow(base,len-i-1));
			break;
		case '3':
			temp = 3 * (pow(base,len-i-1));
			break;
		case '4':
			temp = 4 * (pow(base,len-i-1));
			break;
		case '5':
			temp = 5 * (pow(base,len-i-1));
			break;
		case '6':
			temp = 6 * (pow(base,len-i-1));
			break;
		case '7':
			temp = 7 * (pow(base,len-i-1));
			break;
		case '8':
			temp = 8 * (pow(base,len-i-1));
			break;
		case '9':
			temp = 9 * (pow(base,len-i-1));
			break;
		case 'A':
			temp = 10 * (pow(base,len-i-1));
			break;
		case 'B':
			temp = 11 * (pow(base,len-i-1));
			break;
		case 'C':
			temp = 12 * (pow(base,len-i-1));
			break;
		case 'D':
			temp = 13 * (pow(base,len-i-1));
			break;
		case 'E':
			temp = 14 * (pow(base,len-i-1));
			break;
		case 'F':
			temp = 15 * (pow(base,len-i-1));
			break;
		}
		hexValue += temp;
	}

	return hexValue;

}

/*******************************************************************************
*
*  FUNCTION:         MainProcessor
*
*  DESCRIPTION:      This function performs initial application setup.
*
*  INPUTS:           None
*
*  OUTPUTS:          None
*
*  RETURN VALUE:     None
*
*  AUTHOR:           Darcy Person
*
*******************************************************************************/
void MainProcessor(void)
{
	CHAR			szTotalRecords[20] = {0};
	INT				nTotalRecords;
	BOOLEAN			bContinue = false;
	CHAR              buffer[500];
	CHAR              err_msg[100];
	CHAR              time_date[25] = "";
	INT               count_tran = 0;
	INT               next_portion = 0;
	INT               num_returned = 0;
	INT               ret_code = 0;
	LONG              julian;
	BYTE              bch01_buffer[sizeof(AUTH_TX) + sizeof(BCH01)];
	INT               num_sql;
	INT               err_ctr = 0;
	double            start_time;
	double            end_time;
	double            duration;

	/* Clear buffer (set to null) */
	memset(&bch01_buffer,0, sizeof(bch01_buffer));
	memset (&lError_Msg, 0x00, sizeof (lError_Msg));
	memset (&buffer, 0x00, sizeof(buffer));

	GetAppName (AppName);

	sprintf( buffer,
		"Starting DBF File creation: %s, version %s", AppName, Version );
	LogEvent( buffer, INFO_MSG );

	/* Send message to DOS window in debug mode */
	strcat(buffer,"\n");
	printf(buffer);

	/*Get root directory path*/
	memset (path, 0x00, sizeof(path));
	GetAscendentRootDirectory(path);

	/* Get Database Timing Parameters to gather statistics about each query. */
	memset( ReportTime, 0x00, sizeof(ReportTime) );
	memset( buffer,     0x00, sizeof(buffer)     );
	/* Try to connect to the database */
	if (dbcommon_connect ("equitable", "equitable", "equitable", "ORCL", err_msg) != PTEMSG_OK)
	{
		memset(&buffer, 0x00, sizeof(buffer));
		strcpy(buffer, "Database Connect Error:  ");
		strcat(buffer, err_msg);
		printf(buffer);
		MainProcessDone = 1;

		return;
	}

	/* Send message to system monitor */
	printf("Connected to ORACLE \n");

	/* Set cutoff date and time */

	/* Set dates for Exception processing. */
	ptetime_get_timestamp( time_date );  /* YYYY-MM-DD-hh.mm.ss.jjj */
	get_date( time_date, CurrentDate );  /* YYYYMMDD */

	/* Exception Date = Current Date minus 45 days */

	{
		dbfFilePtr = NULL;
		char totalCount[20] = {0};
		long totalRecords = 0;
		if (ret_code =  (db_get_tlf01_count(totalCount, err_msg, cutoff_date)) != PTEMSG_OK)
		{
			sprintf (buffer, "Error processing TLF01.");
			sprintf(lError_Msg,"db_get_tlf01_list: %s",buffer);
			LogEvent(lError_Msg,ERROR_MSG);

		}
		totalRecords = atol(totalCount);
		//long f = 2147483647;
		//printf("%08X\n",f);
		printf("Total records found = %d\n", totalRecords);

		if(totalRecords > 0)
		{
			char tempStr[3] = {0};
			sprintf(totalCount,"%08X",totalRecords);
			tempStr[0] = totalCount[0];
			tempStr[1] = totalCount[1];
			tempStr[2] = '\0';
			recs[0] = Char2Hex(tempStr);

			tempStr[0] = totalCount[2];
			tempStr[1] = totalCount[3];
			tempStr[2] = '\0';
			recs[1] = Char2Hex(tempStr);

			tempStr[0] = totalCount[4];
			tempStr[1] = totalCount[5];
			tempStr[2] = '\0';
			recs[2] = Char2Hex(tempStr);

			tempStr[0] = totalCount[6];
			tempStr[1] = totalCount[7];
			tempStr[2] = '\0';
			recs[3] = Char2Hex(tempStr);

			strcpy(dbf_filename,"TLF_DBF_");
			strcat(dbf_filename,cutoff_date);
			strcat(dbf_filename,".dbf");
			if(CreateDBF(dbf_filename))
			{
				if (ret_code =  (db_get_tlf01_list(err_msg, cutoff_date)) != PTEMSG_OK)
				{
					sprintf (buffer, "Error processing TLF01.");
					sprintf(lError_Msg,"db_get_tlf01_list: %s",buffer);
					LogEvent(lError_Msg,ERROR_MSG);
				}
			}
		}

	}
	/*disconnect from database*/
	dbcommon_disconnect (err_msg);

	printf("Completing DBF \n");

	if( dbfFilePtr != NULL)
	{
		fclose(dbfFilePtr);
		printf("'%s' DBF file created!!!\n",dbf_filename);
	}
	else
	{
		printf("Unable to create the DBF File!\n");
	}
	MainProcessDone = 1;

	return;

} /* MainProcessor */

BOOLEAN CreateDBF(char *filename)
{
	dbfFilePtr = fopen(filename,"rb");
	if(dbfFilePtr != NULL)
	{
		fclose(dbfFilePtr);
		dbfFilePtr = NULL;
		printf("the DBF file %s already exists!. Do you want to overwrite? [Y/N]:");
		char c = getchar();
		if(c != 'y' && c != 'Y')
		{
			return false;
		}
	}
	dbfFilePtr = fopen(filename, "wb");
	if(dbfFilePtr == NULL)
	{
		printf("Unable to create the file.\n");
		return false;
	}
	return WriteDBFHeader();

}

BOOLEAN WriteDBFHeader()
{
	char header[32] =  {0};
	char FieldArray[6080];
	int i=0;
	time_t now; struct tm* timeStamp;
	if(dbfFilePtr == NULL) { return FALSE; }

	memset(FieldArray, 0, 6080);
	now = time(0); timeStamp = localtime(&now);

//printf("DATE: %d - %d - %d\n",timeStamp->tm_year + 1900, timeStamp->tm_mon + 1, timeStamp->tm_mday);
	header[0] = 0x03;
	header[1] = timeStamp->tm_year + 1900;
	header[2] = timeStamp->tm_mon + 1;
	header[3] = timeStamp->tm_mday;

	//Maximum number of records. LSB first
//	header[4] = 0xFF;
//	header[5] = 0xFF;
//	header[6] = 0xFF;
//	header[7] = 0x7F;

	header[4] = recs[3];
	header[5] = recs[2];
	header[6] = recs[1];
	header[7] = recs[0];

	header[8] = 0x60;		//LSB of total size of the header
	header[9] = 0x08;		//HSB of total size of the header

	//Total records size must be the addition of size of all the variables of DBF_TLF that is to be written in the dbf file
	//Anyway computed below in this function
	header[10] = 0xA0;			//LSB of total size of records
	header[11] = 0x03;			//HSB of total size of records
	header[12] = 0x00;			// Used to find whether the file is encrypted or decrypted. 0- ENC 1-DEC
	header[13] = version_msb;
	header[14] = version_lsb;

	strcpy(&FieldArray[0], "TRAN_ID");		//1
	FieldArray[11] = 'C';
	strcpy(&FieldArray[32], "ENTRY_TYP");	//2
	FieldArray[43] = 'C';
	strcpy(&FieldArray[64], "ACQUIR_ID");	//5
	FieldArray[75] = 'C';
	strcpy(&FieldArray[96], "TERM_ID");		//7
	FieldArray[107] = 'C';
	strcpy(&FieldArray[128], "RESP_TEXT");	//9
	FieldArray[139] = 'C';
	strcpy(&FieldArray[160], "C_NUM_LEN");	//10
	FieldArray[171] = 'C';
	strcpy(&FieldArray[192], "CARD_NUM");	//11
	FieldArray[203] = 'C';
	strcpy(&FieldArray[224], "EXP_DATE");	//12
	FieldArray[235] = 'C';
	strcpy(&FieldArray[256], "TOT_AMT");	//13
	FieldArray[267] = 'C';
	strcpy(&FieldArray[288], "ORIG_AMT");	//16
	FieldArray[299] = 'C';
	strcpy(&FieldArray[320], "AUTH_NUM");	//17
	FieldArray[331] = 'C';
	strcpy(&FieldArray[352], "PROC_CODE");	//18
	FieldArray[363] = 'C';
	strcpy(&FieldArray[384], "SYS_AUDIT");	//19
	FieldArray[395] = 'C';
	strcpy(&FieldArray[416], "ORGSYSTRA");	//20
	FieldArray[427] = 'C';
	strcpy(&FieldArray[448], "POSENTMOD");	//21
	FieldArray[459] = 'C';
	strcpy(&FieldArray[480], "POSCONCOD");	//23
	FieldArray[491] = 'C';
	strcpy(&FieldArray[512], "RETREFNUM");	//26
	FieldArray[523] = 'C';
	strcpy(&FieldArray[544], "ORGRETNUM");	//27
	FieldArray[555] = 'C';
	strcpy(&FieldArray[576], "MERCH_ID");	//28
	FieldArray[587] = 'C';
	strcpy(&FieldArray[608], "ORG_MSG");	//29
	FieldArray[619] = 'C';
	strcpy(&FieldArray[640], "SET_TOTAL");	//30
	FieldArray[651] = 'C';
	strcpy(&FieldArray[672], "MSG_TYPE");	//31
	FieldArray[683] = 'C';
	strcpy(&FieldArray[704], "CHOLD_NAME");	//32
	FieldArray[715] = 'C';
	strcpy(&FieldArray[736], "GEN_STATUS");	//33
	FieldArray[747] = 'C';
	strcpy(&FieldArray[768], "BATCH_NUM");	//36
	FieldArray[779] = 'C';
	strcpy(&FieldArray[800], "RESP_CODE");	//37
	FieldArray[811] = 'C';
	strcpy(&FieldArray[832], "TRAN_DATE");	//38
	FieldArray[843] = 'C';
	strcpy(&FieldArray[864], "TRAN_TIME");	//39
	FieldArray[875] = 'C';
	strcpy(&FieldArray[896], "TRANSTTIME");	//51
	FieldArray[907] = 'C';
	strcpy(&FieldArray[928], "HOSTSTTIME");	//52
	FieldArray[939] = 'C';
	strcpy(&FieldArray[960], "HOSTFITIME");	//53
	FieldArray[971] = 'C';
	strcpy(&FieldArray[992], "TRANFITIME");	//54
	FieldArray[1003] = 'C';
	strcpy(&FieldArray[1024],"AGENT_ID");	//63
	FieldArray[1035] = 'C';
	strcpy(&FieldArray[1056],"CVC");		//64
	FieldArray[1067] = 'C';
	strcpy(&FieldArray[1088],"SETTLEDATE");	//65
	FieldArray[1099] = 'C';
	strcpy(&FieldArray[1120],"CATEG_CODE");	//65
	FieldArray[1131] = 'C';
	strcpy(&FieldArray[1152],"CONV_RATE");	//67
	FieldArray[1163] = 'C';
	strcpy(&FieldArray[1184],"PROD_CODE");	//68
	FieldArray[1195] = 'C';
	strcpy(&FieldArray[1216], "ACQ_ID");	//84
	FieldArray[1227] = 'C';
	strcpy(&FieldArray[1248], "OUT_BAL");	//85
	FieldArray[1259] = 'C';
	strcpy(&FieldArray[1280], "CRDT_LMT");	//86
	FieldArray[1291] = 'C';
	strcpy(&FieldArray[1312], "ORIGIN");	//92
	FieldArray[1323] = 'C';
	strcpy(&FieldArray[1344], "INT_RATE");	//99
	FieldArray[1355] = 'C';
	strcpy(&FieldArray[1376], "TOT_INT");	//100
	FieldArray[1387] = 'C';
	strcpy(&FieldArray[1408], "PROFILE");	//103
	FieldArray[1419] = 'C';
	strcpy(&FieldArray[1440], "NBRPRDCODE");//104
	FieldArray[1451] = 'C';
	strcpy(&FieldArray[1472], "PRDT1_CDE");	//105
	FieldArray[1483] = 'C';
	strcpy(&FieldArray[1504], "PRDT1_QTY");	//106
	FieldArray[1515] = 'C';
	strcpy(&FieldArray[1536], "PRDT1_AMT");	//107
	FieldArray[1547] = 'C';
	strcpy(&FieldArray[1568], "VISA_M_ID");	//165
	FieldArray[1579] = 'C';
	strcpy(&FieldArray[1600], "DEF_FACTOR");//167
	FieldArray[1611] = 'C';
	strcpy(&FieldArray[1632], "DEFTERMLEN");//168
	FieldArray[1643] = 'C';
	strcpy(&FieldArray[1664], "CURNCY_CDE");//169
	FieldArray[1675] = 'C';
	strcpy(&FieldArray[1696], "TRANS_TIME");//170
	FieldArray[1707] = 'C';
	strcpy(&FieldArray[1728], "CVC_DATA");	//172
	FieldArray[1739] = 'C';
	strcpy(&FieldArray[1760], "VERMAGSTR");	//173
	FieldArray[1771] = 'C';
	strcpy(&FieldArray[1792], "SECRESCODE");//175
	FieldArray[1803] = 'C';
	strcpy(&FieldArray[1824], "SERV_CODE");//176
	FieldArray[1835] = 'C';
	strcpy(&FieldArray[1856], "VOICE_AUTH");//179
	FieldArray[1867] = 'C';
	strcpy(&FieldArray[1888], "ACTUAL_AMT");//180
	FieldArray[1899] = 'C';
	strcpy(&FieldArray[1920], "REVERS_AMT");//181
	FieldArray[1931] = 'C';
	strcpy(&FieldArray[1952], "V_AUTH_TXT");//182
	FieldArray[1963] = 'C';
	strcpy(&FieldArray[1984], "OPERAT_ID");	//183
	FieldArray[1995] = 'C';
	strcpy(&FieldArray[2016], "ORGAUTHNUM");//185
	FieldArray[2027] = 'C';
	strcpy(&FieldArray[2048], "SYS_DATE");	//187
	FieldArray[2059] = 'C';
	strcpy(&FieldArray[2080],  "M_AMORT_AM");//189
	FieldArray[2091] = 'C';



	FieldArray[16]		=    21; 	//TRAN_ID		//1
	FieldArray[48]		=    1;  	//ENTRY_TYP		//2
	FieldArray[80]		=   21; 	//ACQUIR_ID		//5
	FieldArray[112]		=   9;  	//TERM_ID		//7
	FieldArray[144]		=   41; 	//RESP_TEXT		//9
	FieldArray[176]		=   3;  	//C_NUM_LEN		//10
	FieldArray[208]		=   65; 	//CARD_NUM		//11
	FieldArray[240]		=   5;  	//EXP_DATE		//12
	FieldArray[272]		=   13; 	//TOT_AMT		//13
	FieldArray[304]		=   13; 	//ORIG_AMT		//16
	FieldArray[336]		=   7;  	//AUTH_NUM		//17
	FieldArray[368]		=   7;  	//PROC_CODE		//18
	FieldArray[400]		=   7;  	//SYS_AUDIT		//19
	FieldArray[432]		=   7;  	//ORGSYSTRA		//20
	FieldArray[464]		=   5;  	//POSENTMOD		//21
	FieldArray[496]		=   3; 		//POSCONCOD		//23
	FieldArray[528]		=   13; 	//RETREFNUM		//26
	FieldArray[560]		=   13; 	//ORGRETNUM		//27
	FieldArray[592]		=   16; 	//MERC_ID		//28
	FieldArray[624]		=   5;  	//ORG_MSG		//29
	FieldArray[656]		=   17; 	//SET_TOTAL		//30
	FieldArray[688]		=   5;  	//MSG_TYPE		//31
	FieldArray[720]		=  31; 	//CHOLD_NAME	//32
	FieldArray[752]		=  2;  	//GEN_STATUS	//33
	FieldArray[784]		=  7;  	//BATCH_NUM		//36
	FieldArray[816]		=  3;  	//RESP_CODE		//37
	FieldArray[848]		=  9;  	//TRAN_DATE		//38
	FieldArray[880]		=  7;  	//TRAN_TIME		//39
	FieldArray[912]		=  17; 	//TRANSTTIME	//51
	FieldArray[944]		=  17; 	//HOSTSTTIME	//52
	FieldArray[976]		=  17; 	//HOSTFITIME	//53
	FieldArray[1008]	=  17; 	//TRANFITIME	//54
	FieldArray[1040]	=  12; 	//AGENT_ID		//63
	FieldArray[1072]	=  1;  	//CVC			//64
	FieldArray[1104]	=  5;  	//SETTLEDATE	//65
	FieldArray[1136]	=  5;  	//CATE_CODE		//66
	FieldArray[1168]	=  10; 	//CONV_RATE		//67
	FieldArray[1200]	=  9;  	//PROD_CODE		//68
	FieldArray[1232]	=  12; 	//ACQ_ID		//84
	FieldArray[1264]	=  13; 	//OUT_BAL		//85
	FieldArray[1296]	=  13; 	//CRDT_LMT		//86
	FieldArray[1328]	=  3;  	//ORIGIN		//92
	FieldArray[1360]	=  5;  	//INT_RATE		//99
	FieldArray[1392]	=  13; 	//TOT_INT		//100
	FieldArray[1424]	=  3;  	//PROFILE		//103
	FieldArray[1456]	=  3;  	//NBRPRDCODE	//104
	FieldArray[1488]	=  7;  	//PRDT1_CDE		//105
	FieldArray[1520]	=  3;  	//PRDT1_QTY		//106
	FieldArray[1552]	=  13; 	//PRDT1_AMT		//107
	FieldArray[1584]	=  16; 	//VISA_M_ID		//165
	FieldArray[1616]	=  8;  	//DEF_FACTOR	//167
	FieldArray[1648]	=  4;  	//DEFTERMLEN	//168
	FieldArray[1680]	=  4;  	//CURNCY_CDE	//169
	FieldArray[1712]	=  11; 	//TRANS_TIME	//170
	FieldArray[1744]	=  4;  	//CVC_DATA		//172
	FieldArray[1776]	=  2;  	//VERMAGSTR		//173
	FieldArray[1808]	=  3;  	//SECRESCODE	//175
	FieldArray[1840]	=  4;  	//SERV_CODE		//176
	FieldArray[1872]	=  2;  	//VOICE_AUTH	//179
	FieldArray[1904]	=  13; 	//ACTUAL_AMT	//180
	FieldArray[1936]	=  13; 	//REVERS_AMT	//181
	FieldArray[1968]	=  241;	//V_AUTH_TXT	//182
	FieldArray[2000]	=  21; 	//OPERAT_ID		//183
	FieldArray[2032]	=  7;  	//ORGAUTHNUM	//185
	FieldArray[2064]	=  9;  	//SYS_DATE		//187
	FieldArray[2096]	=  13; 	//M_AMORT_AM	//189

	{
		int i=0;
		int totalsize = 0;
		for(i=16;i<MAX_FIELDS_SIZE;i=i+32)
		{
			totalsize	+=	FieldArray[i];
		}
		char totalCount[10] = {0};
		char tempStr[3] = {0};
			sprintf(totalCount,"%04X",totalsize);
			tempStr[0] = totalCount[0];
			tempStr[1] = totalCount[1];
			tempStr[2] = '\0';
			recs[0] = Char2Hex(tempStr);
			tempStr[0] = totalCount[2];
			tempStr[1] = totalCount[3];
			tempStr[2] = '\0';
			recs[1] = Char2Hex(tempStr);
				//Total records size must be the addition of size of all the variables of DBF_TLF that is to be written in the dbf file
	header[10] = recs[1];			//LSB of total size of records
	header[11] = recs[0];			//HSB of total size of records
	}


	fwrite(header,1,32,dbfFilePtr);
	fwrite(FieldArray,1,MAX_FIELDS_SIZE,dbfFilePtr);
	char sep = 0x20;
fwrite(&sep, 1, 1, dbfFilePtr);
	return TRUE;
}

BOOLEAN WriteString(char *str)
{
	printf("%s\n",str);
	return TRUE;
}
BOOLEAN WriteChar(char c)
{
	return TRUE;
}
INT isnum(pCHAR in_str)
{
   INT i;
   INT length;

   length = (INT)strlen(in_str);

   for (i = 0; i < length; i++)
   {
      if (!isdigit(in_str[i]))
        return(false);
   }
   return(true);
}

BOOLEAN WriteTLF01TableIntoDBF(DBF_TLF01 *pte_tlf01)
{
	if(dbfFilePtr == NULL)
	{
		return FALSE;
	}
	if(isnum(pte_tlf01->card_num)== false || strlen(pte_tlf01->card_num)== 0)
	{
		/*Dont write to DBF file*/
		return TRUE;
	}
	fwrite(pte_tlf01->transaction_id, 1 ,	sizeof(pte_tlf01->transaction_id),	dbfFilePtr);	//1

//Restrict entry type always to be one character.
	if(pte_tlf01->entry_type > 0x09)
	{
		pte_tlf01->entry_type = 0;	//Invalid entry type. 
	}
	fprintf(dbfFilePtr,"%x",pte_tlf01->entry_type);

	fwrite(pte_tlf01->acquirer_id, 1 ,		sizeof(pte_tlf01->acquirer_id),		dbfFilePtr);	//5
	fwrite(pte_tlf01->terminal_id, 1 ,		sizeof(pte_tlf01->terminal_id),		dbfFilePtr);	//7
	fwrite(pte_tlf01->response_text, 1 ,	sizeof(pte_tlf01->response_text),	dbfFilePtr);	//9
	fwrite(pte_tlf01->card_num_len, 1 ,		sizeof(pte_tlf01->card_num_len),	dbfFilePtr);	//10
	char str[65] = {0};
	memcpy(str, pte_tlf01->card_num,64);
	//printf("%s - %d\n",str,strlen(str));
	int i = 0;
	for(i=0;i<sizeof(str);i++)
	{
		if(str[i] == 0x20)
			str[i] = 0x00;
	}
	des_encryption((unsigned char *)str, strlen(str), des_key, 1);
	for(i=0;i<sizeof(str);i++)
	{
		if(str[i] == 0x00)
			str[i] = 0x20;
	}

	//fwrite(pte_tlf01->card_num, 1 ,		  sizeof(pte_tlf01->card_num),			dbfFilePtr);
	fwrite(str, 1 ,		sizeof(str),	dbfFilePtr);	//11

	fwrite(pte_tlf01->exp_date, 1 ,				sizeof(pte_tlf01->exp_date),			dbfFilePtr);						//12
	fwrite(pte_tlf01->total_amount, 1 ,			sizeof(pte_tlf01->total_amount),		dbfFilePtr);						//13
	fwrite(pte_tlf01->orig_amount, 1 ,			sizeof(pte_tlf01->orig_amount),		dbfFilePtr);							//16
	fwrite(pte_tlf01->auth_number, 1 ,			sizeof(pte_tlf01->auth_number),		dbfFilePtr);							//17
	fwrite(pte_tlf01->processing_code, 1 ,		sizeof(pte_tlf01->processing_code),		dbfFilePtr);						//18
	fwrite(pte_tlf01->sys_trace_audit_num, 1 ,	sizeof(pte_tlf01->sys_trace_audit_num),	dbfFilePtr);						//19
	fwrite(pte_tlf01->orig_sys_trace_num, 1 ,	sizeof(pte_tlf01->orig_sys_trace_num),		dbfFilePtr);					//20
	fwrite(pte_tlf01->pos_entry_mode, 1 ,		sizeof(pte_tlf01->pos_entry_mode),		dbfFilePtr);						//21
	fwrite(pte_tlf01->pos_condition_code, 1 ,	sizeof(pte_tlf01->pos_condition_code),		dbfFilePtr);					//23
	fwrite(pte_tlf01->retrieval_ref_num, 1 ,	sizeof(pte_tlf01->retrieval_ref_num),		dbfFilePtr);					//26
	fwrite(pte_tlf01->orig_retrieval_ref_num, 1,sizeof(pte_tlf01->orig_retrieval_ref_num),	dbfFilePtr);					//27
	fwrite(pte_tlf01->merchant_id, 1 ,			sizeof(pte_tlf01->merchant_id),		dbfFilePtr);							//28
	fwrite(pte_tlf01->orig_message, 1 ,			sizeof(pte_tlf01->orig_message),		dbfFilePtr);						//29
	fwrite(pte_tlf01->settlement_total, 1 ,		sizeof(pte_tlf01->settlement_total),		dbfFilePtr);					//30
	fwrite(pte_tlf01->message_type, 1 ,			sizeof(pte_tlf01->message_type),		dbfFilePtr);						//31
	fwrite(pte_tlf01->card_holder_name, 1 ,		sizeof(pte_tlf01->card_holder_name),		dbfFilePtr);					//32
	if(pte_tlf01->general_status == 0x00)
	{
		pte_tlf01->general_status = 0x20;
	}
	fprintf(dbfFilePtr,"%02d",pte_tlf01->general_status);
	fwrite(pte_tlf01->batch_number, 1 ,			sizeof(pte_tlf01->batch_number),		dbfFilePtr);						//36
	fwrite(pte_tlf01->response_code, 1 ,		sizeof(pte_tlf01->response_code),		dbfFilePtr);						//37
	fwrite(pte_tlf01->date_yyyymmdd, 1 ,		sizeof(pte_tlf01->date_yyyymmdd),		dbfFilePtr);						//38
	fwrite(pte_tlf01->time_hhmmss, 1 ,			sizeof(pte_tlf01->time_hhmmss),		dbfFilePtr);							//39
	fwrite(pte_tlf01->tran_start_time, 1 ,		sizeof(pte_tlf01->tran_start_time),		dbfFilePtr);						//51
	fwrite(pte_tlf01->host_start_time, 1 ,		sizeof(pte_tlf01->host_start_time),		dbfFilePtr);						//52
	fwrite(pte_tlf01->host_finish_time, 1 ,		sizeof(pte_tlf01->host_finish_time),		dbfFilePtr);					//53
	fwrite(pte_tlf01->tran_finish_time, 1 ,		sizeof(pte_tlf01->tran_finish_time),		dbfFilePtr);					//54
	fwrite(pte_tlf01->agent_id, 1 ,				sizeof(pte_tlf01->agent_id),			dbfFilePtr);						//63
	if(pte_tlf01->cvc == 0x00)
	{
		pte_tlf01->cvc = ' ';
	}
	fprintf(dbfFilePtr,"%c",pte_tlf01->cvc);
	fwrite(pte_tlf01->settlement_date, 1 ,			sizeof(pte_tlf01->settlement_date),		dbfFilePtr);						//65
	fwrite(pte_tlf01->category_code, 1 ,			sizeof(pte_tlf01->category_code),		dbfFilePtr);						//66
	fwrite(pte_tlf01->conversion_rate, 1 ,			sizeof(pte_tlf01->conversion_rate),		dbfFilePtr);						//67
	fwrite(pte_tlf01->product_code, 1 ,				sizeof(pte_tlf01->product_code),		dbfFilePtr);						//68
	fwrite(pte_tlf01->acquiring_id, 1 ,				sizeof(pte_tlf01->acquiring_id),		dbfFilePtr);					//85
	fwrite(pte_tlf01->outstanding_balance, 1 ,		sizeof(pte_tlf01->outstanding_balance),	dbfFilePtr);					//86
	fwrite(pte_tlf01->credit_limit, 1 ,				sizeof(pte_tlf01->credit_limit),	dbfFilePtr);					//86
	fwrite(pte_tlf01->origin, 1 ,					sizeof(pte_tlf01->origin),			dbfFilePtr);						//92
	fwrite(pte_tlf01->interest_rate, 1 ,			sizeof(pte_tlf01->interest_rate),		dbfFilePtr);					//99
	fwrite(pte_tlf01->total_interest, 1 ,			sizeof(pte_tlf01->total_interest),		dbfFilePtr);					//100
	fwrite(pte_tlf01->profile, 1 ,					sizeof(pte_tlf01->profile),			dbfFilePtr);						//103
	fwrite(pte_tlf01->nbr_of_prod_codes, 1 ,		sizeof(pte_tlf01->nbr_of_prod_codes),		dbfFilePtr);				//104
	fwrite(pte_tlf01->product1_code, 1 ,			sizeof(pte_tlf01->product1_code),		dbfFilePtr);					//105
	fwrite(pte_tlf01->product1_quantity, 1 ,		sizeof(pte_tlf01->product1_quantity),		dbfFilePtr);				//106
	fwrite(pte_tlf01->product1_amount, 1 ,			sizeof(pte_tlf01->product1_amount),		dbfFilePtr);					//107
	fwrite(pte_tlf01->visa_merchant_id, 1 ,			sizeof(pte_tlf01->visa_merchant_id),		dbfFilePtr);				//165
	fwrite(pte_tlf01->deferred_factor, 1 ,			sizeof(pte_tlf01->deferred_factor),		dbfFilePtr);					//167
	fwrite(pte_tlf01->deferred_term_length, 1 ,		sizeof(pte_tlf01->deferred_term_length),	dbfFilePtr);				//168
	fwrite(pte_tlf01->currency_code, 1 ,			sizeof(pte_tlf01->currency_code),		dbfFilePtr);					//169
	fwrite(pte_tlf01->transmission_timestamp, 1 ,	sizeof(pte_tlf01->transmission_timestamp),	dbfFilePtr);				//170
	fwrite(pte_tlf01->cvc_data, 1 ,					sizeof(pte_tlf01->cvc_data),			dbfFilePtr);					//172
	fwrite(pte_tlf01->verify_mag_stripe, 1 ,		sizeof(pte_tlf01->verify_mag_stripe),		dbfFilePtr);				//173
	fwrite(pte_tlf01->security_response_code, 1 ,	sizeof(pte_tlf01->security_response_code),	dbfFilePtr);				//175
	fwrite(pte_tlf01->service_code, 1 ,				sizeof(pte_tlf01->service_code),		dbfFilePtr);					//176
	fwrite(pte_tlf01->voice_auth, 1 ,				sizeof(pte_tlf01->voice_auth),			dbfFilePtr);					//179
	fwrite(pte_tlf01->actual_amount, 1 ,			sizeof(pte_tlf01->actual_amount),		dbfFilePtr);					//180
	fwrite(pte_tlf01->reversal_amount, 1 ,			sizeof(pte_tlf01->reversal_amount),		dbfFilePtr);					//181
	fwrite(pte_tlf01->voice_auth_text, 1 ,			sizeof(pte_tlf01->voice_auth_text),		dbfFilePtr);					//182
	fwrite(pte_tlf01->operator_id, 1 ,				sizeof(pte_tlf01->operator_id),		dbfFilePtr);						//183
	fwrite(pte_tlf01->orig_auth_number, 1 ,			sizeof(pte_tlf01->orig_auth_number),		dbfFilePtr);				//185
	fwrite(pte_tlf01->system_date, 1 ,				sizeof(pte_tlf01->system_date),		dbfFilePtr);						//187
	fwrite(pte_tlf01->monthly_amort_amt, 1 ,		sizeof(pte_tlf01->monthly_amort_amt),		dbfFilePtr);				//189
//char sep = 0x20;
//fwrite(&sep, 1, 1, dbfFilePtr);
	return TRUE;
}

  /*****************************************************************************
  *                                                                            *
  *  Except for main and MainProcessor, functions are in alphabetical order.   *
  *                                                                            *
  *****************************************************************************/
  void ascii_to_bin (pBYTE src, pBYTE dst, INT len)
  {
	  INT  i, j, k;
	  for (i = 0; i < (len*2); i+=2)
	  {
		  /* if I hit a null terminator, quit.  */
		  if (src[i] == '\0')
			  break;
		  /* if these are leading blanks, leave the bcd zero.  */
		  if (src[i] != ' ')
		  {
			  if (src[i] <= '9')
				  dst[i/2] = ((src[i]-'0')*16);
			  else
				  dst[i/2] = ((src[i]-'A')+0x0A)*16;   /* handle 0a-0f */
		  }
		  if (((i+1) < (len*2)) && (src[i+1] != ' '))
		  {
			  if (src[i+1] <= '9')
				  dst[i/2] += (src[i+1]-'0');
			  else
			  {
				  j         = (toupper(src[i+1]) - 'A');
				  k         = j + 0x0A;
				  dst[i/2] += k;
			  }
		  }
	  }
  } /* ascii_to_bin */




	/*******************************************************************************
	*
	*  FUNCTION:         EndProcess
	*
	*  DESCRIPTION:      This function does shutdown and clean up functionalities.
	*
	*  INPUTS:           None
	*
	*  OUTPUTS:          None
	*
	*  RETURN VALUE:     BOOLEAN true for success or false for failure.
	*
	*  AUTHOR:           Irene Goldfild
	*
  *******************************************************************************/
  void EndProcess(void)
  {
	  CHAR Buffer[100] = "";

	  if ( EndProcessFlag == true )
	  {
		  //      sprintf( Buffer, "Shutting down the %s Service, version %s",
		  //               AppName, Version );
		  //      LogEvent( Buffer, INFO_MSG );
		  //      strcat( Buffer, "\n" );
		  //      PRINT( Buffer );
	  }
	  else
	  {
		  EndProcessFlag = true;
	  }
	  return;

  } /* EndProcess */
