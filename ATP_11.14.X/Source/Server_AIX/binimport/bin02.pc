/*******************************************************************************
*  
* MODULE:      bin02.pc
*  
* TITLE:       
*  
* DESCRIPTION: Ascendent import Processor.  This application takes an ASCII file,
*              parses it, populates the BIN02 table.
*
* APPLICATION: Equitable
*
* AUTHOR:  Sreerama Velaga 04/10/2000
*
* REVISION HISTORY:
*
* 
*   File
* Revision   Date   By  Description
* -------- -------- --- -----------
  1.9      04/09/07 DI  1. Changed commits from every 1,000 to 10,000. This
                           gives a 32% savings in time during heavy volume.
                        2. Changed "delete bin02" to "truncate table bin02".
                           This cuts table cleanup prior to import over 3 mins.

                                +---------+-------------+----------+
                                | BIN02   | No Activity | Activity |
                                |---------+-------------+----------|
                                | 1,000   |  4:19       |  10:15   |
                                |10,000   |  4:06       |   7:29   |
                                |Delete   |  2.34       |   3:22   |
                                |Truncate |  0:03       |   0:03   |
                                +---------+-------------+----------+


  $Log:   N:\POS\PVCS6.6\EPICPORTZ\PTE\Equitable\bin02import\bin02.pc  $
   
      Rev 1.8   Apr 05 2005 14:07:04   dirby
   Updated version to 4.4.1.1
   SCR 12785
   
      Rev 1.7   Jul 08 2004 16:30:12   dirby
   Updated version to 4.4.0.1
   SCRs 1287 & 1388
   
      Rev 1.6   May 27 2004 17:00:16   dirby
   Updated version to 4.3.0.1
   SCR 1380
   
      Rev 1.5   Feb 19 2003 16:14:02   dirby
   Updated version to 4.2.0.1
   SCR 955
   
      Rev 1.4   Aug 22 2002 11:57:42   dirby
   Updated version to 4.1.1.1
   SCR 255
   
      Rev 1.3   May 02 2002 11:19:34   dirby
   1.  Added logging of start and end time to dump file.
   2.  Made change to not process a 1 byte record, because it is a new line character.
   3.  Enhanced error message of SQL Return code -1 to be a duplicate primary key.
   SCR 680
   
      Rev 1.2   May 01 2002 17:10:06   dirby
   Made lots of changes to improve this application:
   1.  Updated version to 4.0.2.1
   2.  Pre-calculated some constants that are used for each import record.
   3.  Gave more information on error messages.
   4.  Put banner in dump file.
   5.  Summarized the activity at end of dump file.
   6.  Reworked PopulateBin02Table to be more efficient.
   SCR 680
   
      Rev 1.1   Jan 09 2001 13:45:44   dirby
    
   
      Rev 1.0   Apr 10 2000 15:58:28   svelaga
   Initial Release 1.0
*
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

EXEC SQL INCLUDE sqlca.h;


#include "ntutils.h"
#include "app_info.h"
#include "equitdb.h"
#include "tx_dbstruct.h"
#include "nc_dbstruct.h"
#include "dc_dbstruct.h"
#include "ptetime.h"

#include "txutils.h"


#define RECORD_LENGTH  82
#define UID "equitable"
#define PWD "equitable"
#define ALIAS "equitable"

#define DEFAULT_QUE_NAME "ncvisa"


EXEC SQL BEGIN DECLARE SECTION;


char db_uid[21];
char db_pwd[21];
char db_alias[21];
varchar sqlstmt[2048];
int commit_count = 0;

EXEC SQL END DECLARE SECTION;

char error_msg[1000];
FILE *fptr;
FILE *dumpPtr;

char dest_que_name[11];
char Version[] = "ATP_11.1.0";


static void populateBin02Table(char dataRecord[]);
static void insert_newBin02Records();
INT         delete_oldBin02Records();
void        read_parms ();

BIN02 bin02;

INT  dataRecord_size = RECORD_LENGTH + 10;
INT  bin02_size;
INT  bin02_bin_len_size;
INT  bin02_lo_size;
INT  bin02_high_size;
INT  bin02_pan_len_size;
INT  bin02_dest_name_size;
INT  bin02_desc_size;

/* Offsets into Import record */
INT  offset_length;
INT  offset_lo;
INT  offset_pan_len;

/* Statistics */
LONG num_recs_read_from_file;
LONG num_recs_successfully_inserted;
LONG num_recs_failed;

/* This flag is used to put a banner at the start of the dump file. */
INT  first_error = true;

/* These fields are populated only in case of error.
 * On errors, they get stored in the dump file.
 */
CHAR sequence_number[7];
CHAR segment_number;

/* Buffer of data for dump file. */
CHAR  dmp_file_buffer[1000];

/* Start and End Times of Import */
CHAR  Start_Time[25] = "";
CHAR  End_Time  [25] = "";


/******************************************************************************
       NAME:           main

       DESCRIPTION:    This module is the entry point for the application.

       INPUTS:         argv[1] is the name of the ascii file to import.
            None.
       OUTPUTS:
            None.       
       RETURNS:        
            None.                       

      AUTHOR:         
      MODIFIED BY:    None.
*******************************************************************************/
void main( int argc, char *argv[] )
{
   CHAR dataRecord[RECORD_LENGTH + 10];
   CHAR xipcinstance_name[30] = {0}, app_name[12] = {0};
   CHAR temp_str[256] = {0};
   CHAR dump_file_name[128];

   INT  EndProcessImport = 0;
   CHAR tempMsg[100] = {0};
   INT  ret_code;


   InitEventLogging();
   sprintf(error_msg,"Starting Visa/PLUS Bin file load, version %s\n", Version);
   LogEvent(error_msg,INFO_MSG);

   if (0 == strcmp(argv[1],"?"))
   {
      printf("\nbinimport filename \n");
      printf("Example: binimport  /Ascendent/ascendent/import/Plusbn.txt\n");
      exit( 0 );
   }

   if( argc != 2 )
   {
      sprintf(error_msg,"Shutting down - filename is a required parameter\n");
      LogEvent(error_msg,WARN_MSG);
      exit( 0 );
   }

   /* Get Start Time */
   ptetime_get_timestamp( Start_Time );

   if (NULL == (fptr = fopen(argv[1],"r")))
   {
      sprintf(error_msg , "Can not open the file %s.",argv[1]);
      LogEvent(error_msg,WARN_MSG);
      sprintf(error_msg , "Stopping Visa/PLUS Bin file load");
      LogEvent(error_msg,INFO_MSG);
      exit(0);
   }

   sprintf(dump_file_name,"%s.dmp",argv[1]);
   dumpPtr = fopen(dump_file_name,"w");
   if (dumpPtr == NULL)
   {
      printf("Error: Can't open the dump.txt file.\n");
      exit(0);
   } 

   /* Pre-calculate some constants that are used often. */
   bin02_size = sizeof( BIN02 );
   bin02_bin_len_size   = sizeof( bin02.primary_key.length );
   bin02_lo_size        = sizeof( bin02.primary_key.lo     );
   bin02_high_size      = sizeof( bin02.high               );
   bin02_pan_len_size   = sizeof( bin02.pan_length         );
   bin02_dest_name_size = sizeof( bin02.destination_name   );
   bin02_desc_size      = sizeof( bin02.description        );

   /* Calculate the offsets to fields in the Import record. */
   offset_pan_len = 7;
   offset_length  = 9;
   offset_lo      = 11;

   /* Initialize the statistic counters. */
   num_recs_read_from_file        = 0;
   num_recs_successfully_inserted = 0;
   num_recs_failed                = 0;

   memset( sequence_number, 0x00, sizeof(sequence_number) );

   /* Connecting to database */
   strcpy(db_uid,UID);
   strcpy(db_pwd,PWD);
   strcpy(db_alias,ALIAS);
   printf("Trying to connect to database...");


   EXEC SQL CONNECT :db_uid IDENTIFIED BY :db_pwd  using :db_alias;
   if(sqlca.sqlcode == 0)
      printf("Connected to database \n");
   else 
   {
      printf("Unable to connecet to database \n");
      sprintf(error_msg , "Cannot connect to the database");
      LogEvent(error_msg,WARN_MSG);
      sprintf(error_msg , "Stopping Visa/PLUS Bin file load");
      LogEvent(error_msg,INFO_MSG);
   }

   /* Delete all the records from bin02  */
   ret_code = delete_oldBin02Records();

   if(ret_code == 1)
   {
      printf(" unable to delete the old records \n");
      sprintf(error_msg , "Unable to delete bin02 table.");
      LogEvent(error_msg,WARN_MSG);
      sprintf(error_msg , "Stopping Visa/PLUS Bin file load");
      LogEvent(error_msg,INFO_MSG);
      exit(0);
   }

   read_parms();
   printf( " Importing . . .\n" );
   while(!EndProcessImport)
   {
      /* Read a record.  If there is any problem Quit. */
      memset( &dataRecord, 0x00, dataRecord_size );
      if (NULL == fgets(dataRecord,RECORD_LENGTH ,fptr))
      {
         EndProcessImport = 1;
         break;
      }

      /* Do this check in case a newline character is read. */
      else if ( strlen(dataRecord) > 1 )
      {
         (void)populateBin02Table(dataRecord);

         /*insert the bin02 record. */
         insert_newBin02Records();

         num_recs_read_from_file++;
      }
   }

   EXEC SQL COMMIT;
   printf( "Imported %d records.\n",  num_recs_successfully_inserted );

   /* Put summary of counts at the end of the dump file. */
   memset( dmp_file_buffer, 0x00, sizeof(dmp_file_buffer) );
   strcpy( dmp_file_buffer, "\n\nSUMMARY:\n" );
   fputs( dmp_file_buffer, dumpPtr );

   /* Number of records successfully inserted into BIN02 */
   memset( dmp_file_buffer, 0x00, sizeof(dmp_file_buffer) );
   sprintf( dmp_file_buffer,
           "     %6ld  Records successfully inserted\n",
            num_recs_successfully_inserted );
   fputs( dmp_file_buffer, dumpPtr );

   /* Number of records that failed to insert */
   memset( dmp_file_buffer, 0x00, sizeof(dmp_file_buffer) );
   sprintf( dmp_file_buffer,
           "     %6ld  Records failed\n",
            num_recs_failed );
   fputs( dmp_file_buffer, dumpPtr );

   /* Number of records read from file */
   memset( dmp_file_buffer, 0x00, sizeof(dmp_file_buffer) );
   sprintf( dmp_file_buffer,
           "     %6ld  Records read from file\n\n",
            num_recs_read_from_file );
   fputs( dmp_file_buffer, dumpPtr );

   /* Log the End (and maybe start) time to Dump File. */
   if ( first_error == true )
   {
      memset( dmp_file_buffer, 0x00, sizeof(dmp_file_buffer) );
      sprintf( dmp_file_buffer, "Start Time:  %s\n", Start_Time );
      fputs( dmp_file_buffer, dumpPtr );
   }
   ptetime_get_timestamp( End_Time );
   memset( dmp_file_buffer, 0x00, sizeof(dmp_file_buffer) );
   sprintf( dmp_file_buffer, "End   Time:  %s\n", End_Time );
   fputs( dmp_file_buffer, dumpPtr );

   printf(" inserting new records completed \n");
   fclose(fptr);
   fclose(dumpPtr);

   sprintf( error_msg,
           "Ascendent Visa/PLUS Bin file load complete, version %s",
            Version);
   LogEvent(error_msg,INFO_MSG);

   ShutDownEventLogging();
}



static void populateBin02Table(char dataRecord[])
{
   INT bin_length;

   memset( &bin02 ,0x00, bin02_size );

   memcpy( sequence_number, dataRecord, 6 );
   segment_number = dataRecord[6];

   strncpy( bin02.pan_length,
            dataRecord + offset_pan_len,
            bin02_pan_len_size-1 );

   strncpy( bin02.primary_key.length,
            dataRecord + offset_length,
            bin02_bin_len_size-1 );

   bin_length = atoi(bin02.primary_key.length);
   if (0 == bin_length)
   {
      /* This guarantees that 'something' will go to the database.  Since the 
       * bin02.primary_key.length == 0, this record won't be used, but putting
       * this code in prevents an error when inserting bin02.
       */
      bin_length = 1;
   }

   strncpy( bin02.primary_key.lo,
            dataRecord + offset_lo,
            bin_length );

   strncpy( bin02.high,
            bin02.primary_key.lo,
            bin_length );

   strcpy(bin02.destination_name, dest_que_name);
   return;
}


/******************************************************************************
 NAME:               delete_oldBin02Records

 DESCRIPTION:        deletes the old data records from Bin02 table.

 INPUTS :   none    
 OUTPUTS:   none
 RETURNS:   0 for Success
            1 for failure

 AUTHOR:     Sreerama Velaga        
*******************************************************************************/
int delete_oldBin02Records()
{
   printf(" Deleting the old BIN02 table records... \n");

   sprintf(sqlstmt.arr,"truncate table bin02 ");
   sqlstmt.len = strlen(sqlstmt.arr);
   EXEC SQL PREPARE S FROM :sqlstmt;
   EXEC SQL EXECUTE S;

   if(sqlca.sqlcode == 0)
   {
      printf(" Old records are deleted from bin02 table \n");
      EXEC SQL COMMIT;
      return 0;
   }
   else if(sqlca.sqlcode == 1403)
   {
      printf(" No old records were found with the specified card_type\n");
      EXEC SQL COMMIT;
      return 0;
   }
   EXEC SQL COMMIT RELEASE;
   return 1;
}


/******************************************************************************
 NAME:               insert_newBin02Records

 DESCRIPTION:        Inserts new data record parsed from
                     bin02 file into bin02 table.

 INPUTS:    none
    
 OUTPUTS:   none

 RETURNS:   none
          
 AUTHOR:     Sreerama Velaga        
*******************************************************************************/
static void insert_newBin02Records()
{
   EXEC SQL BEGIN DECLARE SECTION;
   int i=0;
   char length[3];
   char lo[17];
   char high[17];
   char pan_length[3];
   char destination_name[11];
   EXEC SQL END DECLARE SECTION;

   strcpy(length, bin02.primary_key.length);
   strcpy(lo, bin02.primary_key.lo);
   strcpy(high, bin02.high);
   strcpy(destination_name, bin02.destination_name);
   strcpy(pan_length, bin02.pan_length);

   EXEC SQL INSERT INTO BIN02 (length, lo, high, pan_length,destination_name)
            VALUES(:length,:lo,:high,:pan_length,:destination_name);

   if(sqlca.sqlcode != 0)
   {
      num_recs_failed++;
      memset( dmp_file_buffer, 0x00, sizeof(dmp_file_buffer) );
      if ( first_error == true )
      {
         first_error = false;

         /* Log the Import start time to the dump file. */
         sprintf( dmp_file_buffer, "Start Time:  %s\n\n", Start_Time );
         fputs( dmp_file_buffer, dumpPtr );

         /* Log the Dump file Banner. */
         strcpy( dmp_file_buffer,
                "SEQ#   SEG  Pan Len  Bin Len  Bin Number    Failure Reason\n");
         fputs( dmp_file_buffer, dumpPtr );

         memset( dmp_file_buffer, 0x00, sizeof(dmp_file_buffer) );
         strcpy( dmp_file_buffer,
                "------ ---  -------  -------  ------------  --------------\n");
         fputs( dmp_file_buffer, dumpPtr );
      }

      if ( -1 == sqlca.sqlcode )
      {
         sprintf( dmp_file_buffer,
                 "%6s  %c     %2s       %2s     %12s  %s\n",
                  sequence_number,
                  segment_number,
                  bin02.pan_length,
                  bin02.primary_key.length,
                  bin02.primary_key.lo,
                 "Unique constraint violation - Duplicate Bin Length & Bin Number" );

         fputs( dmp_file_buffer, dumpPtr );
         fflush(dumpPtr);

         printf( "sqlcode = -1 => Duplicate Bin Length and Bin Number\n" );
      }
      else
      {
         sprintf( dmp_file_buffer,
                 "%6s  %c     %2s       %2s     %12s  %s\n",
                  sequence_number,
                  segment_number,
                  bin02.pan_length,
                  bin02.primary_key.length,
                  bin02.primary_key.lo,
                  sqlca.sqlerrm.sqlerrmc );

         fputs( dmp_file_buffer, dumpPtr );
         fflush(dumpPtr);

         printf("sqlcode = %d\n", sqlca.sqlcode );
      }
      printf("Unable to insert record: sequence # = %s, length = %s, bin = %s\n",
              sequence_number,
              bin02.primary_key.length, bin02.primary_key.lo );
   }
   else
   {
      num_recs_successfully_inserted++;
   }

   commit_count++;
   if( commit_count == 10000 )
   {
      EXEC SQL COMMIT;
      printf("Imported %d records. Length = %s, lo = %s\n",
              num_recs_successfully_inserted,
              bin02.primary_key.length, bin02.primary_key.lo );
      commit_count = 0;
   }
   return;
}

/******************************************************************************
 *  NAME:           read_parms
 *
 *  DESCRIPTION:    This function reads the "bin02.ini" file in the
 *                  ascendent\config directory (if the file is there)
 *                  for the parameter that indicates the network destination
 *                  name for bin02 records.  The INI file should have:
 *                  "Directory=".  If the INI is not there OR the parameters
 *                  are not there, this function  will default the values.
 *
 *  INPUTS:         None
 *
 *  OUTPUTS:        dest_que_name - (Global) Name of network controller where
 *                                  Plus transactions will be routed to
 *
 *  RETURNS:        None
 *
 *  AUTHOR:         Unknown  
 *
 *  MODIFIED BY:    Irene Goldfild
 ******************************************************************************/
void read_parms ()
{
   CHAR ini_file [256];

   printf ("Read parameters from INI file\n");

   /*** Get Config directory ***/
   GetPinnacleConfigDirectory (ini_file);
   strcat (ini_file, "bin02.ini");
  
   /*** Get profile string ***/
   GetPrivateProfileString ("DESTINATION",             /* section name       */
                            "destinationquename",      /* key name           */
                            DEFAULT_QUE_NAME,          /* default value      */
                            dest_que_name,             /* destination buffer */
                            sizeof(dest_que_name) - 1, /* size of buffer     */
                            ini_file);                 /* ini filename       */
   return;
}

