/******************************************************************************
  
   Module:           nc_database.pc
  
   Title:            Network Control Dataserver DB Routines
  
   Description:
   
   Application:      ATP

   Author:           Various

******************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef WIN32
#include <sqlproto.h>
#endif

#include <math.h>
#include <time.h>
#include <sys/timeb.h>

#include "basictyp.h"
#include "app_info.h"
#include "pte.h"
#include "pteipc.h"
#include "ptemsg.h"
#include "ptetimer.h"
#include "equitdb.h"
#include "nc_dbstruct.h"
#include "nc_database.h"
#include "dbcommon.h"
#include "txutils.h"
#include "ptetime.h"
#include "ntutils.h"
#include "memmnger.h"
#include "tx_dbstruct.h"

#define PESO  "608"
#define AMEX03A
/* Function prototypes */
extern long Txutils_Calculate_Julian_Date(BYTE * );
extern void Txutils_Calculate_Gregorian_Date(LONG , pCHAR );
extern void genutil_format_date(pCHAR temp);

/* Oracle error codes */
#define NULL_COLUMN_DATA -1405
#define NO_DATA_FOUND     1403

extern CHAR AppName[];
SQL01  Sql01;
INT    rtnval;


/* For DB statics added by raghu */
extern BYTE DB_MsgSubtype2 ;
extern BYTE DB_MsgSubtype1 ;
char DB_Tmr_Lgng_Buf[512];
double start_time;
double end_time  ;
double duration  ; 
extern INT db_error_statics_flag;
extern double db_error_statics_value;
char er_buf[512];
BYTE DB_rcode;
extern CHAR  DB_Logging_Filename[256];
extern CHAR  DB_module_file_name[256];
extern CHAR  DB_file_path[256];
extern INT LOOKBACK_DAYS;
/* End   */



EXEC SQL INCLUDE sqlca;

typedef struct
{
   WORD len;
   BYTE pin_data[100];
}RAWPINDATA;

EXEC SQL BEGIN DECLARE SECTION;

   /* error code variable */
   long    SQLCODE;
   long    SQL_CODE;

/**/
EXEC SQL TYPE RAWPINDATA is VARRAW(5000);

 struct
 {
   char network_id                                 [11];
   char network_type                               [2];

   char  name                                      [30];
   char  status                                    [2];
   char  totals_ind                                [2];
   char  statistics_ind                            [2];
   char  acquirer_inst_id_code                     [12];
   char  forwarding_inst_id_code                   [12];
   char  receiving_inst_id_code                    [12];
   char  remote_nsp_type                           [2];
   char  pin_type                                  [2];
   char  encr_type                                 [2];
   char  pad_char                                  [2];
   char  cwk                                       [49];
   char  kek                                       [17];
   char  retired_cwk                               [49];
   char  auto_logon                                [2];
   char  echo_interval                             [4];
   char  max_consecutive_timeouts                  [4];
   char  max_active_txns                           [4];
   char  que_name                                  [12];
   char  local_nsp_type                            [8];
   char  request_timer                             [4];
   char  idle_line_timer                           [4];
   char  advice_repeat_counter                     [3];
   char  admin_message_timer                       [4];
   char  store_forward_processing                  [2];
   char  currency_code_purchase                    [4];
   char  currency_code_cash                        [4];
   char  country_code                              [4];
   char  station_id1                               [7];
   char  station_id2                               [7];
   char  prev_src_station                          [7];
   char  tpdu_id                                   [16];
   
   char  identifier1                               [7];
   char  identifier2                               [7];
   char  identifier3                               [7];
   char  identifier4                               [7];
   char  identifier5                               [7];
   char  identifier6                               [7];
   char  identifier7                               [7];
   char  identifier8                               [7];
   char  identifier9                               [7];
   char  identifier10                              [7];
   
   char  processing_code1                          [7];
   char  processing_code2                          [7];
   char  processing_code3                          [7];
   char  processing_code4                          [7];
   char  processing_code5                          [7];
   char  processing_code6                          [7];
   char  processing_code7                          [7];
   char  processing_code8                          [7];
   char  processing_code9                          [7];
   char  processing_code10                         [7];
   char  processing_code11                         [7];
   char  processing_code12                         [7];
   char  processing_code13                         [7];
   char  processing_code14                         [7];
   char  processing_code15                         [7];
   char  processing_code16                         [7];
   char  processing_code17                         [7];
   char  processing_code18                         [7];
   char  processing_code19                         [7];
   char  processing_code20                         [7];
   char  zmk                                       [49];
   char  neg_access_code                           [7];
      
} pte_ncf01;

struct
 {
   varchar network_id                              [11];
   varchar network_type                            [2];

   varchar  name                                   [30];
   varchar  status                                 [2];
   varchar  totals_ind                             [2];
   varchar  statistics_ind                         [2];
   varchar  acquirer_inst_id_code                  [12];
   varchar  forwarding_inst_id_code                [12];
   varchar  receiving_inst_id_code                 [12];
   varchar  remote_nsp_type                        [2];
   varchar  pin_type                               [2];
   varchar  encr_type                              [2];
   varchar  pad_char                               [2];
   varchar  cwk                                    [49];
   varchar  kek                                    [17];
   varchar  retired_cwk                            [49];
   varchar  auto_logon                             [2];
   varchar  echo_interval                          [4];
   varchar  max_consecutive_timeouts               [4];
   varchar  max_active_txns                        [4];
   varchar  que_name                               [12];
   varchar  local_nsp_type                         [8];
   varchar  request_timer                          [4];
   varchar  idle_line_timer                        [4];
   varchar  advice_repeat_counter                  [3];
   varchar  admin_message_timer                    [4];
   varchar  store_forward_processing               [2];
   varchar  currency_code_purchase                 [4];
   varchar  currency_code_cash                     [4];
   varchar  country_code                           [4];
   varchar  station_id1                            [7];
   varchar  station_id2                            [7];
   varchar  prev_src_station                       [7];
   varchar  tpdu_id                                [16];
   
   varchar  identifier1                            [7];
   varchar  identifier2                            [7];
   varchar  identifier3                            [7];
   varchar  identifier4                            [7];
   varchar  identifier5                            [7];
   varchar  identifier6                            [7];
   varchar  identifier7                            [7];
   varchar  identifier8                            [7];
   varchar  identifier9                            [7];
   varchar  identifier10                           [7];
   
   varchar  processing_code1                       [7];
   varchar  processing_code2                       [7];
   varchar  processing_code3                       [7];
   varchar  processing_code4                       [7];
   varchar  processing_code5                       [7];
   varchar  processing_code6                       [7];
   varchar  processing_code7                       [7];
   varchar  processing_code8                       [7];
   varchar  processing_code9                       [7];
   varchar  processing_code10                      [7];
   varchar  processing_code11                      [7];
   varchar  processing_code12                      [7];
   varchar  processing_code13                      [7];
   varchar  processing_code14                      [7];
   varchar  processing_code15                      [7];
   varchar  processing_code16                      [7];
   varchar  processing_code17                      [7];
   varchar  processing_code18                      [7];
   varchar  processing_code19                      [7];
   varchar  processing_code20                      [7];
   varchar  zmk                                    [49];
   varchar  neg_access_code                        [7];

} db_ncf01;

struct
{
   char network_id                              [11];
   char network_type                            [2];
   
   char  credit_cnt                             [5];
   char  credit_reversal_cnt                    [5];
   char  debit_cnt                              [5];
   char  debit_reversal_cnt                     [5];
   char  transfer_cnt                           [5];
   char  transfer_reversal_cnt                  [5];
   char  inquiries_cnt                          [5];
   char  authorizations_cnt                     [5];
   char  credit_proc_fee_amt                    [13];
   char  credit_tran_fee_amt                    [13];
   char  debit_proc_fee_amt                     [13];
   char  debit_tran_fee_amt                     [13];
   char  credit_amt                             [13];
   char  credit_reversal_amt                    [13];
   char  debit_amt                              [13];
   char  debit_reversal_amt                     [13];
   char  net_settlement_amt                     [13];
} pte_ncf02;

struct
{
   varchar network_id                           [11];
   varchar network_type                         [2];
   
   varchar  credit_cnt                          [5];
   varchar  credit_reversal_cnt                 [5];
   varchar  debit_cnt                           [5];
   varchar  debit_reversal_cnt                  [5];
   varchar  transfer_cnt                        [5];
   varchar  transfer_reversal_cnt               [5];
   varchar  inquiries_cnt                       [5];
   varchar  authorizations_cnt                  [5];
   varchar  credit_proc_fee_amt                 [13];
   varchar  credit_tran_fee_amt                 [13];
   varchar  debit_proc_fee_amt                  [13];
   varchar  debit_tran_fee_amt                  [13];
   varchar  credit_amt                          [13];
   varchar  credit_reversal_amt                 [13];
   varchar  debit_amt                           [13];
   varchar  debit_reversal_amt                  [13];
   varchar  net_settlement_amt                  [13];
} db_ncf02;


struct
{
   char  network_id                             [10];
   char  yyyymmdd                               [9];

   char  ytd_total_tran_cnt                     [13];
   char  ytd_total_tran_amt                     [13];
   char  mtd_total_tran_cnt                     [13];
   char  mtd_total_tran_amt                     [13];
   char  tran_cnt                               [7];
   char  tran_amt                               [13];
   char  tran_approved_cnt                      [7];
   char  tran_declined_cnt                      [7];

   char category_code1                       [5];
   char category_cnt1                        [5];
   char category_code2                       [5];
   char category_cnt2                        [5];
   char category_code3                       [5];
   char category_cnt3                        [5];
   char category_code4                       [5];
   char category_cnt4                        [5];
   char category_code5                       [5];
   char category_cnt5                        [5];
   char category_code6                       [5];
   char category_cnt6                        [5];
   char category_code7                       [5];
   char category_cnt7                        [5];
   char category_code8                       [5];
   char category_cnt8                        [5];
   char category_code9                       [5];
   char category_cnt9                        [5];
   char category_code10                      [5];
   char category_cnt10                       [5];
   char category_code11                      [5];
   char category_cnt11                       [5];
   char category_code12                      [5];
   char category_cnt12                       [5];
   char category_code13                      [5];
   char category_cnt13                       [5];
   char category_code14                      [5];
   char category_cnt14                       [5];
   char category_code15                      [5];
   char category_cnt15                       [5];
   char category_code16                      [5];
   char category_cnt16                       [5];
   char category_code17                      [5];
   char category_cnt17                       [5];
   char category_code18                      [5];
   char category_cnt18                       [5];
   char category_code19                      [5];
   char category_cnt19                       [5];
   char category_code20                      [5];
   char category_cnt20                       [5];

} pte_ncf20;

struct
{
   varchar  network_id                      [10];
   varchar  yyyymmdd                         [9];

   varchar  ytd_total_tran_cnt              [13];
   varchar  ytd_total_tran_amt              [13];
   varchar  mtd_total_tran_cnt              [13];
   varchar  mtd_total_tran_amt              [13];
   varchar  tran_cnt                         [7];
   varchar  tran_amt                        [13];
   varchar  tran_approved_cnt                [7];
   varchar  tran_declined_cnt                [7];

   varchar category_code1                    [5];
   varchar category_cnt1                     [5];
   varchar category_code2                    [5];
   varchar category_cnt2                     [5];
   varchar category_code3                    [5];
   varchar category_cnt3                     [5];
   varchar category_code4                    [5];
   varchar category_cnt4                     [5];
   varchar category_code5                    [5];
   varchar category_cnt5                     [5];
   varchar category_code6                    [5];
   varchar category_cnt6                     [5];
   varchar category_code7                    [5];
   varchar category_cnt7                     [5];
   varchar category_code8                    [5];
   varchar category_cnt8                     [5];
   varchar category_code9                    [5];
   varchar category_cnt9                     [5];
   varchar category_code10                   [5];
   varchar category_cnt10                    [5];
   varchar category_code11                   [5];
   varchar category_cnt11                    [5];
   varchar category_code12                   [5];
   varchar category_cnt12                    [5];
   varchar category_code13                   [5];
   varchar category_cnt13                    [5];
   varchar category_code14                   [5];
   varchar category_cnt14                    [5];
   varchar category_code15                   [5];
   varchar category_cnt15                    [5];
   varchar category_code16                   [5];
   varchar category_cnt16                    [5];
   varchar category_code17                   [5];
   varchar category_cnt17                    [5];
   varchar category_code18                   [5];
   varchar category_cnt18                    [5];
   varchar category_code19                   [5];
   varchar category_cnt19                    [5];
   varchar category_code20                   [5];
   varchar category_cnt20                    [5];

} db_ncf20;


struct
{
   char  network_id              [11];
   char  network_type             [2];
   char  batch_number             [7];

   char  open_date                [9];
   char  open_time                [7];
   char  release_date             [9];
   char  release_time             [7];
   char  credit_cnt              [11];
   char  credit_amt              [17];
   char  credit_rev_cnt          [11];
   char  credit_rev_amt          [17];
   char  debit_cnt               [11];
   char  debit_amt               [17];
   char  debit_rev_cnt           [11];
   char  debit_rev_amt           [17];
   char  total_amt               [17];
   char  total_amt_type           [2];

} pte_ncf21;

struct
{
   varchar  network_id           [11];
   varchar  network_type          [2];
   varchar  batch_number          [7];

   varchar  open_date             [9];
   varchar  open_time             [7];
   varchar  release_date          [9];
   varchar  release_time          [7];
   varchar  credit_cnt           [11];
   varchar  credit_amt           [17];
   varchar  credit_rev_cnt       [11];
   varchar  credit_rev_amt       [17];
   varchar  debit_cnt            [11];
   varchar  debit_amt            [17];
   varchar  debit_rev_cnt        [11];
   varchar  debit_rev_amt        [17];
   varchar  total_amt            [17];
   varchar  total_amt_type        [2];

} db_ncf21;



struct
{
   char  network_id              [11];
   char  network_type             [2];
   char  batch_number             [7];
   char  retrieval_ref_num       [13];

   char  open_date                [9];
   char  open_time                [7];
   char  merchant_id             [16];
   char  transaction_id          [21];
   char  device_id                [9];
   char  card_nbr                [20];
   char  message_type             [5];
   char  processing_code          [7];
   char  tran_amount             [13];
   char  auth_number              [7];
   char  response_code            [3];
   char  tran_date                [9];
   char  tran_time                [7];
   char  sys_trace_audit_nbr      [7];
   char  tx_key                      ;
   char  invoice_nbr              [9];
   char  network_data            [13];
   char  currency_code            [4];
   char  acquiring_inst_id_code  [12];
   char  settlement_date          [5];
   char  transmission_timestamp  [11];
   char  tran_fee_amount         [10];

} pte_ncf30;

struct
{
   varchar  network_id             [11];
   varchar  network_type            [2];
   varchar  batch_number            [7];
   varchar  retrieval_ref_num      [13];

   varchar  open_date               [9];
   varchar  open_time               [7];
   varchar  merchant_id            [16];
   varchar  transaction_id         [21];
   varchar  device_id               [9];
   varchar  card_nbr               [20];
   varchar  message_type            [5];
   varchar  processing_code         [7];
   varchar  tran_amount            [13];
   varchar  auth_number             [7];
   varchar  response_code           [3];
   varchar  tran_date               [9];
   varchar  tran_time               [7];
   varchar  sys_trace_audit_nbr     [7];
   varchar  tx_key                  [1];
   varchar  invoice_nbr             [9];
   varchar  network_data           [13];
   varchar  currency_code           [4];
   varchar  acquiring_inst_id_code [12];
   varchar  settlement_date         [5];
   varchar  transmission_timestamp [11];
   varchar  tran_fee_amount        [10];

} db_ncf30;


struct
{
	char 	network_id            [11];
	char 	iss_cwk_keyblock	  [129];
	char 	iss_zmk_keyblock      [129];
	char 	iss_rtdcwk_keyblock   [129];
	char 	iss_kek_keyblock      [129];
	char 	acq_cwk_keyblock	  [129];
	char 	acq_zmk_keyblock      [129];
	char 	acq_kek_keyblock      [129];
	char 	iss_prev_src_station  [129];
	char 	future_field1		  [129];
	char 	future_field2		  [129];
	char 	future_field3		  [129];
	char 	future_field4		  [129];
	char 	future_field5		  [129];

}pte_ncf01_keyblock;

 struct
{
	varchar 	network_id            	[10];
	varchar 	iss_cwk_keyblock	 	[128];
	varchar 	iss_zmk_keyblock       	[128];
	varchar 	iss_rtdcwk_keyblock    	[128];
	varchar 	iss_kek_keyblock       	[128];
	varchar 	acq_cwk_keyblock	 	[128];
	varchar 	acq_zmk_keyblock       	[128];
	varchar 	acq_kek_keyblock       	[128];
	varchar 	iss_prev_src_station 	[128];
	varchar 	future_field1			[128];
	varchar 	future_field2			[128];
	varchar 	future_field3			[128];
	varchar 	future_field4			[128];
	varchar 	future_field5			[128];

}db_ncf01_keyblock;

struct
{
   char  card_nbr     [17];
   char  card_type     [2];
   char  card_exten    [4];
   char  card_status   [2];

} pte_neg01;

struct
{
   varchar  card_nbr     [17];
   varchar  card_type     [2];
   varchar  card_exten    [4];
   varchar  card_status   [2];

} db_neg01;



struct 
{
   char bkcb_name  [3];
   char termnumr   [9];
 
   char bourder    [3];
   char mnemonic   [5];
   char brchname  [16];
   char termsite   [4];
   char termaddr  [51];
   char termdist  [26];
   char termcimu  [26];
   char termprov  [26];
   char termregn   [7];
   char machtype  [21];
   char termodel  [11];
   char dateinst   [9];
   char termloc   [13];
   char termtype   [6];
   char refnum     [7];
   char linktype   [2];

} pte_atm01;

struct 
{
   varchar bkcb_name  [3];
   varchar termnumr   [9];
 
   varchar bourder    [3];
   varchar mnemonic   [5];
   varchar brchname  [16];
   varchar termsite   [4];
   varchar termaddr  [51];
   varchar termdist  [26];
   varchar termcimu  [26];
   varchar termprov  [26];
   varchar termregn   [7];
   varchar machtype  [21];
   varchar termodel  [11];
   varchar dateinst   [9];
   varchar termloc   [13];
   varchar termtype   [6];
   varchar refnum     [7];
   varchar linktype   [2];

} db_atm01;

 struct
 {
   char  transaction_id             [21];
   char  card_num                   [20];
   char  tran_amount                [13];
   char  device_id                   [9];
   char  message_type                [5];
   char  processing_code             [7];
   char  sys_trace_audit_nbr         [7];
   char  tran_date                   [9];
   char  tran_time                   [7];
   char  tx_key                         ;
   char  retrieval_ref_num          [13];
   char  merchant_id                [16];
   char  auth_number                 [7];
   char  response_code               [3];
   char  invoice_nbr                 [9];
   char  network_data               [52];
   char  currency_code               [4];
   char  transmission_timestamp     [11];
   char  exp_date                    [5];
   char  settlement_amount          [13];
   char  settlement_date             [5];
   char  settlement_conv_rate        [9];
   char  settlement_curr_code        [4];
   char  billing_amount             [13];
   char  billing_conv_rate           [9];
   char  billing_curr_code           [4];
   char  tran_fee_amount             [9];
   char  handler_queue               [8];
   char  acquiring_inst_id_code     [12];
   char  forwarding_inst_id_code    [12];
   char  reversal_amount            [13];
      
} pte_saf01;

struct
 {
   varchar  transaction_id             [21];
   varchar  card_num                   [20];
   varchar  tran_amount                [13];
   varchar  device_id                   [9];
   varchar  message_type                [5];
   varchar  processing_code             [7];
   varchar  sys_trace_audit_nbr         [7];
   varchar  tran_date                   [9];
   varchar  tran_time                   [7];
   varchar  tx_key                      [1];
   varchar  retrieval_ref_num          [13];
   varchar  merchant_id                [16];
   varchar  auth_number                 [7];
   varchar  response_code               [3];
   varchar  invoice_nbr                 [9];
   varchar  network_data               [52];
   varchar  currency_code               [4];
   varchar  transmission_timestamp     [11];
   varchar  exp_date                    [5];
   varchar  settlement_amount          [13];
   varchar  settlement_date             [5];
   varchar  settlement_conv_rate        [9];
   varchar  settlement_curr_code        [4];
   varchar  billing_amount             [13];
   varchar  billing_conv_rate           [9];
   varchar  billing_curr_code           [4];
   varchar  tran_fee_amount             [9];
   varchar  handler_queue               [8];
   varchar  acquiring_inst_id_code     [12];
   varchar  forwarding_inst_id_code    [12];
   varchar  reversal_amount            [13];

} db_saf01;


struct
{
   char  name           [11];
   char  type           [2];
   char  caller_id      [6];
   char  source         [31];
   char  username       [31];
   char  application    [21];
   char  rule_domain    [81];
   char  product        [31];
   char  priority       [5];
   char  tpdu_id        [12];
   char  queue_name     [16];
   char  request_timer  [4];
   char  echo_timer     [4];
      
} pte_fg01;

struct
{
   varchar  name           [11];
   varchar  type           [2];
   varchar  caller_id      [6];
   varchar  source         [31];
   varchar  username       [31];
   varchar  application    [21];
   varchar  rule_domain    [81];
   varchar  product        [31];
   varchar  priority       [5];
   varchar  tpdu_id        [12];
   varchar  queue_name     [16];
   varchar  request_timer  [4];
   varchar  echo_timer     [4];

} db_fg01;


struct
{
    char transaction_id                     [21]; 

    char entry_type                         ;
    char tpdu_id                            [16];
    char issuer_id                          [21];
    char acquirer_id                        [21];
    char tx_key                             ;
    char terminal_id                        [9];
    char terminal_type                      [3];
    char response_text                      [41];
    char card_num_len                       [3];
    char card_num                           [20];
    char exp_date                           [5];
    char total_amount                       [13];
    char add_amounts                        [25];
    char invoice_number                     [9];
    char orig_amount                        [13];
    char auth_number                        [7];
    char processing_code                    [7];
    char sys_trace_audit_num                [7];
    char orig_sys_trace_num                 [7];
    char pos_entry_mode                     [5];
    char nii                                [5];
    char pos_condition_code                 [3];
    char track1                             [77];
    char track2                             [38];
    char retrieval_ref_num                  [13];
    char orig_retrieval_ref_num             [13];
    char merchant_id                        [16];
    char orig_message                       [5];
    char settlement_total                   [17];
    char message_type                       [5];
    char card_holder_name                   [31];
    char general_status                     ;
    char originator_queue                   [17];
    char originator_info                    [33];
    char batch_number                       [7];
    char response_code                      [3];
    char date_yyyymmdd                      [9];
    char time_hhmmss                        [7];
    char num_sales                          [4];
    char sales_amount                       [13];
    char num_refunds                        [4];
    char refund_amount                      [13];
    char num_dbsales                        [4];
    char dbsales_amount                     [13];
    char num_dbrefunds                      [4];
    char dbrefund_amount                    [13];
    char pin_block                          [19];
    char tax_amount                         [13];
    char tip_amount                         [13];
    char tran_start_time                    [17];
    char host_start_time                    [17];
    char host_finish_time                   [17];
    char tran_finish_time                   [17];
    char settle_file_prefix                 [7];
    char resp_source_len                    [3];
    char visa_char_indicator                ;
    char visa_tran_id                       [16];
    char visa_validation_code               [5];
    char mcard_banknet_len                  [4];
    char mcard_banknet                      [51];
    char agent_id_len                       [4];
    char agent_id                           [12];
    char cvc                                ;
    char settlement_date                    [5];

    char category_code                      [5];
    char conversion_rate                    [10];
    char product_code                       [9];
    char odometer                           [8];
    char organization_id                    [5];
    char dynamic_keychange                  ;

   char source_key                         [49];
   char txn_cnt                            [4];
   char dcf01_retired_cwk                  [49];
   char dest_key                           [49];
   char ncf01_retired_cwk                  [49];
   char handler_queue                      [8];
   char authorizing_host_queue             [8];
   char max_net_consec_tmouts              [4];
   char max_active_txns                    [4];
   char forwarding_institution_id          [12];
   char remote_nsp_type                    [2];
   char kek                                [17]; 
   char acquiring_id                       [12];
   char outstanding_balance                [13]; 
   char credit_limit                       [13];
   char nfi_name                           [11];
   char nfi_seq_nbr                        [7];
   char nfi_start_date                     [9];
   char nfi_end_date                       [9];
   char resp_source                        [26];

   char origin                             [3];
   char auth_1                             [3];
   char auth_2                             [3];
   char update_mask                        [2];
   char type_of_data                       [3];
   char down_payment                       [13];
   char period                             [3];
   char interest_rate                      [5];
   char total_interest                     [13];
   char redemption_amount                  [13];
   char vehicle_number                     [9];

   char profile                                    [3];
   char nbr_of_prod_codes                          [3];
   
   char product1_code                              [7];
   char product1_quantity                          [3];
   char product1_amount                            [13];
   char product2_code                              [7];
   char product2_quantity                          [3];
   char product2_amount                            [13];
   char product3_code                              [7];
   char product3_quantity                          [3];
   char product3_amount                            [13];
   char product4_code                              [7];
   char product4_quantity                          [3];
   char product4_amount                            [13];
   char product5_code                              [7];
   char product5_quantity                          [3];
   char product5_amount                            [13];
   char product6_code                              [7];
   char product6_quantity                          [3];
   char product6_amount                            [13];
   char product7_code                              [7];
   char product7_quantity                          [3];
   char product7_amount                            [13];
   char product8_code                              [7];
   char product8_quantity                          [3];
   char product8_amount                            [13];
   char product9_code                              [7];
   char product9_quantity                          [3];
   char product9_amount                            [13];
   char product10_code                              [7];
   char product10_quantity                          [3];
   char product10_amount                            [13];
   char product11_code                              [7];
   char product11_quantity                          [3];
   char product11_amount                            [13];
   char product12_code                              [7];
   char product12_quantity                          [3];
   char product12_amount                            [13];
   char product13_code                              [7];
   char product13_quantity                          [3];
   char product13_amount                            [13];
   char product14_code                              [7];
   char product14_quantity                          [3];
   char product14_amount                            [13];
   char product15_code                              [7];
   char product15_quantity                          [3];
   char product15_amount                            [13];
   char product16_code                              [7];
   char product16_quantity                          [3];
   char product16_amount                            [13];
   char product17_code                              [7];
   char product17_quantity                          [3];
   char product17_amount                            [13];
   char product18_code                              [7];
   char product18_quantity                          [3];
   char product18_amount                            [13];
   char product19_code                              [7];
   char product19_quantity                          [3];
   char product19_amount                            [13];
   char product20_code                              [7];
   char product20_quantity                          [3];
   char product20_amount                            [13];
   char visa_merchant_id                            [16];
   char cash_bonus                                  [2];  /* added 01-29-99 by IG */
   char deferred_factor                             [8];  /* added 01-29-99 by IG */
   char deferred_term_length                        [4];  /* added 01-29-99 by IG */
   char currency_code                               [4];  /* added 01-29-99 by IG */
   char transmission_timestamp                      [11]; /* added 01-29-99 by IG */
   char tran_fee_amount                             [9];  /* added 01-29-99 by IG */
   char cvc_data                                    [4];  /* added 01-29-99 by IG */

   char verify_mag_stripe                           [2];  /* added 02-09-99 by IG */
   char saf                                         [2];  /* added 02-09-99 by IG */
   char security_response_code                      [3];  /* added 02-09-99 by IG */
   char service_code                                [4];  /* added 02-09-99 by IG */
   char source_pin_format                           [3];  /* added 02-09-99 by IG */
   char dest_pin_format                             [3];  /* added 02-09-99 by IG */
   char voice_auth                                  [2];  /* added 02-09-99 by IG */
   char actual_amount                               [13]; /* AP IG, Equitable 02-10-99 */
   char reversal_amount                             [13]; /* AP IG, Equitable 02-10-99 */
   char voice_auth_text                             [241]; /* IG 02-22-99 */ 
   char operator_id                                 [21];  /* IA 03-09-99 */
   char workstation                                 [21];  /* IA 03-16-99 */
   char orig_auth_number                            [7];   /* IA 04-08-99 */
   char ticket_nbr									[16];
   char system_date									[9];
   char def_gross_amt                               [13];
   char monthly_amort_amt                           [13];

}pte_tlf01;

struct
{
    varchar transaction_id                     [21]; 

    varchar entry_type                         [1];
    varchar tpdu_id                            [16];
    varchar issuer_id                          [21];
    varchar acquirer_id                        [21];
    varchar tx_key                             [1];
    varchar terminal_id                        [9];
    varchar terminal_type                      [3];
    varchar response_text                      [41];
    varchar card_num_len                       [3];
    varchar card_num                           [20];
    varchar exp_date                           [5];
    varchar total_amount                       [13];
    varchar add_amounts                        [25];
    varchar invoice_number                     [9];
    varchar orig_amount                        [13];
    varchar auth_number                        [7];
    varchar processing_code                    [7];
    varchar sys_trace_audit_num                [7];
    varchar orig_sys_trace_num                 [7];
    varchar pos_entry_mode                     [5];
    varchar nii                                [5];
    varchar pos_condition_code                 [3];
    varchar track1                             [77];
    varchar track2                             [38];
    varchar retrieval_ref_num                  [13];
    varchar orig_retrieval_ref_num             [13];
    varchar merchant_id                        [16];
    varchar orig_message                       [5];
    varchar settlement_total                   [17];
    varchar message_type                       [5];
    varchar card_holder_name                   [31];
    varchar general_status                     [1];
    varchar originator_queue                   [17];
    varchar originator_info                    [33];
    varchar batch_number                       [7];
    varchar response_code                      [3];
    varchar date_yyyymmdd                      [9];
    varchar time_hhmmss                        [7];
    varchar num_sales                          [4];
    varchar sales_amount                       [13];
    varchar num_refunds                        [4];
    varchar refund_amount                      [13];
    varchar num_dbsales                        [4];
    varchar dbsales_amount                     [13];
    varchar num_dbrefunds                      [4];
    varchar dbrefund_amount                    [13];
    varchar pin_block                          [19];
    varchar tax_amount                         [13];
    varchar tip_amount                         [13];
    varchar tran_start_time                    [17];
    varchar host_start_time                    [17];
    varchar host_finish_time                   [17];
    varchar tran_finish_time                   [17];
    varchar settle_file_prefix                 [7];
    varchar resp_source_len                    [3];
    varchar visa_char_indicator                [1];
    varchar visa_tran_id                       [16];
    varchar visa_validation_code               [5];
    varchar mcard_banknet_len                  [4];
    varchar mcard_banknet                      [51];
    varchar agent_id_len                       [4];
    varchar agent_id                           [12];
    varchar cvc                                [1];
    varchar settlement_date                    [5];

    varchar category_code                      [5];
    varchar conversion_rate                    [10];
    varchar product_code                       [9];
    varchar odometer                           [8];
    varchar organization_id                    [5];
    varchar dynamic_keychange                  [1];

   varchar source_key                         [49];
   varchar txn_cnt                            [4];
   varchar dcf01_retired_cwk                  [49];
   varchar dest_key                           [49];
   varchar ncf01_retired_cwk                  [49];
   varchar handler_queue                      [8];
   varchar authorizing_host_queue             [8];
   varchar max_net_consec_tmouts              [4];
   varchar max_active_txns                    [4];
   varchar forwarding_institution_id          [12];
   varchar remote_nsp_type                    [2];
   varchar kek                                [17];
   varchar acquiring_id                       [12];
   varchar outstanding_balance                [13];
   varchar credit_limit                       [13];
   varchar nfi_name                           [11];
   varchar nfi_seq_nbr                        [7];
   varchar nfi_start_date                     [9];
   varchar nfi_end_date                       [9];
   varchar resp_source                        [26];
   varchar origin                             [3];
   varchar auth_1                             [3];
   varchar auth_2                             [3];
   varchar update_mask                        [2];
   varchar type_of_data                       [3];
   varchar down_payment                       [13];
   varchar period                             [3];
   varchar interest_rate                      [5];
   varchar total_interest                     [13];
   varchar redemption_amount                  [13];
   varchar vehicle_number                     [9];

   varchar profile                                    [3];
   varchar nbr_of_prod_codes                          [3];
   
   varchar product1_code                              [7];
   varchar product1_quantity                          [3];
   varchar product1_amount                            [13];
   varchar product2_code                              [7];
   varchar product2_quantity                          [3];
   varchar product2_amount                            [13];
   varchar product3_code                              [7];
   varchar product3_quantity                          [3];
   varchar product3_amount                            [13];
   varchar product4_code                              [7];
   varchar product4_quantity                          [3];
   varchar product4_amount                            [13];
   varchar product5_code                              [7];
   varchar product5_quantity                          [3];
   varchar product5_amount                            [13];
   varchar product6_code                              [7];
   varchar product6_quantity                          [3];
   varchar product6_amount                            [13];
   varchar product7_code                              [7];
   varchar product7_quantity                          [3];
   varchar product7_amount                            [13];
   varchar product8_code                              [7];
   varchar product8_quantity                          [3];
   varchar product8_amount                            [13];
   varchar product9_code                              [7];
   varchar product9_quantity                          [3];
   varchar product9_amount                            [13];
   varchar product10_code                              [7];
   varchar product10_quantity                          [3];
   varchar product10_amount                            [13];
   varchar product11_code                              [7];
   varchar product11_quantity                          [3];
   varchar product11_amount                            [13];
   varchar product12_code                              [7];
   varchar product12_quantity                          [3];
   varchar product12_amount                            [13];
   varchar product13_code                              [7];
   varchar product13_quantity                          [3];
   varchar product13_amount                            [13];
   varchar product14_code                              [7];
   varchar product14_quantity                          [3];
   varchar product14_amount                            [13];
   varchar product15_code                              [7];
   varchar product15_quantity                          [3];
   varchar product15_amount                            [13];
   varchar product16_code                              [7];
   varchar product16_quantity                          [3];
   varchar product16_amount                            [13];
   varchar product17_code                              [7];
   varchar product17_quantity                          [3];
   varchar product17_amount                            [13];
   varchar product18_code                              [7];
   varchar product18_quantity                          [3];
   varchar product18_amount                            [13];
   varchar product19_code                              [7];
   varchar product19_quantity                          [3];
   varchar product19_amount                            [13];
   varchar product20_code                              [7];
   varchar product20_quantity                          [3];
   varchar product20_amount                            [13];
   varchar visa_merchant_id                            [16];
   varchar cash_bonus                                  [2];  /* added 01-29-99 by IG */
   varchar deferred_factor                             [8];  /* added 01-29-99 by IG */
   varchar deferred_term_length                        [4];  /* added 01-29-99 by IG */
   varchar currency_code                               [4];  /* added 01-29-99 by IG */
   varchar transmission_timestamp                      [11]; /* added 01-29-99 by IG */
   varchar tran_fee_amount                             [9];  /* added 01-29-99 by IG */
   varchar cvc_data                                    [4];  /* added 01-29-99 by IG */
   varchar verify_mag_stripe                           [2];  /* added 02-09-99 by IG */
   varchar saf                                         [2];  /* added 02-09-99 by IG */
   varchar security_response_code                      [3];  /* added 02-09-99 by IG */
   varchar service_code                                [4];  /* added 02-09-99 by IG */
   varchar source_pin_format                           [3];  /* added 02-09-99 by IG */
   varchar dest_pin_format                             [3];  /* added 02-09-99 by IG */
   varchar voice_auth                                  [2];  /* added 02-09-99 by IG */
   varchar actual_amount                               [13]; /* AP IG, Equitable 02-10-99 */
   varchar reversal_amount                             [13]; /* AP IG, Equitable 02-10-99 */
   varchar voice_auth_text                             [241]; /* IG 02-22-99 */
   varchar operator_id                                 [21];  /* IA 03-09-99 */
   varchar workstation                                 [21];  /* IA 03-16-99 */
   varchar orig_auth_number                            [7];   /* IA 04-08-99 */
   varchar ticket_nbr							       [16];
   varchar system_date							       [9];
   varchar def_gross_amt                               [13];
   varchar monthly_amort_amt                           [13];

}db_tlf01;

struct
{
	char on_behalf_service		[3];
	char on_behalf_result 		[2];
	char description      		[41];
	char response_code    		[3];
	
}pte_obs01;

struct
{
	varchar	on_behalf_service	[3];
	varchar on_behalf_result 	[2];
	varchar description         [41];
	varchar response_code       [3];

}db_obs01;

struct
{
	char cavv 					[2];
	char description      		[41];
	char response_code    		[3];
	
}pte_visa3ds2;

struct
{
	varchar cavv 				[2];
	varchar description         [41];
	varchar response_code       [3];

}db_visa3ds2;

EXEC SQL END DECLARE SECTION;


/*************************************************************************************/
/*************************************************************************************/
void db_to_tlf01 ( pTLF01 tlf01_ptr )
{
   
   memset(tlf01_ptr, 0, sizeof(TLF01));
   memcpy(tlf01_ptr->primary_key.transaction_id, db_tlf01.transaction_id.arr, db_tlf01.transaction_id.len);
   tlf01_ptr->entry_type = db_tlf01.entry_type.arr[0];
   memcpy(tlf01_ptr->tpdu_id, db_tlf01.tpdu_id.arr, db_tlf01.tpdu_id.len);
   memcpy(tlf01_ptr->issuer_id, db_tlf01.issuer_id.arr, db_tlf01.issuer_id.len);
   memcpy(tlf01_ptr->acquirer_id, db_tlf01.acquirer_id.arr, db_tlf01.acquirer_id.len);
   tlf01_ptr->tx_key = db_tlf01.tx_key.arr[0];
   memcpy(tlf01_ptr->terminal_id, db_tlf01.terminal_id.arr, db_tlf01.terminal_id.len);
   memcpy(tlf01_ptr->terminal_type, db_tlf01.terminal_type.arr, db_tlf01.terminal_type.len);
   memcpy(tlf01_ptr->response_text, db_tlf01.response_text.arr, db_tlf01.response_text.len);
   memcpy(tlf01_ptr->card_num_len, db_tlf01.card_num_len.arr, db_tlf01.card_num_len.len);
   memcpy(tlf01_ptr->card_num, db_tlf01.card_num.arr, db_tlf01.card_num.len);
   memcpy(tlf01_ptr->exp_date, db_tlf01.exp_date.arr, db_tlf01.exp_date.len);
   memcpy(tlf01_ptr->total_amount, db_tlf01.total_amount.arr, db_tlf01.total_amount.len);
   memcpy(tlf01_ptr->add_amounts, db_tlf01.add_amounts.arr, db_tlf01.add_amounts.len);
   memcpy(tlf01_ptr->invoice_number, db_tlf01.invoice_number.arr, db_tlf01.invoice_number.len);
   memcpy(tlf01_ptr->orig_amount, db_tlf01.orig_amount.arr, db_tlf01.orig_amount.len);
   memcpy(tlf01_ptr->auth_number, db_tlf01.auth_number.arr, db_tlf01.auth_number.len);
   memcpy(tlf01_ptr->processing_code, db_tlf01.processing_code.arr, db_tlf01.processing_code.len);
   memcpy(tlf01_ptr->sys_trace_audit_num, db_tlf01.sys_trace_audit_num.arr, db_tlf01.sys_trace_audit_num.len);
   memcpy(tlf01_ptr->orig_sys_trace_num, db_tlf01.orig_sys_trace_num.arr, db_tlf01.orig_sys_trace_num.len);
   memcpy(tlf01_ptr->pos_entry_mode, db_tlf01.pos_entry_mode.arr, db_tlf01.pos_entry_mode.len);
   memcpy(tlf01_ptr->nii, db_tlf01.nii.arr, db_tlf01.nii.len);
   memcpy(tlf01_ptr->pos_condition_code, db_tlf01.pos_condition_code.arr, db_tlf01.pos_condition_code.len);
   memcpy(tlf01_ptr->track1, db_tlf01.track1.arr, db_tlf01.track1.len);
   memcpy(tlf01_ptr->track2, db_tlf01.track2.arr, db_tlf01.track2.len);
   memcpy(tlf01_ptr->retrieval_ref_num, db_tlf01.retrieval_ref_num.arr, db_tlf01.retrieval_ref_num.len);
   memcpy(tlf01_ptr->orig_retrieval_ref_num, db_tlf01.orig_retrieval_ref_num.arr, db_tlf01.orig_retrieval_ref_num.len);
   memcpy(tlf01_ptr->merchant_id, db_tlf01.merchant_id.arr, db_tlf01.merchant_id.len);
   memcpy(tlf01_ptr->orig_message, db_tlf01.orig_message.arr, db_tlf01.orig_message.len);
   memcpy(tlf01_ptr->settlement_total, db_tlf01.settlement_total.arr, db_tlf01.settlement_total.len);
   memcpy(tlf01_ptr->message_type, db_tlf01.message_type.arr, db_tlf01.message_type.len);
   memcpy(tlf01_ptr->card_holder_name, db_tlf01.card_holder_name.arr, db_tlf01.card_holder_name.len);
   tlf01_ptr->general_status = db_tlf01.general_status.arr[0];
   memcpy(tlf01_ptr->originator_queue, db_tlf01.originator_queue.arr, db_tlf01.originator_queue.len);
   memcpy(tlf01_ptr->originator_info, db_tlf01.originator_info.arr, db_tlf01.originator_info.len);
   memcpy(tlf01_ptr->batch_number, db_tlf01.batch_number.arr, db_tlf01.batch_number.len);
   memcpy(tlf01_ptr->response_code, db_tlf01.response_code.arr, db_tlf01.response_code.len);
   memcpy(tlf01_ptr->date_yyyymmdd, db_tlf01.date_yyyymmdd.arr, db_tlf01.date_yyyymmdd.len);
   memcpy(tlf01_ptr->time_hhmmss, db_tlf01.time_hhmmss.arr, db_tlf01.time_hhmmss.len);
   memcpy(tlf01_ptr->num_sales, db_tlf01.num_sales.arr, db_tlf01.num_sales.len);
   memcpy(tlf01_ptr->sales_amount, db_tlf01.sales_amount.arr, db_tlf01.sales_amount.len);
   memcpy(tlf01_ptr->num_refunds, db_tlf01.num_refunds.arr, db_tlf01.num_refunds.len);
   memcpy(tlf01_ptr->refund_amount, db_tlf01.refund_amount.arr, db_tlf01.refund_amount.len);
   memcpy(tlf01_ptr->num_dbsales, db_tlf01.num_dbsales.arr, db_tlf01.num_dbsales.len);
   memcpy(tlf01_ptr->dbsales_amount, db_tlf01.dbsales_amount.arr, db_tlf01.dbsales_amount.len);
   memcpy(tlf01_ptr->num_dbrefunds, db_tlf01.num_dbrefunds.arr, db_tlf01.num_dbrefunds.len);
   memcpy(tlf01_ptr->dbrefund_amount, db_tlf01.dbrefund_amount.arr, db_tlf01.dbrefund_amount.len);
   memcpy(tlf01_ptr->pin_block, db_tlf01.pin_block.arr, db_tlf01.pin_block.len);
   memcpy(tlf01_ptr->tax_amount, db_tlf01.tax_amount.arr, db_tlf01.tax_amount.len);
   memcpy(tlf01_ptr->tip_amount, db_tlf01.tip_amount.arr, db_tlf01.tip_amount.len);
   memcpy(tlf01_ptr->tran_start_time, db_tlf01.tran_start_time.arr, db_tlf01.tran_start_time.len);
   memcpy(tlf01_ptr->host_start_time, db_tlf01.host_start_time.arr, db_tlf01.host_start_time.len);
   memcpy(tlf01_ptr->host_finish_time, db_tlf01.host_finish_time.arr, db_tlf01.host_finish_time.len);
   memcpy(tlf01_ptr->tran_finish_time, db_tlf01.tran_finish_time.arr, db_tlf01.tran_finish_time.len);
   memcpy(tlf01_ptr->settle_file_prefix, db_tlf01.settle_file_prefix.arr, db_tlf01.settle_file_prefix.len);
   memcpy(tlf01_ptr->resp_source_len, db_tlf01.resp_source_len.arr, db_tlf01.resp_source_len.len);
   tlf01_ptr->visa_char_indicator = db_tlf01.visa_char_indicator.arr[0];
   memcpy(tlf01_ptr->visa_tran_id, db_tlf01.visa_tran_id.arr, db_tlf01.visa_tran_id.len);
   memcpy(tlf01_ptr->visa_validation_code, db_tlf01.visa_validation_code.arr, db_tlf01.visa_validation_code.len);
   memcpy(tlf01_ptr->mcard_banknet_len, db_tlf01.mcard_banknet_len.arr, db_tlf01.mcard_banknet_len.len);
   memcpy(tlf01_ptr->mcard_banknet, db_tlf01.mcard_banknet.arr, db_tlf01.mcard_banknet.len);
   memcpy(tlf01_ptr->agent_id_len, db_tlf01.agent_id_len.arr, db_tlf01.agent_id_len.len);
   memcpy(tlf01_ptr->agent_id, db_tlf01.agent_id.arr, db_tlf01.agent_id.len);
   tlf01_ptr->cvc = db_tlf01.cvc.arr[0];
   memcpy(tlf01_ptr->settlement_date, db_tlf01.settlement_date.arr, db_tlf01.settlement_date.len);
   memcpy(tlf01_ptr->category_code, db_tlf01.category_code.arr, db_tlf01.category_code.len);
   memcpy(tlf01_ptr->conversion_rate, db_tlf01.conversion_rate.arr, db_tlf01.conversion_rate.len);
   memcpy(tlf01_ptr->product_code, db_tlf01.product_code.arr, db_tlf01.product_code.len);
   memcpy(tlf01_ptr->odometer, db_tlf01.odometer.arr, db_tlf01.odometer.len);
   memcpy(tlf01_ptr->organization_id, db_tlf01.organization_id.arr, db_tlf01.organization_id.len);
   tlf01_ptr->dynamic_keychange = db_tlf01.dynamic_keychange.arr[0];

   memcpy(tlf01_ptr->txn_cnt, db_tlf01.txn_cnt.arr, db_tlf01.txn_cnt.len);
   memcpy(tlf01_ptr->source_key, db_tlf01.source_key.arr, db_tlf01.source_key.len);
   memcpy(tlf01_ptr->dcf01_retired_cwk, db_tlf01.dcf01_retired_cwk.arr, db_tlf01.dcf01_retired_cwk.len);
   memcpy(tlf01_ptr->dest_key, db_tlf01.dest_key.arr, db_tlf01.dest_key.len);
   memcpy(tlf01_ptr->ncf01_retired_cwk, db_tlf01.ncf01_retired_cwk.arr, db_tlf01.ncf01_retired_cwk.len);
   memcpy(tlf01_ptr->handler_queue, db_tlf01.handler_queue.arr, db_tlf01.handler_queue.len);
   memcpy(tlf01_ptr->authorizing_host_queue, db_tlf01.authorizing_host_queue.arr, db_tlf01.authorizing_host_queue.len);
   memcpy(tlf01_ptr->max_net_consec_tmouts, db_tlf01.max_net_consec_tmouts.arr, db_tlf01.max_net_consec_tmouts.len);
   memcpy(tlf01_ptr->max_active_txns, db_tlf01.max_active_txns.arr, db_tlf01.max_active_txns.len);
   memcpy(tlf01_ptr->remote_nsp_type, db_tlf01.remote_nsp_type.arr, db_tlf01.remote_nsp_type.len);
   memcpy(tlf01_ptr->kek, db_tlf01.kek.arr, db_tlf01.kek.len);
   
   memcpy(tlf01_ptr->credit_limit, db_tlf01.credit_limit.arr, db_tlf01.credit_limit.len);
   memcpy(tlf01_ptr->forwarding_institution_id, db_tlf01.forwarding_institution_id.arr, db_tlf01.forwarding_institution_id.len);
   memcpy(tlf01_ptr->acquiring_id, db_tlf01.acquiring_id.arr, db_tlf01.acquiring_id.len);
   memcpy(tlf01_ptr->outstanding_balance, db_tlf01.outstanding_balance.arr, db_tlf01.outstanding_balance.len);
   memcpy(tlf01_ptr->nfi_name, db_tlf01.nfi_name.arr, db_tlf01.nfi_name.len);
   memcpy(tlf01_ptr->nfi_seq_nbr, db_tlf01.nfi_seq_nbr.arr, db_tlf01.nfi_seq_nbr.len);
   memcpy(tlf01_ptr->nfi_start_date, db_tlf01.nfi_start_date.arr, db_tlf01.nfi_start_date.len);
   memcpy(tlf01_ptr->nfi_end_date, db_tlf01.nfi_end_date.arr, db_tlf01.nfi_end_date.len);
   memcpy(tlf01_ptr->resp_source, db_tlf01.resp_source.arr, db_tlf01.resp_source.len);
   memcpy(tlf01_ptr->dispensation.origin, db_tlf01.origin.arr, db_tlf01.origin.len);
   memcpy(tlf01_ptr->dispensation.auth_1, db_tlf01.auth_1.arr, db_tlf01.auth_1.len);
   memcpy(tlf01_ptr->dispensation.auth_2, db_tlf01.auth_2.arr, db_tlf01.auth_2.len);
   memcpy(tlf01_ptr->update_mask, db_tlf01.update_mask.arr, db_tlf01.update_mask.len);

   memcpy(tlf01_ptr->type_of_data, db_tlf01.type_of_data.arr, db_tlf01.type_of_data.len);
   memcpy(tlf01_ptr->down_payment, db_tlf01.down_payment.arr, db_tlf01.down_payment.len);
   memcpy(tlf01_ptr->period, db_tlf01.period.arr, db_tlf01.period.len);
   memcpy(tlf01_ptr->interest_rate, db_tlf01.interest_rate.arr, db_tlf01.interest_rate.len);
   memcpy(tlf01_ptr->total_interest, db_tlf01.total_interest.arr, db_tlf01.total_interest.len);
   memcpy(tlf01_ptr->redemption_amount, db_tlf01.redemption_amount.arr, db_tlf01.redemption_amount.len);
   memcpy(tlf01_ptr->vehicle_number, db_tlf01.vehicle_number.arr, db_tlf01.vehicle_number.len);
  
   memcpy(tlf01_ptr->profile, db_tlf01.profile.arr, db_tlf01.profile.len);
   memcpy(tlf01_ptr->nbr_of_prod_codes, db_tlf01.nbr_of_prod_codes.arr, db_tlf01.nbr_of_prod_codes.len);
  
   memcpy(tlf01_ptr->product_codes[0].code, db_tlf01.product1_code.arr, db_tlf01.product1_code.len);
   memcpy(tlf01_ptr->product_codes[0].quantity, db_tlf01.product1_quantity.arr, db_tlf01.product1_quantity.len);
   memcpy(tlf01_ptr->product_codes[0].amount, db_tlf01.product1_amount.arr, db_tlf01.product1_amount.len);   
   memcpy(tlf01_ptr->product_codes[1].code, db_tlf01.product2_code.arr, db_tlf01.product2_code.len);
   memcpy(tlf01_ptr->product_codes[1].quantity, db_tlf01.product2_quantity.arr, db_tlf01.product2_quantity.len);
   memcpy(tlf01_ptr->product_codes[1].amount, db_tlf01.product2_amount.arr, db_tlf01.product2_amount.len);
   memcpy(tlf01_ptr->product_codes[2].code, db_tlf01.product3_code.arr, db_tlf01.product3_code.len);
   memcpy(tlf01_ptr->product_codes[2].quantity, db_tlf01.product3_quantity.arr, db_tlf01.product3_quantity.len);
   memcpy(tlf01_ptr->product_codes[2].amount, db_tlf01.product3_amount.arr, db_tlf01.product3_amount.len);
   memcpy(tlf01_ptr->product_codes[3].code, db_tlf01.product4_code.arr, db_tlf01.product4_code.len);
   memcpy(tlf01_ptr->product_codes[3].quantity, db_tlf01.product4_quantity.arr, db_tlf01.product4_quantity.len);
   memcpy(tlf01_ptr->product_codes[3].amount, db_tlf01.product4_amount.arr, db_tlf01.product4_amount.len);
   memcpy(tlf01_ptr->product_codes[4].code, db_tlf01.product5_code.arr, db_tlf01.product5_code.len);
   memcpy(tlf01_ptr->product_codes[4].quantity, db_tlf01.product5_quantity.arr, db_tlf01.product5_quantity.len);
   memcpy(tlf01_ptr->product_codes[4].amount, db_tlf01.product5_amount.arr, db_tlf01.product5_amount.len);
   memcpy(tlf01_ptr->product_codes[5].code, db_tlf01.product6_code.arr, db_tlf01.product6_code.len);
   memcpy(tlf01_ptr->product_codes[5].quantity, db_tlf01.product6_quantity.arr, db_tlf01.product6_quantity.len);
   memcpy(tlf01_ptr->product_codes[5].amount, db_tlf01.product6_amount.arr, db_tlf01.product6_amount.len);
   memcpy(tlf01_ptr->product_codes[6].code, db_tlf01.product7_code.arr, db_tlf01.product7_code.len);
   memcpy(tlf01_ptr->product_codes[6].quantity, db_tlf01.product7_quantity.arr, db_tlf01.product7_quantity.len);
   memcpy(tlf01_ptr->product_codes[6].amount, db_tlf01.product7_amount.arr, db_tlf01.product7_amount.len);
   memcpy(tlf01_ptr->product_codes[7].code, db_tlf01.product8_code.arr, db_tlf01.product8_code.len);
   memcpy(tlf01_ptr->product_codes[7].quantity, db_tlf01.product8_quantity.arr, db_tlf01.product8_quantity.len);
   memcpy(tlf01_ptr->product_codes[7].amount, db_tlf01.product8_amount.arr, db_tlf01.product8_amount.len);
   memcpy(tlf01_ptr->product_codes[8].code, db_tlf01.product9_code.arr, db_tlf01.product9_code.len);
   memcpy(tlf01_ptr->product_codes[8].quantity, db_tlf01.product9_quantity.arr, db_tlf01.product9_quantity.len);
   memcpy(tlf01_ptr->product_codes[8].amount, db_tlf01.product9_amount.arr, db_tlf01.product9_amount.len);
   memcpy(tlf01_ptr->product_codes[9].code, db_tlf01.product10_code.arr, db_tlf01.product10_code.len);
   memcpy(tlf01_ptr->product_codes[9].quantity, db_tlf01.product10_quantity.arr, db_tlf01.product10_quantity.len);
   memcpy(tlf01_ptr->product_codes[9].amount, db_tlf01.product10_amount.arr, db_tlf01.product10_amount.len);
   memcpy(tlf01_ptr->product_codes[10].code, db_tlf01.product11_code.arr, db_tlf01.product11_code.len);
   memcpy(tlf01_ptr->product_codes[10].quantity, db_tlf01.product11_quantity.arr, db_tlf01.product11_quantity.len);
   memcpy(tlf01_ptr->product_codes[10].amount, db_tlf01.product11_amount.arr, db_tlf01.product11_amount.len);
   memcpy(tlf01_ptr->product_codes[11].code, db_tlf01.product12_code.arr, db_tlf01.product12_code.len);
   memcpy(tlf01_ptr->product_codes[11].quantity, db_tlf01.product12_quantity.arr, db_tlf01.product12_quantity.len);
   memcpy(tlf01_ptr->product_codes[11].amount, db_tlf01.product12_amount.arr, db_tlf01.product12_amount.len);
   memcpy(tlf01_ptr->product_codes[12].code, db_tlf01.product13_code.arr, db_tlf01.product13_code.len);
   memcpy(tlf01_ptr->product_codes[12].quantity, db_tlf01.product13_quantity.arr, db_tlf01.product13_quantity.len);
   memcpy(tlf01_ptr->product_codes[12].amount, db_tlf01.product13_amount.arr, db_tlf01.product13_amount.len);
   memcpy(tlf01_ptr->product_codes[13].code, db_tlf01.product14_code.arr, db_tlf01.product14_code.len);
   memcpy(tlf01_ptr->product_codes[13].quantity, db_tlf01.product14_quantity.arr, db_tlf01.product14_quantity.len);
   memcpy(tlf01_ptr->product_codes[13].amount, db_tlf01.product14_amount.arr, db_tlf01.product14_amount.len);
   memcpy(tlf01_ptr->product_codes[14].code, db_tlf01.product15_code.arr, db_tlf01.product15_code.len);
   memcpy(tlf01_ptr->product_codes[14].quantity, db_tlf01.product15_quantity.arr, db_tlf01.product15_quantity.len);
   memcpy(tlf01_ptr->product_codes[14].amount, db_tlf01.product15_amount.arr, db_tlf01.product15_amount.len);
   memcpy(tlf01_ptr->product_codes[15].code, db_tlf01.product16_code.arr, db_tlf01.product16_code.len);
   memcpy(tlf01_ptr->product_codes[15].quantity, db_tlf01.product16_quantity.arr, db_tlf01.product16_quantity.len);
   memcpy(tlf01_ptr->product_codes[15].amount, db_tlf01.product16_amount.arr, db_tlf01.product16_amount.len);
   memcpy(tlf01_ptr->product_codes[16].code, db_tlf01.product17_code.arr, db_tlf01.product17_code.len);
   memcpy(tlf01_ptr->product_codes[16].quantity, db_tlf01.product17_quantity.arr, db_tlf01.product17_quantity.len);
   memcpy(tlf01_ptr->product_codes[16].amount, db_tlf01.product17_amount.arr, db_tlf01.product17_amount.len);
   memcpy(tlf01_ptr->product_codes[17].code, db_tlf01.product18_code.arr, db_tlf01.product18_code.len);
   memcpy(tlf01_ptr->product_codes[17].quantity, db_tlf01.product18_quantity.arr, db_tlf01.product18_quantity.len);
   memcpy(tlf01_ptr->product_codes[17].amount, db_tlf01.product18_amount.arr, db_tlf01.product18_amount.len);
   memcpy(tlf01_ptr->product_codes[18].code, db_tlf01.product19_code.arr, db_tlf01.product19_code.len);
   memcpy(tlf01_ptr->product_codes[18].quantity, db_tlf01.product19_quantity.arr, db_tlf01.product19_quantity.len);
   memcpy(tlf01_ptr->product_codes[18].amount, db_tlf01.product19_amount.arr, db_tlf01.product19_amount.len);
   memcpy(tlf01_ptr->product_codes[19].code, db_tlf01.product20_code.arr, db_tlf01.product20_code.len);
   memcpy(tlf01_ptr->product_codes[19].quantity, db_tlf01.product20_quantity.arr, db_tlf01.product20_quantity.len);
   memcpy(tlf01_ptr->product_codes[19].amount, db_tlf01.product20_amount.arr, db_tlf01.product20_amount.len);
   memcpy(tlf01_ptr->visa_merchant_id, db_tlf01.visa_merchant_id.arr, db_tlf01.visa_merchant_id.len);
   
   memcpy(tlf01_ptr->cash_bonus, db_tlf01.cash_bonus.arr, db_tlf01.cash_bonus.len);
   memcpy(tlf01_ptr->deferred_factor, db_tlf01.deferred_factor.arr, db_tlf01.deferred_factor.len);
   memcpy(tlf01_ptr->deferred_term_length, db_tlf01.deferred_term_length.arr, db_tlf01.deferred_term_length.len);
   memcpy(tlf01_ptr->currency_code, db_tlf01.currency_code.arr, db_tlf01.currency_code.len);
   memcpy(tlf01_ptr->transmission_timestamp, db_tlf01.transmission_timestamp.arr, db_tlf01.transmission_timestamp.len);
   memcpy(tlf01_ptr->tran_fee_amount, db_tlf01.tran_fee_amount.arr, db_tlf01.tran_fee_amount.len);
   memcpy(tlf01_ptr->cvc_data, db_tlf01.cvc_data.arr, db_tlf01.cvc_data.len);

   memcpy(tlf01_ptr->verify_mag_stripe, db_tlf01.verify_mag_stripe.arr, db_tlf01.verify_mag_stripe.len);
   memcpy(tlf01_ptr->saf, db_tlf01.saf.arr, db_tlf01.saf.len);
   memcpy(tlf01_ptr->security_response_code, db_tlf01.security_response_code.arr, db_tlf01.security_response_code.len);
   memcpy(tlf01_ptr->service_code, db_tlf01.service_code.arr, db_tlf01.service_code.len);
   memcpy(tlf01_ptr->source_pin_format, db_tlf01.source_pin_format.arr, db_tlf01.source_pin_format.len);
   memcpy(tlf01_ptr->dest_pin_format, db_tlf01.dest_pin_format.arr, db_tlf01.dest_pin_format.len);
   memcpy(tlf01_ptr->voice_auth, db_tlf01.voice_auth.arr, db_tlf01.voice_auth.len);

   memcpy(tlf01_ptr->actual_amount, db_tlf01.actual_amount.arr, db_tlf01.actual_amount.len);
   memcpy(tlf01_ptr->reversal_amount, db_tlf01.reversal_amount.arr, db_tlf01.reversal_amount.len);
  
   memcpy(tlf01_ptr->voice_auth_text, db_tlf01.voice_auth_text.arr, db_tlf01.voice_auth_text.len);
   memcpy(tlf01_ptr->operator_id, db_tlf01.operator_id.arr, db_tlf01.operator_id.len);
   memcpy(tlf01_ptr->workstation, db_tlf01.workstation.arr, db_tlf01.workstation.len);
   memcpy(tlf01_ptr->orig_auth_number, db_tlf01.orig_auth_number.arr, db_tlf01.orig_auth_number.len);
   memcpy(tlf01_ptr->ticket_nbr, db_tlf01.ticket_nbr.arr, db_tlf01.ticket_nbr.len);
   memcpy(tlf01_ptr->system_date, db_tlf01.system_date.arr, db_tlf01.system_date.len);
   memcpy(tlf01_ptr->def_gross_amt, db_tlf01.def_gross_amt.arr, db_tlf01.def_gross_amt.len);
   memcpy(tlf01_ptr->monthly_amort_amt, db_tlf01.monthly_amort_amt.arr, db_tlf01.monthly_amort_amt.len);
}



/******************************************************************************
 *
 *  NAME:         ncf01_to_db
 *
 *  DESCRIPTION:  This function copies an NCF01 record into pte_ncf01 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       ncf01_ptr - NCF01 structure
 *
 *  OUTPUTS:      pte_ncf01 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void ncf01_to_db( pNCF01 ncf01_ptr )
{
  memcpy (&pte_ncf01, ncf01_ptr, sizeof(pte_ncf01));
}


/******************************************************************************
 *
 *  NAME:         ncf02_to_db
 *
 *  DESCRIPTION:  This function copies an NCF02 record into pte_ncf02 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       ncf02_ptr - NCF02 structure
 *
 *  OUTPUTS:      pte_ncf02 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void ncf02_to_db( pNCF02 ncf02_ptr )
{
  memcpy (&pte_ncf02, ncf02_ptr, sizeof(pte_ncf02));
}


/******************************************************************************
 *
 *  NAME:         ncf20_to_db
 *
 *  DESCRIPTION:  This function copies an NCF20 record into pte_ncf20 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       ncf20_ptr - NCF20 structure
 *
 *  OUTPUTS:      pte_ncf20 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void ncf20_to_db( pNCF20 ncf20_ptr )
{
  memcpy (&pte_ncf20, ncf20_ptr, sizeof(pte_ncf20));
}


/******************************************************************************
 *
 *  NAME:         ncf21_to_db
 *
 *  DESCRIPTION:  This function copies an NCF21 record into pte_ncf21 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       ncf21_ptr - NCF21 structure
 *
 *  OUTPUTS:      pte_ncf21 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS: total_amt fld is checked for the sign, it if got one change it no sign.
 ******************************************************************************/
void ncf21_to_db( pNCF21 ncf21_ptr )
{
  char tot_amt[18];
  int i;
  memcpy (&pte_ncf21, ncf21_ptr, sizeof(pte_ncf21));
  if(( pte_ncf21.total_amt[0] == '-') || ( pte_ncf21.total_amt[0] == '+'))
  {
      strcpy(tot_amt,pte_ncf21.total_amt);
      /*strncpy(pte_ncf21.total_amt,(tot_amt+1),16); CRUDE FIX*/
      pte_ncf21.total_amt[0]='0';
      for(i=1;i<16;i++)
        pte_ncf21.total_amt[i]=tot_amt[i];

  }
}


/******************************************************************************
 *
 *  NAME:         ncf30_to_db
 *
 *  DESCRIPTION:  This function copies an NCF30 record into pte_ncf30 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       ncf30_ptr - NCF01 structure
 *
 *  OUTPUTS:      pte_ncf30 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void ncf30_to_db( pNCF30 ncf30_ptr )
{
  memcpy (&pte_ncf30, ncf30_ptr, sizeof(pte_ncf30));
}


/******************************************************************************
 *
 *  NAME:         ncf01_keyblock_to_db
 *
 *  DESCRIPTION:  This function copies an NCF01_KEYBCLOCK record into pte_ncf01_keyblock for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       ncf01_keyblock_ptr - NCF01_KEYBLOCK structure
 *
 *  OUTPUTS:      pte_ncf01_keyblock - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void ncf01_keyblock_to_db( pNCF01_KEYBLOCK ncf01_keyblock_ptr )
{
  memcpy (&pte_ncf01_keyblock, ncf01_keyblock_ptr, sizeof(pte_ncf01_keyblock));
}

/******************************************************************************
 *
 *  NAME:         atm01_to_db
 *
 *  DESCRIPTION:  This function copies an ATM01 record into pte_atm01 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       atm01_ptr - ATM01 structure
 *
 *  OUTPUTS:      pte_atm01 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void atm01_to_db( pATM01 atm01_ptr )
{
  memcpy (&pte_atm01, atm01_ptr, sizeof(pte_atm01));
}


/******************************************************************************
 *
 *  NAME:         neg01_to_db
 *
 *  DESCRIPTION:  This function copies an NEG01 record into pte_neg01 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       neg01_ptr - NEG01 structure
 *
 *  OUTPUTS:      pte_neg01 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void neg01_to_db( pNEG01 neg01_ptr )
{
  memcpy (&pte_neg01, neg01_ptr, sizeof(pte_neg01));
}


/******************************************************************************
 *
 *  NAME:         saf01_to_db
 *
 *  DESCRIPTION:  This function copies an SAF01 record into pte_saf01 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       saf01_ptr - SAF01 structure
 *
 *  OUTPUTS:      pte_saf01 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void saf01_to_db( pSAF01 saf01_ptr )
{
  memcpy (&pte_saf01, saf01_ptr, sizeof(pte_saf01));
}


/******************************************************************************
 *
 *  NAME:         fg01_to_db
 *
 *  DESCRIPTION:  This function copies an FG01 record into pte_fg01 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       fg01_ptr - FG01 structure
 *
 *  OUTPUTS:      pte_fg01 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
void fg01_to_db( pFG01 fg01_ptr )
{
   memcpy( &pte_fg01, fg01_ptr, sizeof(pte_fg01) );
}


/******************************************************************************
 *
 *  NAME:         db_to_ncf01
 *
 *  DESCRIPTION:  This function copies an NCF01 record from db_ncf01 into
 *                ncf01_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      ncf01_ptr - NCF01 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 *     DI - 03/17/99 - Added receiving_inst_id_code.
 ******************************************************************************/
void db_to_ncf01 ( pNCF01 ncf01_ptr )
{
   memset( ncf01_ptr, 0, sizeof(NCF01) );
   memcpy( ncf01_ptr->primary_key.network_id, db_ncf01.network_id.arr, db_ncf01.network_id.len );
   memcpy( ncf01_ptr->primary_key.network_type, db_ncf01.network_type.arr, db_ncf01.network_type.len);

   memcpy(ncf01_ptr->name, db_ncf01.name.arr, db_ncf01.name.len);
   memcpy(ncf01_ptr->status, db_ncf01.status.arr, db_ncf01.status.len);
   memcpy(ncf01_ptr->totals_ind, db_ncf01.totals_ind.arr, db_ncf01.totals_ind.len);
   memcpy(ncf01_ptr->statistics_ind, db_ncf01.statistics_ind.arr, db_ncf01.statistics_ind.len);
   memcpy(ncf01_ptr->acquirer_inst_id_code, db_ncf01.acquirer_inst_id_code.arr, db_ncf01.acquirer_inst_id_code.len);
   memcpy(ncf01_ptr->forwarding_inst_id_code, db_ncf01.forwarding_inst_id_code.arr, db_ncf01.forwarding_inst_id_code.len);
   memcpy(ncf01_ptr->receiving_inst_id_code, db_ncf01.receiving_inst_id_code.arr, db_ncf01.receiving_inst_id_code.len);
   memcpy(ncf01_ptr->remote_nsp_type, db_ncf01.remote_nsp_type.arr, db_ncf01.remote_nsp_type.len);
   memcpy(ncf01_ptr->pin_type, db_ncf01.pin_type.arr, db_ncf01.pin_type.len);
   memcpy(ncf01_ptr->encr_type, db_ncf01.encr_type.arr, db_ncf01.encr_type.len);
   memcpy(ncf01_ptr->pad_char, db_ncf01.pad_char.arr, db_ncf01.pad_char.len);
   memcpy(ncf01_ptr->cwk, db_ncf01.cwk.arr, db_ncf01.cwk.len);
   memcpy(ncf01_ptr->kek, db_ncf01.kek.arr, db_ncf01.kek.len);
   memcpy(ncf01_ptr->retired_cwk, db_ncf01.retired_cwk.arr, db_ncf01.retired_cwk.len);
   memcpy(ncf01_ptr->auto_logon, db_ncf01.auto_logon.arr, db_ncf01.auto_logon.len);
   memcpy(ncf01_ptr->echo_interval, db_ncf01.echo_interval.arr, db_ncf01.echo_interval.len);
   memcpy(ncf01_ptr->max_consecutive_timeouts, db_ncf01.max_consecutive_timeouts.arr, db_ncf01.max_consecutive_timeouts.len);
   memcpy(ncf01_ptr->max_active_txns, db_ncf01.max_active_txns.arr, db_ncf01.max_active_txns.len);
   memcpy(ncf01_ptr->que_name, db_ncf01.que_name.arr, db_ncf01.que_name.len);
  
   memcpy(ncf01_ptr->local_nsp_type, db_ncf01.local_nsp_type.arr, db_ncf01.local_nsp_type.len);
   memcpy(ncf01_ptr->request_timer, db_ncf01.request_timer.arr, db_ncf01.request_timer.len);
   memcpy(ncf01_ptr->idle_line_timer, db_ncf01.idle_line_timer.arr, db_ncf01.idle_line_timer.len);
   memcpy(ncf01_ptr->advice_repeat_counter, db_ncf01.advice_repeat_counter.arr, db_ncf01.advice_repeat_counter.len);
   memcpy(ncf01_ptr->admin_message_timer, db_ncf01.admin_message_timer.arr, db_ncf01.admin_message_timer.len);
   memcpy(ncf01_ptr->store_forward_processing, db_ncf01.store_forward_processing.arr, db_ncf01.store_forward_processing.len);
   memcpy(ncf01_ptr->currency_code_purchase, db_ncf01.currency_code_purchase.arr, db_ncf01.currency_code_purchase.len);
   memcpy(ncf01_ptr->currency_code_cash, db_ncf01.currency_code_cash.arr, db_ncf01.currency_code_cash.len);
   memcpy(ncf01_ptr->country_code, db_ncf01.country_code.arr, db_ncf01.country_code.len);
  
   memcpy(ncf01_ptr->station_id1, db_ncf01.station_id1.arr, db_ncf01.station_id1.len);
   memcpy(ncf01_ptr->station_id2, db_ncf01.station_id2.arr, db_ncf01.station_id2.len);
   memcpy(ncf01_ptr->prev_src_station, db_ncf01.prev_src_station.arr, db_ncf01.prev_src_station.len);
   memcpy(ncf01_ptr->tpdu_id, db_ncf01.tpdu_id.arr, db_ncf01.tpdu_id.len);
   memcpy(ncf01_ptr->logon_bin[0].identifier, db_ncf01.identifier1.arr,  db_ncf01.identifier1.len);
   memcpy(ncf01_ptr->logon_bin[1].identifier, db_ncf01.identifier2.arr,  db_ncf01.identifier2.len);
   memcpy(ncf01_ptr->logon_bin[2].identifier, db_ncf01.identifier3.arr,  db_ncf01.identifier3.len);
   memcpy(ncf01_ptr->logon_bin[3].identifier, db_ncf01.identifier4.arr,  db_ncf01.identifier4.len);
   memcpy(ncf01_ptr->logon_bin[4].identifier, db_ncf01.identifier5.arr,  db_ncf01.identifier5.len);
   memcpy(ncf01_ptr->logon_bin[5].identifier, db_ncf01.identifier6.arr,  db_ncf01.identifier6.len);
   memcpy(ncf01_ptr->logon_bin[6].identifier, db_ncf01.identifier7.arr,  db_ncf01.identifier7.len);
   memcpy(ncf01_ptr->logon_bin[7].identifier, db_ncf01.identifier8.arr,  db_ncf01.identifier8.len);
   memcpy(ncf01_ptr->logon_bin[8].identifier, db_ncf01.identifier9.arr,  db_ncf01.identifier9.len);
   memcpy(ncf01_ptr->logon_bin[9].identifier, db_ncf01.identifier10.arr, db_ncf01.identifier10.len);
   memcpy(ncf01_ptr->allowed[0].processing_code,  db_ncf01.processing_code1.arr,  db_ncf01.processing_code1.len);
   memcpy(ncf01_ptr->allowed[1].processing_code,  db_ncf01.processing_code2.arr,  db_ncf01.processing_code2.len);
   memcpy(ncf01_ptr->allowed[2].processing_code,  db_ncf01.processing_code3.arr,  db_ncf01.processing_code3.len);
   memcpy(ncf01_ptr->allowed[3].processing_code,  db_ncf01.processing_code4.arr,  db_ncf01.processing_code4.len);
   memcpy(ncf01_ptr->allowed[4].processing_code,  db_ncf01.processing_code5.arr,  db_ncf01.processing_code5.len);
   memcpy(ncf01_ptr->allowed[5].processing_code,  db_ncf01.processing_code6.arr,  db_ncf01.processing_code6.len);
   memcpy(ncf01_ptr->allowed[6].processing_code,  db_ncf01.processing_code7.arr,  db_ncf01.processing_code7.len);
   memcpy(ncf01_ptr->allowed[7].processing_code,  db_ncf01.processing_code8.arr,  db_ncf01.processing_code8.len);
   memcpy(ncf01_ptr->allowed[8].processing_code,  db_ncf01.processing_code9.arr,  db_ncf01.processing_code9.len);
   memcpy(ncf01_ptr->allowed[9].processing_code,  db_ncf01.processing_code10.arr, db_ncf01.processing_code10.len);
   memcpy(ncf01_ptr->allowed[10].processing_code, db_ncf01.processing_code11.arr, db_ncf01.processing_code11.len);
   memcpy(ncf01_ptr->allowed[11].processing_code, db_ncf01.processing_code12.arr, db_ncf01.processing_code12.len);
   memcpy(ncf01_ptr->allowed[12].processing_code, db_ncf01.processing_code13.arr, db_ncf01.processing_code13.len);
   memcpy(ncf01_ptr->allowed[13].processing_code, db_ncf01.processing_code14.arr, db_ncf01.processing_code14.len);
   memcpy(ncf01_ptr->allowed[14].processing_code, db_ncf01.processing_code15.arr, db_ncf01.processing_code15.len);
   memcpy(ncf01_ptr->allowed[15].processing_code, db_ncf01.processing_code16.arr, db_ncf01.processing_code16.len);
   memcpy(ncf01_ptr->allowed[16].processing_code, db_ncf01.processing_code17.arr, db_ncf01.processing_code17.len);
   memcpy(ncf01_ptr->allowed[17].processing_code, db_ncf01.processing_code18.arr, db_ncf01.processing_code18.len);
   memcpy(ncf01_ptr->allowed[18].processing_code, db_ncf01.processing_code19.arr, db_ncf01.processing_code19.len);
   memcpy(ncf01_ptr->allowed[19].processing_code, db_ncf01.processing_code20.arr, db_ncf01.processing_code20.len);
   memcpy(ncf01_ptr->zmk,                         db_ncf01.zmk.arr,               db_ncf01.zmk.len);
   memcpy(ncf01_ptr->neg_access_code,             db_ncf01.neg_access_code.arr,   db_ncf01.neg_access_code.len);
   
}

/******************************************************************************
 *
 *  NAME:         db_to_ncf02
 *
 *  DESCRIPTION:  This function copies an NCF02 record from db_ncf02 into
 *                ncf02_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      ncf02_ptr - NCF02 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void db_to_ncf02 ( pNCF02 ncf02_ptr )
{
   memset( ncf02_ptr, 0, sizeof(NCF02) );
   memcpy( ncf02_ptr->primary_key.network_id, db_ncf02.network_id.arr, db_ncf02.network_id.len);
   memcpy( ncf02_ptr->primary_key.network_type, db_ncf02.network_type.arr, db_ncf02.network_type.len);
   
   memcpy(ncf02_ptr->credit_cnt, db_ncf02.credit_cnt.arr, db_ncf02.credit_cnt.len);
   memcpy(ncf02_ptr->credit_reversal_cnt, db_ncf02.credit_reversal_cnt.arr, db_ncf02.credit_reversal_cnt.len);
   memcpy(ncf02_ptr->debit_cnt, db_ncf02.debit_cnt.arr, db_ncf02.debit_cnt.len);
   memcpy(ncf02_ptr->debit_reversal_cnt, db_ncf02.debit_reversal_cnt.arr, db_ncf02.debit_reversal_cnt.len);
   memcpy(ncf02_ptr->transfer_cnt, db_ncf02.transfer_cnt.arr, db_ncf02.transfer_cnt.len);
   memcpy(ncf02_ptr->transfer_reversal_cnt, db_ncf02.transfer_reversal_cnt.arr, db_ncf02.transfer_reversal_cnt.len);
   memcpy(ncf02_ptr->inquiries_cnt, db_ncf02.inquiries_cnt.arr, db_ncf02.inquiries_cnt.len);
   memcpy(ncf02_ptr->authorizations_cnt, db_ncf02.authorizations_cnt.arr, db_ncf02.authorizations_cnt.len);
   memcpy(ncf02_ptr->credit_proc_fee_amt, db_ncf02.credit_proc_fee_amt.arr, db_ncf02.credit_proc_fee_amt.len);
   memcpy(ncf02_ptr->credit_tran_fee_amt, db_ncf02.credit_tran_fee_amt.arr, db_ncf02.credit_tran_fee_amt.len);
   memcpy(ncf02_ptr->debit_proc_fee_amt, db_ncf02.debit_proc_fee_amt.arr, db_ncf02.debit_proc_fee_amt.len);
   memcpy(ncf02_ptr->debit_tran_fee_amt, db_ncf02.debit_tran_fee_amt.arr, db_ncf02.debit_tran_fee_amt.len);
   memcpy(ncf02_ptr->credit_amt, db_ncf02.credit_amt.arr, db_ncf02.credit_amt.len);
   memcpy(ncf02_ptr->credit_reversal_amt, db_ncf02.credit_reversal_amt.arr, db_ncf02.credit_reversal_amt.len);
   memcpy(ncf02_ptr->debit_amt, db_ncf02.debit_amt.arr, db_ncf02.debit_amt.len);
   memcpy(ncf02_ptr->debit_reversal_amt, db_ncf02.debit_reversal_amt.arr, db_ncf02.debit_reversal_amt.len);
   memcpy(ncf02_ptr->net_settlement_amt, db_ncf02.net_settlement_amt.arr, db_ncf02.net_settlement_amt.len);
}

/******************************************************************************
 *
 *  NAME:         db_to_ncf20
 *
 *  DESCRIPTION:  This function copies an NCF20 record from db_ncf20 into
 *                ncf20_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      ncf20_ptr - NCF20 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void db_to_ncf20 ( pNCF20 ncf20_ptr )
{
   memset( ncf20_ptr, 0, sizeof(NCF20) );
   memcpy( ncf20_ptr->primary_key.network_id, db_ncf20.network_id.arr, db_ncf20.network_id.len);
   memcpy( ncf20_ptr->primary_key.yyyymmdd, db_ncf20.yyyymmdd.arr, db_ncf20.yyyymmdd.len);
   
   memcpy(ncf20_ptr->ytd_total_tran_cnt, db_ncf20.ytd_total_tran_cnt.arr, db_ncf20.ytd_total_tran_cnt.len);
   memcpy(ncf20_ptr->ytd_total_tran_amt, db_ncf20.ytd_total_tran_amt.arr, db_ncf20.ytd_total_tran_amt.len);
   memcpy(ncf20_ptr->mtd_total_tran_cnt, db_ncf20.mtd_total_tran_cnt.arr, db_ncf20.mtd_total_tran_cnt.len);
   memcpy(ncf20_ptr->mtd_total_tran_amt, db_ncf20.mtd_total_tran_amt.arr, db_ncf20.mtd_total_tran_amt.len);
   memcpy(ncf20_ptr->tran_cnt, db_ncf20.tran_cnt.arr, db_ncf20.tran_cnt.len);
   memcpy(ncf20_ptr->tran_amt, db_ncf20.tran_amt.arr, db_ncf20.tran_amt.len);
   memcpy(ncf20_ptr->tran_approved_cnt, db_ncf20.tran_approved_cnt.arr, db_ncf20.tran_approved_cnt.len);
   memcpy(ncf20_ptr->tran_declined_cnt, db_ncf20.tran_declined_cnt.arr, db_ncf20.tran_declined_cnt.len);

   memcpy(ncf20_ptr->decline[0].category_code,  db_ncf20.category_code1.arr,  db_ncf20.category_code1.len);
   memcpy(ncf20_ptr->decline[1].category_code,  db_ncf20.category_code2.arr,  db_ncf20.category_code2.len);
   memcpy(ncf20_ptr->decline[2].category_code,  db_ncf20.category_code3.arr,  db_ncf20.category_code3.len);
   memcpy(ncf20_ptr->decline[3].category_code,  db_ncf20.category_code4.arr,  db_ncf20.category_code4.len);
   memcpy(ncf20_ptr->decline[4].category_code,  db_ncf20.category_code5.arr,  db_ncf20.category_code5.len);
   memcpy(ncf20_ptr->decline[5].category_code,  db_ncf20.category_code6.arr,  db_ncf20.category_code6.len);
   memcpy(ncf20_ptr->decline[6].category_code,  db_ncf20.category_code7.arr,  db_ncf20.category_code7.len);
   memcpy(ncf20_ptr->decline[7].category_code,  db_ncf20.category_code8.arr,  db_ncf20.category_code8.len);
   memcpy(ncf20_ptr->decline[8].category_code,  db_ncf20.category_code9.arr,  db_ncf20.category_code9.len);
   memcpy(ncf20_ptr->decline[9].category_code,  db_ncf20.category_code10.arr, db_ncf20.category_code10.len);
   memcpy(ncf20_ptr->decline[10].category_code, db_ncf20.category_code11.arr, db_ncf20.category_code11.len);
   memcpy(ncf20_ptr->decline[11].category_code, db_ncf20.category_code12.arr, db_ncf20.category_code12.len);
   memcpy(ncf20_ptr->decline[12].category_code, db_ncf20.category_code13.arr, db_ncf20.category_code13.len);
   memcpy(ncf20_ptr->decline[13].category_code, db_ncf20.category_code14.arr, db_ncf20.category_code14.len);
   memcpy(ncf20_ptr->decline[14].category_code, db_ncf20.category_code15.arr, db_ncf20.category_code15.len);
   memcpy(ncf20_ptr->decline[15].category_code, db_ncf20.category_code16.arr, db_ncf20.category_code16.len);
   memcpy(ncf20_ptr->decline[16].category_code, db_ncf20.category_code17.arr, db_ncf20.category_code17.len);
   memcpy(ncf20_ptr->decline[17].category_code, db_ncf20.category_code18.arr, db_ncf20.category_code18.len);
   memcpy(ncf20_ptr->decline[18].category_code, db_ncf20.category_code19.arr, db_ncf20.category_code19.len);
   memcpy(ncf20_ptr->decline[19].category_code, db_ncf20.category_code20.arr, db_ncf20.category_code20.len);

   memcpy(ncf20_ptr->decline[0].category_cnt,   db_ncf20.category_cnt1.arr,   db_ncf20.category_cnt1.len);
   memcpy(ncf20_ptr->decline[1].category_cnt,   db_ncf20.category_cnt2.arr,   db_ncf20.category_cnt2.len);
   memcpy(ncf20_ptr->decline[2].category_cnt,   db_ncf20.category_cnt3.arr,   db_ncf20.category_cnt3.len);
   memcpy(ncf20_ptr->decline[3].category_cnt,   db_ncf20.category_cnt4.arr,   db_ncf20.category_cnt4.len);
   memcpy(ncf20_ptr->decline[4].category_cnt,   db_ncf20.category_cnt5.arr,   db_ncf20.category_cnt5.len);
   memcpy(ncf20_ptr->decline[5].category_cnt,   db_ncf20.category_cnt6.arr,   db_ncf20.category_cnt6.len);
   memcpy(ncf20_ptr->decline[6].category_cnt,   db_ncf20.category_cnt7.arr,   db_ncf20.category_cnt7.len);
   memcpy(ncf20_ptr->decline[7].category_cnt,   db_ncf20.category_cnt8.arr,   db_ncf20.category_cnt8.len);
   memcpy(ncf20_ptr->decline[8].category_cnt,   db_ncf20.category_cnt9.arr,   db_ncf20.category_cnt9.len);
   memcpy(ncf20_ptr->decline[9].category_cnt,   db_ncf20.category_cnt10.arr,  db_ncf20.category_cnt10.len);
   memcpy(ncf20_ptr->decline[10].category_cnt,  db_ncf20.category_cnt11.arr,  db_ncf20.category_cnt11.len);
   memcpy(ncf20_ptr->decline[11].category_cnt,  db_ncf20.category_cnt12.arr,  db_ncf20.category_cnt12.len);
   memcpy(ncf20_ptr->decline[12].category_cnt,  db_ncf20.category_cnt13.arr,  db_ncf20.category_cnt13.len);
   memcpy(ncf20_ptr->decline[13].category_cnt,  db_ncf20.category_cnt14.arr,  db_ncf20.category_cnt14.len);
   memcpy(ncf20_ptr->decline[14].category_cnt,  db_ncf20.category_cnt15.arr,  db_ncf20.category_cnt15.len);
   memcpy(ncf20_ptr->decline[15].category_cnt,  db_ncf20.category_cnt16.arr,  db_ncf20.category_cnt16.len);
   memcpy(ncf20_ptr->decline[16].category_cnt,  db_ncf20.category_cnt17.arr,  db_ncf20.category_cnt17.len);
   memcpy(ncf20_ptr->decline[17].category_cnt,  db_ncf20.category_cnt18.arr,  db_ncf20.category_cnt18.len);
   memcpy(ncf20_ptr->decline[18].category_cnt,  db_ncf20.category_cnt19.arr,  db_ncf20.category_cnt19.len);
   memcpy(ncf20_ptr->decline[19].category_cnt,  db_ncf20.category_cnt20.arr,  db_ncf20.category_cnt20.len);
}

/******************************************************************************
 *
 *  NAME:         db_to_ncf21
 *
 *  DESCRIPTION:  This function copies an NCF21 record from db_ncf21 into
 *                ncf21_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      ncf21_ptr - NCF21 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void db_to_ncf21 ( pNCF21 ncf21_ptr )
{
   memset( ncf21_ptr, 0, sizeof(NCF21) );
   memcpy( ncf21_ptr->primary_key.network_id,   db_ncf21.network_id.arr,   db_ncf21.network_id.len);
   memcpy( ncf21_ptr->primary_key.network_type, db_ncf21.network_type.arr, db_ncf21.network_type.len);
   memcpy( ncf21_ptr->primary_key.batch_number, db_ncf21.batch_number.arr, db_ncf21.batch_number.len);
   
   memcpy(ncf21_ptr->open_date, db_ncf21.open_date.arr, db_ncf21.open_date.len);
   memcpy(ncf21_ptr->open_time, db_ncf21.open_time.arr, db_ncf21.open_time.len);
   memcpy(ncf21_ptr->release_date, db_ncf21.release_date.arr, db_ncf21.release_date.len);
   memcpy(ncf21_ptr->release_time, db_ncf21.release_time.arr, db_ncf21.release_time.len);
   memcpy(ncf21_ptr->credit_cnt, db_ncf21.credit_cnt.arr, db_ncf21.credit_cnt.len);
   memcpy(ncf21_ptr->credit_amt, db_ncf21.credit_amt.arr, db_ncf21.credit_amt.len);
   memcpy(ncf21_ptr->credit_rev_cnt, db_ncf21.credit_rev_cnt.arr, db_ncf21.credit_rev_cnt.len);
   memcpy(ncf21_ptr->credit_rev_amt, db_ncf21.credit_rev_amt.arr, db_ncf21.credit_rev_amt.len);
   memcpy(ncf21_ptr->debit_cnt, db_ncf21.debit_cnt.arr, db_ncf21.debit_cnt.len);
   memcpy(ncf21_ptr->debit_amt, db_ncf21.debit_amt.arr, db_ncf21.debit_amt.len);
   memcpy(ncf21_ptr->debit_rev_cnt, db_ncf21.debit_rev_cnt.arr, db_ncf21.debit_rev_cnt.len);
   memcpy(ncf21_ptr->debit_rev_amt, db_ncf21.debit_rev_amt.arr, db_ncf21.debit_rev_amt.len);
   memcpy(ncf21_ptr->total_amt, db_ncf21.total_amt.arr, db_ncf21.total_amt.len);
   memcpy(ncf21_ptr->total_amt_type, db_ncf21.total_amt_type.arr, db_ncf21.total_amt_type.len);

}

/******************************************************************************
 *
 *  NAME:         db_to_ncf30
 *
 *  DESCRIPTION:  This function copies an NCF30 record from db_ncf30 into
 *                ncf30_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void db_to_ncf30 ( pNCF30 ncf30_ptr )
{
   memset( ncf30_ptr, 0, sizeof(NCF30) );
   memcpy( ncf30_ptr->primary_key.network_id,   db_ncf30.network_id.arr,   db_ncf30.network_id.len);
   memcpy( ncf30_ptr->primary_key.network_type, db_ncf30.network_type.arr, db_ncf30.network_type.len);
   memcpy( ncf30_ptr->primary_key.batch_number, db_ncf30.batch_number.arr, db_ncf30.batch_number.len);
   memcpy( ncf30_ptr->primary_key.retrieval_ref_num, db_ncf30.retrieval_ref_num.arr, db_ncf30.retrieval_ref_num.len);
   
   memcpy(ncf30_ptr->open_date, db_ncf30.open_date.arr, db_ncf30.open_date.len);
   memcpy(ncf30_ptr->open_time, db_ncf30.open_time.arr, db_ncf30.open_time.len);
   memcpy(ncf30_ptr->merchant_id, db_ncf30.merchant_id.arr, db_ncf30.merchant_id.len);
   memcpy(ncf30_ptr->transaction_id, db_ncf30.transaction_id.arr, db_ncf30.transaction_id.len);
   memcpy(ncf30_ptr->device_id, db_ncf30.device_id.arr, db_ncf30.device_id.len);
   memcpy(ncf30_ptr->card_nbr, db_ncf30.card_nbr.arr, db_ncf30.card_nbr.len);
   memcpy(ncf30_ptr->message_type, db_ncf30.message_type.arr, db_ncf30.message_type.len);
   memcpy(ncf30_ptr->processing_code, db_ncf30.processing_code.arr, db_ncf30.processing_code.len);

   memcpy(ncf30_ptr->tran_amount,  db_ncf30.tran_amount.arr,  db_ncf30.tran_amount.len);
   memcpy(ncf30_ptr->auth_number,  db_ncf30.auth_number.arr,  db_ncf30.auth_number.len);
   memcpy(ncf30_ptr->response_code,  db_ncf30.response_code.arr,  db_ncf30.response_code.len);
   memcpy(ncf30_ptr->tran_date,  db_ncf30.tran_date.arr,  db_ncf30.tran_date.len);
   memcpy(ncf30_ptr->tran_time,  db_ncf30.tran_time.arr,  db_ncf30.tran_time.len);
   memcpy(ncf30_ptr->sys_trace_audit_nbr,  db_ncf30.sys_trace_audit_nbr.arr,  db_ncf30.sys_trace_audit_nbr.len);
   ncf30_ptr->tx_key = db_ncf30.tx_key.arr[0];
   memcpy(ncf30_ptr->invoice_nbr,  db_ncf30.invoice_nbr.arr,  db_ncf30.invoice_nbr.len);
   memcpy(ncf30_ptr->network_data, db_ncf30.network_data.arr, db_ncf30.network_data.len);
   memcpy(ncf30_ptr->currency_code, db_ncf30.currency_code.arr, db_ncf30.currency_code.len);
   memcpy(ncf30_ptr->acquiring_inst_id_code, db_ncf30.acquiring_inst_id_code.arr, db_ncf30.acquiring_inst_id_code.len);
   memcpy(ncf30_ptr->settlement_date, db_ncf30.settlement_date.arr, db_ncf30.settlement_date.len);
   memcpy(ncf30_ptr->transmission_timestamp, db_ncf30.transmission_timestamp.arr, db_ncf30.transmission_timestamp.len);
   memcpy(ncf30_ptr->tran_fee_amount, db_ncf30.tran_fee_amount.arr, db_ncf30.tran_fee_amount.len);
}

/******************************************************************************
 *
 *  NAME:         db_to_ncf01_keyblock
 *
 *  DESCRIPTION:  This function copies an NCF01_KEYBLOCK record from db_ncf01_keyblock into
 *                ncf01_keyblock_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      ncf01_keyblock_ptr - NCF01_KEYBLOCK structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void db_to_ncf01_keyblock ( pNCF01_KEYBLOCK ncf01_keyblock_ptr )
{
   memset( ncf01_keyblock_ptr, 0, sizeof(NCF01_KEYBLOCK) );
   memcpy( ncf01_keyblock_ptr->network_id,   db_ncf01_keyblock.network_id.arr,   db_ncf01_keyblock.network_id.len);
   /*memcpy( ncf01_keyblock_ptr->NETWORK_TYPE, db_ncf01_keyblock.network_type.arr, db_ncf01_keyblock.network_type.len);*/
     
   memcpy( ncf01_keyblock_ptr->iss_cwk_keyblock, db_ncf01_keyblock.iss_cwk_keyblock.arr, db_ncf01_keyblock.iss_cwk_keyblock.len);
   memcpy( ncf01_keyblock_ptr->iss_zmk_keyblock, db_ncf01_keyblock.iss_zmk_keyblock.arr, db_ncf01_keyblock.iss_zmk_keyblock.len);
   memcpy( ncf01_keyblock_ptr->iss_rtdcwk_keyblock, db_ncf01_keyblock.iss_rtdcwk_keyblock.arr, db_ncf01_keyblock.iss_rtdcwk_keyblock.len);
   memcpy( ncf01_keyblock_ptr->iss_kek_keyblock, db_ncf01_keyblock.iss_kek_keyblock.arr, db_ncf01_keyblock.iss_kek_keyblock.len);
   memcpy( ncf01_keyblock_ptr->acq_cwk_keyblock, db_ncf01_keyblock.acq_cwk_keyblock.arr, db_ncf01_keyblock.acq_cwk_keyblock.len);
   memcpy( ncf01_keyblock_ptr->acq_zmk_keyblock, db_ncf01_keyblock.acq_zmk_keyblock.arr, db_ncf01_keyblock.acq_zmk_keyblock.len);
   memcpy( ncf01_keyblock_ptr->acq_kek_keyblock, db_ncf01_keyblock.acq_kek_keyblock.arr, db_ncf01_keyblock.acq_kek_keyblock.len);
   memcpy( ncf01_keyblock_ptr->iss_prev_src_station, db_ncf01_keyblock.iss_prev_src_station.arr, db_ncf01_keyblock.iss_prev_src_station.len);
   memcpy( ncf01_keyblock_ptr->future_field1, db_ncf01_keyblock.future_field1.arr, db_ncf01_keyblock.future_field1.len);
   memcpy( ncf01_keyblock_ptr->future_field2, db_ncf01_keyblock.future_field2.arr, db_ncf01_keyblock.future_field2.len);
   memcpy( ncf01_keyblock_ptr->future_field3, db_ncf01_keyblock.future_field3.arr, db_ncf01_keyblock.future_field3.len);
   memcpy( ncf01_keyblock_ptr->future_field4, db_ncf01_keyblock.future_field4.arr, db_ncf01_keyblock.future_field4.len);
   memcpy( ncf01_keyblock_ptr->future_field5, db_ncf01_keyblock.future_field5.arr, db_ncf01_keyblock.future_field5.len);
                                      
}
/******************************************************************************
 *
 *  NAME:         db_to_atm01
 *
 *  DESCRIPTION:  This function copies an ATM01 record from db_atm01 into
 *                atm01_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      atm01_ptr - ATM01 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void db_to_atm01 ( pATM01 atm01_ptr )
{
   memset( atm01_ptr, 0, sizeof(ATM01) );
   memcpy( atm01_ptr->primary_key.bkcb_name,   db_atm01.bkcb_name.arr,   db_atm01.bkcb_name.len);
   memcpy( atm01_ptr->primary_key.termnumr, db_atm01.termnumr.arr, db_atm01.termnumr.len);

   memcpy(atm01_ptr->bourder,  db_atm01.bourder.arr,  db_atm01.bourder.len);
   memcpy(atm01_ptr->mnemonic, db_atm01.mnemonic.arr, db_atm01.mnemonic.len);
   
   memcpy(atm01_ptr->brchname, db_atm01.brchname.arr, db_atm01.brchname.len);
   memcpy(atm01_ptr->termsite, db_atm01.termsite.arr, db_atm01.termsite.len);
   memcpy(atm01_ptr->termaddr, db_atm01.termaddr.arr, db_atm01.termaddr.len);
   memcpy(atm01_ptr->termdist, db_atm01.termdist.arr, db_atm01.termdist.len);
   memcpy(atm01_ptr->termcimu, db_atm01.termcimu.arr, db_atm01.termcimu.len);
   memcpy(atm01_ptr->termprov, db_atm01.termprov.arr, db_atm01.termprov.len);
   memcpy(atm01_ptr->termregn, db_atm01.termregn.arr, db_atm01.termregn.len);
   memcpy(atm01_ptr->machtype, db_atm01.machtype.arr, db_atm01.machtype.len);

   memcpy(atm01_ptr->termodel, db_atm01.termodel.arr, db_atm01.termodel.len);
   memcpy(atm01_ptr->dateinst, db_atm01.dateinst.arr, db_atm01.dateinst.len);
   memcpy(atm01_ptr->termloc,  db_atm01.termloc.arr,  db_atm01.termloc.len);
   memcpy(atm01_ptr->termtype, db_atm01.termtype.arr, db_atm01.termtype.len);
   memcpy(atm01_ptr->refnum,   db_atm01.refnum.arr,   db_atm01.refnum.len);
   memcpy(atm01_ptr->linktype, db_atm01.linktype.arr, db_atm01.linktype.len);
}

/******************************************************************************
 *
 *  NAME:         db_to_neg01
 *
 *  DESCRIPTION:  This function copies an NEG01 record from db_neg01 into
 *                neg01_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      neg01_ptr - NEG01 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void db_to_neg01 ( pNEG01 neg01_ptr )
{
   memset( neg01_ptr, 0, sizeof(NEG01) );
   memcpy( neg01_ptr->card_nbr,  db_neg01.card_nbr.arr,  db_neg01.card_nbr.len );
   memcpy( neg01_ptr->card_type, db_neg01.card_type.arr, db_neg01.card_type.len);

   memcpy(neg01_ptr->card_exten,  db_neg01.card_exten.arr,  db_neg01.card_exten.len);
   memcpy(neg01_ptr->card_status, db_neg01.card_status.arr, db_neg01.card_status.len);
}

/******************************************************************************
 *
 *  NAME:         db_to_saf01
 *
 *  DESCRIPTION:  This function copies an SAF01 record from db_saf01 into
 *                saf01_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      saf01_ptr - NCF01 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void db_to_saf01 ( pSAF01 saf01_ptr )
{
   memset( saf01_ptr, 0, sizeof(SAF01) );
   memcpy( saf01_ptr->primary_key.transaction_id, db_saf01.transaction_id.arr, db_saf01.transaction_id.len );

   memcpy(saf01_ptr->card_num, db_saf01.card_num.arr, db_saf01.card_num.len);
   memcpy(saf01_ptr->tran_amount, db_saf01.tran_amount.arr, db_saf01.tran_amount.len);
   memcpy(saf01_ptr->device_id, db_saf01.device_id.arr, db_saf01.device_id.len);
   memcpy(saf01_ptr->message_type, db_saf01.message_type.arr, db_saf01.message_type.len);
   memcpy(saf01_ptr->processing_code, db_saf01.processing_code.arr, db_saf01.processing_code.len);
   memcpy(saf01_ptr->sys_trace_audit_nbr, db_saf01.sys_trace_audit_nbr.arr, db_saf01.sys_trace_audit_nbr.len);
   memcpy(saf01_ptr->tran_date, db_saf01.tran_date.arr, db_saf01.tran_date.len);
   memcpy(saf01_ptr->tran_time, db_saf01.tran_time.arr, db_saf01.tran_time.len);
   saf01_ptr->tx_key = db_saf01.tx_key.arr[0];
   memcpy(saf01_ptr->retrieval_ref_num, db_saf01.retrieval_ref_num.arr, db_saf01.retrieval_ref_num.len);
   memcpy(saf01_ptr->merchant_id, db_saf01.merchant_id.arr, db_saf01.merchant_id.len);
   memcpy(saf01_ptr->auth_number, db_saf01.auth_number.arr, db_saf01.auth_number.len);
   memcpy(saf01_ptr->response_code, db_saf01.response_code.arr, db_saf01.response_code.len);
   memcpy(saf01_ptr->invoice_nbr, db_saf01.invoice_nbr.arr, db_saf01.invoice_nbr.len);
   memcpy(saf01_ptr->network_data, db_saf01.network_data.arr, db_saf01.network_data.len);
   memcpy(saf01_ptr->currency_code, db_saf01.currency_code.arr, db_saf01.currency_code.len);
   memcpy(saf01_ptr->transmission_timestamp, db_saf01.transmission_timestamp.arr, db_saf01.transmission_timestamp.len);
   memcpy(saf01_ptr->exp_date, db_saf01.exp_date.arr, db_saf01.exp_date.len);
   memcpy(saf01_ptr->settlement_amount, db_saf01.settlement_amount.arr, db_saf01.settlement_amount.len);
   memcpy(saf01_ptr->settlement_date, db_saf01.settlement_date.arr, db_saf01.settlement_date.len);
   memcpy(saf01_ptr->settlement_conv_rate, db_saf01.settlement_conv_rate.arr, db_saf01.settlement_conv_rate.len);
   memcpy(saf01_ptr->settlement_curr_code, db_saf01.settlement_curr_code.arr, db_saf01.settlement_curr_code.len);
   memcpy(saf01_ptr->billing_amount, db_saf01.billing_amount.arr, db_saf01.billing_amount.len);
   memcpy(saf01_ptr->billing_conv_rate, db_saf01.billing_conv_rate.arr, db_saf01.billing_conv_rate.len);
   memcpy(saf01_ptr->billing_curr_code, db_saf01.billing_curr_code.arr, db_saf01.billing_curr_code.len);
   memcpy(saf01_ptr->tran_fee_amount, db_saf01.tran_fee_amount.arr, db_saf01.tran_fee_amount.len);
   memcpy(saf01_ptr->handler_queue, db_saf01.handler_queue.arr, db_saf01.handler_queue.len);
   memcpy(saf01_ptr->acquiring_inst_id_code, db_saf01.acquiring_inst_id_code.arr, db_saf01.acquiring_inst_id_code.len);
   memcpy(saf01_ptr->forwarding_inst_id_code, db_saf01.forwarding_inst_id_code.arr, db_saf01.forwarding_inst_id_code.len);
   memcpy(saf01_ptr->reversal_amount, db_saf01.reversal_amount.arr, db_saf01.reversal_amount.len);
}

/******************************************************************************
 *
 *  NAME:         db_to_fg01
 *
 *  DESCRIPTION:  This function copies an FG01 record from db_fg01 into
 *                fg01_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      fg01_ptr - FG01 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
void db_to_fg01 ( pFG01 fg01_ptr )
{
   memset( fg01_ptr, 0x00, sizeof(FG01) );

   memcpy(fg01_ptr->name,          db_fg01.name.arr,          db_fg01.name.len         );
   memcpy(fg01_ptr->type,          db_fg01.type.arr,          db_fg01.type.len         );
   memcpy(fg01_ptr->caller_id,     db_fg01.caller_id.arr,     db_fg01.caller_id.len    );
   memcpy(fg01_ptr->source,        db_fg01.source.arr,        db_fg01.source.len       );
   memcpy(fg01_ptr->username,      db_fg01.username.arr,      db_fg01.username.len     );
   memcpy(fg01_ptr->application,   db_fg01.application.arr,   db_fg01.application.len  );
   memcpy(fg01_ptr->rule_domain,   db_fg01.rule_domain.arr,   db_fg01.rule_domain.len  );
   memcpy(fg01_ptr->product,       db_fg01.product.arr,       db_fg01.product.len      );
   memcpy(fg01_ptr->priority,      db_fg01.priority.arr,      db_fg01.priority.len     );
   memcpy(fg01_ptr->tpdu_id,       db_fg01.tpdu_id.arr,       db_fg01.tpdu_id.len      );
   memcpy(fg01_ptr->queue_name,    db_fg01.queue_name.arr,    db_fg01.queue_name.len   );
   memcpy(fg01_ptr->request_timer, db_fg01.request_timer.arr, db_fg01.request_timer.len);
   memcpy(fg01_ptr->echo_timer,    db_fg01.echo_timer.arr,    db_fg01.echo_timer.len   );

   return;
}

/******************************************************************************
 *
 *  NAME:         obs01_to_db
 *
 *  DESCRIPTION:  This function copies an OBS01 record into pte_obs01 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       obs01_ptr - OBS01 structure
 *
 *  OUTPUTS:      pte_obs01 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void obs01_to_db( pOBS01 obs01_ptr )
{
  memcpy (&pte_obs01, obs01_ptr, sizeof(pte_obs01));
}

/******************************************************************************
 *
 *  NAME:         visa3ds2_to_db
 *
 *  DESCRIPTION:  This function copies an VISA3DS2 record into pte_visa3ds2 for
 *                updates, inserts, and deletes.
 *
 *  INPUTS:       visa3ds2_ptr - VISA3DS2 structure
 *
 *  OUTPUTS:      pte_visa3ds2 - Global used to pass info to the database
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
void visa3ds2_to_db( pVISA3DS2 visa3ds2_ptr )
{
  memcpy (&pte_visa3ds2, visa3ds2_ptr, sizeof(pte_visa3ds2));
}

/******************************************************************************
 *
 *  NAME:         db_to_obs01
 *
 *  DESCRIPTION:  This function copies an FG01 record from db_obs01 into
 *                obs01_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      obs01_ptr - OBS01 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
void db_to_obs01 ( pOBS01 obs01_ptr )
{
   memset( obs01_ptr, 0x00, sizeof(OBS01) );

   memcpy(obs01_ptr->on_behalf_service,          db_obs01.on_behalf_service.arr,         db_obs01.on_behalf_service.len 	);
   memcpy(obs01_ptr->on_behalf_result,          db_obs01.on_behalf_result.arr,          db_obs01.on_behalf_result.len  	);
   memcpy(obs01_ptr->description,     db_obs01.description.arr,     			db_obs01.description.len      	);
   memcpy(obs01_ptr->response_code,        db_obs01.response_code.arr,        		db_obs01.response_code.len      );
}

/******************************************************************************
 *
 *  NAME:         db_to_visa3ds2
 *
 *  DESCRIPTION:  This function copies an VISA3DS2 record from db_visa3ds2 into
 *                visa3ds2_ptr.
 *
 *  INPUTS:       None
 *
 *  OUTPUTS:      visa3ds2_ptr - OBS01 structure
 *
 *  RTRN VALUE:   None
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
void db_to_visa3ds2 ( pVISA3DS2 visa3ds2_ptr )
{
   memset( visa3ds2_ptr, 0x00, sizeof(VISA3DS2) );

   memcpy(visa3ds2_ptr->cavv,          db_visa3ds2.cavv.arr,         db_visa3ds2.cavv.len 	);
   memcpy(visa3ds2_ptr->description,     db_visa3ds2.description.arr,     			db_visa3ds2.description.len      	);
   memcpy(visa3ds2_ptr->response_code,        db_visa3ds2.response_code.arr,        		db_visa3ds2.response_code.len      );
}

void Get_LookbackDays_for_Variable_Auth ( )
{
   DWORD rc;
   CHAR  filename     [80] = {0};
   CHAR  tmpstr       [80] = {0};
   CHAR  readstring	  [80] = {0};
   
     /* Get path to the tf.ini file. */
   memset( readstring, 0x00, sizeof(readstring) );
   GetPinnacleConfigDirectory(readstring);
   sprintf(filename, "%stf.ini", readstring);
  
   rc = GetPrivateProfileString(
    "VARIABLE_AUTHORIZATION",    /*  points to section name  */
    "LOOKBACK_DAYS",             /*  points to key name  */
    "30",               		 /*  points to default string  */
    tmpstr,                         /*  points to destination buffer  */
    sizeof(tmpstr) - 1,             /*  size of destination buffer  */
    filename                        /*  points to initialization filename  */
   );
   
   LOOKBACK_DAYS = atoi(tmpstr);

} 
/*************************************************************************************/
/*************************************************************************************/

BYTE db_get_obs01_count(pCHAR obscount, pCHAR ErrorMsg )
{
   INT  retval;

   EXEC SQL BEGIN DECLARE SECTION;
   int NumRowsReturned = 0;
   EXEC SQL END DECLARE SECTION;

   EXEC SQL SELECT COUNT(*) INTO :NumRowsReturned FROM OBS01;
   
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		sprintf(er_buf,"In db_get_obs01_count,ST1:%d,ST2:%d",DB_MsgSubtype1,DB_MsgSubtype2);
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg );
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
	}
   else
   {
      itoa(NumRowsReturned, obscount, 10);
      return PTEMSG_OK;
   }


}
/*************************************************************************************/
/*************************************************************************************/

BYTE db_select_obs01(pCHAR         key, 
                     pOBS01        obs01_ptr,
                     pCHAR         ErrorMsg )
{
   memset( &db_obs01, 0, sizeof( db_obs01 ) );

   strncpy( pte_obs01.on_behalf_service, key, sizeof(pte_obs01.on_behalf_service) );
   strncpy( pte_obs01.on_behalf_result, key + sizeof(pte_obs01.on_behalf_service),
            sizeof(pte_obs01.on_behalf_result) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
      EXEC SQL SELECT *
   INTO :db_obs01
   FROM obs01
   WHERE on_behalf_service   = :pte_obs01.on_behalf_service   AND 
         on_behalf_result = :pte_obs01.on_behalf_result;
         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01 ,Fun_Name : db_select_obs01 , Duration = %f,on_behalf_service: %s,on_behalf_result:%s  ",
		DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
    if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_select_obs01,ST1:%d,ST2:%d,on_behalf_service: %s,on_behalf_result:%s  ",
		DB_MsgSubtype1,DB_MsgSubtype2,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
	}
   db_to_obs01 (obs01_ptr);

   return PTEMSG_OK;

}

/*************************************************************************************/
/*************************************************************************************/
BYTE db_select_visa3ds2(pCHAR         key, 
                     pVISA3DS2        visa3ds2_ptr,
                     pCHAR         ErrorMsg )
{
   memset( &db_visa3ds2, 0, sizeof( db_visa3ds2 ) );

   strncpy( pte_visa3ds2.cavv, key, sizeof(pte_visa3ds2.cavv) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
      EXEC SQL SELECT *
   INTO :db_visa3ds2
   FROM visa3ds2
   WHERE cavv= :pte_visa3ds2.cavv; 

         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2 ,Fun_Name : db_select_visa3ds2 , Duration = %f,cavv:%s, Response_code=%s",
		DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_visa3ds2.cavv,pte_visa3ds2.response_code);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
    if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_select_obs01,ST1:%d,ST2:%d,cavv:%s, Response_code=%s  ",
		DB_MsgSubtype1,DB_MsgSubtype2,pte_visa3ds2.cavv,pte_visa3ds2.response_code);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
	}
   db_to_visa3ds2 (visa3ds2_ptr);

   return PTEMSG_OK;

}


/*************************************************************************************/
/*************************************************************************************/

BYTE db_select_tlf01_for_pulse_reversal (  pAUTH_TX       auth_tx, 
                        pTLF01         tlf01_ptr, 
                        pCHAR          ErrorMsg )
{
   memset( &db_tlf01, 0, sizeof( db_tlf01 ) );
   strncpy( pte_tlf01.card_num , auth_tx->TLF01_details.card_num, sizeof(pte_tlf01.card_num) );
   strncpy( pte_tlf01.retrieval_ref_num, auth_tx->TLF01_details.retrieval_ref_num, sizeof(pte_tlf01.retrieval_ref_num) );
   strncpy( pte_tlf01.sys_trace_audit_num, auth_tx->TLF01_details.sys_trace_audit_num, sizeof(pte_tlf01.sys_trace_audit_num) );
   strncpy( pte_tlf01.message_type, auth_tx->TLF01_details.orig_message, sizeof(pte_tlf01.date_yyyymmdd) );
   
   

	if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }

   EXEC SQL SELECT *
   INTO :db_tlf01
   FROM tlf01
   WHERE card_num 			= :pte_tlf01.card_num 			 AND
   		retrieval_ref_num	= :pte_tlf01.retrieval_ref_num	 AND
   		sys_trace_audit_num	= :pte_tlf01.sys_trace_audit_num AND
   		message_type        = :pte_tlf01.message_type 		 AND
   		response_code       = '00'							 AND
   		rownum				= 1 ORDER BY date_yyyymmdd,time_hhmmss ;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d,Data_Type : TLF01 ,Fun_Name : db_select_tlf01_for_pulse_reversal , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_select_tlf01_for_pulse_reversal,ST1:%d,ST2:%d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
	}
   db_to_tlf01 (tlf01_ptr);

   return PTEMSG_OK;
}

/*************************************************************************************/
BYTE db_select_tlf01_for_MC_purchase_return (  pAUTH_TX       auth_tx, 
                       						   pTLF01         tlf01_ptr, 
                        					   pCHAR          ErrorMsg )
{
   	memset( &db_tlf01, 0, sizeof( db_tlf01 ) );
   	strncpy( pte_tlf01.card_num , auth_tx->TLF01_details.card_num, sizeof(pte_tlf01.card_num) );
    //strncpy( pte_tlf01.retrieval_ref_num, auth_tx->TLF01_details.retrieval_ref_num, sizeof(pte_tlf01.retrieval_ref_num) );
    //strncpy( pte_tlf01.sys_trace_audit_num, auth_tx->TLF01_details.sys_trace_audit_num, sizeof(pte_tlf01.sys_trace_audit_num) );
    strncpy( pte_tlf01.message_type, "0100", 4 );
    strncpy( pte_tlf01.mcard_banknet, auth_tx->TLF01_details.mcard_banknet, sizeof(pte_tlf01.mcard_banknet) );
    strncpy( pte_tlf01.settlement_date, auth_tx->TLF01_details.settlement_date, sizeof(pte_tlf01.settlement_date) );
    strncpy( pte_tlf01.card_num, auth_tx->TLF01_details.card_num, sizeof(pte_tlf01.card_num) );
     
    if ( db_error_statics_flag == true )
    {
      	start_time = ptetime_get_time();
    }

    EXEC SQL SELECT *
    INTO :db_tlf01
    FROM tlf01
    WHERE card_num 			= :pte_tlf01.card_num 			 AND
   		//retrieval_ref_num	= :pte_tlf01.retrieval_ref_num	 AND
   		//sys_trace_audit_num	= :pte_tlf01.sys_trace_audit_num AND
   		message_type        = :pte_tlf01.message_type 		 AND
   		mcard_banknet       = :pte_tlf01.mcard_banknet		 AND
   		settlement_date 	= :pte_tlf01.settlement_date	 AND
   		card_num			= :pte_tlf01.card_num			 AND
   		response_code       = '00'							 AND
   		rownum				= 1 ORDER BY date_yyyymmdd,time_hhmmss ;
   
   if ( db_error_statics_flag == true )
   {
       end_time = ptetime_get_time();
       duration = end_time - start_time;
       if(duration >= db_error_statics_value)
	   {
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d,Data_Type : TLF01 ,Fun_Name : db_select_tlf01_for_pulse_reversal , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	   }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_select_tlf01_for_pulse_reversal,ST1:%d,ST2:%d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
	}
	
   db_to_tlf01 (tlf01_ptr);
   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_select_ncf01
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF01 based on a key value.  The record is
 *                selected into db_ncf01, then copied into ncf01_ptr for
 *                the calling function.
 *
 *  INPUTS:       key - Network Id and Network Type
 *
 *  OUTPUTS:      ncf01_ptr - NCF01 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 *     DI - 03/17/99 - Added receiving_inst_id_code.
 ******************************************************************************/
BYTE db_select_ncf01 (  pCHAR         key, 
                        pNCF01        ncf01_ptr,
                        pCHAR         ErrorMsg )
{
   memset( &db_ncf01, 0, sizeof( db_ncf01 ) );

   strncpy( pte_ncf01.network_id, key, sizeof(pte_ncf01.network_id) );
   strncpy( pte_ncf01.network_type, key + sizeof(pte_ncf01.network_id),
            sizeof(pte_ncf01.network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL SELECT network_id, network_type, name, status, totals_ind,
               statistics_ind, acquirer_inst_id_code, forwarding_inst_id_code, 
               receiving_inst_id_code, 
               remote_nsp_type, pin_type, encr_type, pad_char, cwk, kek, 
               retired_cwk, auto_logon, echo_interval, max_consecutive_timeouts,
               max_active_txns,que_name, local_nsp_type, request_timer,
               idle_line_timer, advice_repeat_counter, admin_message_timer,
               store_forward_processing, currency_code_purchase,
               currency_code_cash, country_code, station_id1 ,station_id2,
               prev_src_station,tpdu_id, identifier1 ,identifier2, identifier3,
               identifier4, identifier5 ,identifier6, identifier7, identifier8,
               identifier9 ,identifier10,processing_code1, processing_code2,
               processing_code3,  processing_code4,  processing_code5,
               processing_code6,  processing_code7,  processing_code8,
               processing_code9,  processing_code10, processing_code11,
               processing_code12, processing_code13, processing_code14,
               processing_code15, processing_code16,processing_code17,
               processing_code18, processing_code19, processing_code20, zmk,
               neg_access_code 
   INTO :db_ncf01
   FROM ncf01
   WHERE network_type = :pte_ncf01.network_type   AND 
         network_id   = :pte_ncf01.network_id ;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_select_ncf01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
      
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf01 ,ST1:%d,ST2:%d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf01 (ncf01_ptr);

   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_select_ncf02
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF02 based on a key value.  The record is
 *                selected into db_ncf02, then copied into ncf02_ptr for
 *                the calling function.
 *
 *  INPUTS:       Primary_key - Network Id and Network Type
 *
 *  OUTPUTS:      ncf02_ptr - NCF02 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_select_ncf02 (  pCHAR          Primary_key, 
                        pNCF02         ncf02_ptr, 
                        pCHAR          ErrorMsg )
{
   memset( &db_ncf02, 0, sizeof( db_ncf02 ) );
   strncpy( pte_ncf02.network_id, Primary_key, sizeof(pte_ncf02.network_id) );
   strncpy( pte_ncf02.network_type, Primary_key+sizeof(pte_ncf02.network_id),
            sizeof(pte_ncf02.network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT *
   INTO :db_ncf02
   FROM ncf02
   WHERE network_id   = :pte_ncf02.network_id   AND 
         network_type = :pte_ncf02.network_type;
         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF02 ,Fun_Name : db_select_ncf02 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_select_ncf02,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf02 (ncf02_ptr);

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_select_ncf20
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF20 based on a key value.  The record is
 *                selected into db_ncf20, then copied into ncf20_ptr for
 *                the calling function.
 *
 *  INPUTS:       key - Network Id and Date in yyyymmdd format
 *
 *  OUTPUTS:      ncf20_ptr - NCF20 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_select_ncf20 (  pCHAR         key, 
                        pNCF20        ncf20_ptr,
                        pCHAR         ErrorMsg )
{
   memset( &db_ncf20, 0, sizeof( db_ncf20 ) );

   strncpy( pte_ncf20.network_id, key,  sizeof(pte_ncf20.network_id) );
   strncpy( pte_ncf20.yyyymmdd,   key + sizeof(pte_ncf20.network_id),
            sizeof(pte_ncf20.yyyymmdd) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT network_id, yyyymmdd, ytd_total_tran_cnt, ytd_total_tran_amt,
               mtd_total_tran_cnt, mtd_total_tran_amt, tran_cnt, tran_amt,
               tran_approved_cnt, tran_declined_cnt,
               category_code1, category_cnt1, category_code2, category_cnt2,
               category_code3, category_cnt3, category_code4, category_cnt4,
               category_code5, category_cnt5, category_code6, category_cnt6,
               category_code7, category_cnt7, category_code8, category_cnt8,
               category_code9, category_cnt9, category_code10, category_cnt10,
               category_code11, category_cnt11, category_code12, category_cnt12,
               category_code13, category_cnt13, category_code14, category_cnt14,
               category_code15, category_cnt15, category_code16, category_cnt16,
               category_code17, category_cnt17, category_code18, category_cnt18,
               category_code19, category_cnt19, category_code20, category_cnt20
   INTO :db_ncf20
   FROM ncf20
   WHERE network_id = :pte_ncf20.network_id   AND 
         yyyymmdd     = :pte_ncf20.yyyymmdd ;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF20 ,Fun_Name : db_select_ncf20 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf20 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf20 (ncf20_ptr);

   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_select_ncf21
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF21 based on a key value.  The record is
 *                selected into db_ncf21, then copied into ncf21_ptr for
 *                the calling function.
 *
 *  INPUTS:       key - Network Id, Network Type and Batch Number
 *
 *  OUTPUTS:      ncf21_ptr - NCF21 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 *      DI - 02/17/99 - Corrected bug getting batch number key.
 *      DI - 01/28/00 - Removed the 'FOR UPDATE' condition.
 ******************************************************************************/
BYTE db_select_ncf21 (  pCHAR         key, 
                        pNCF21        ncf21_ptr,
                        pCHAR         ErrorMsg )
{
   memset( &db_ncf21, 0, sizeof( db_ncf21 ) );

   strncpy( pte_ncf21.network_id, key, sizeof(pte_ncf21.network_id) );
   strncpy( pte_ncf21.network_type, key + sizeof(pte_ncf21.network_id),
            sizeof(pte_ncf21.network_type) );
   strncpy( pte_ncf21.batch_number, key + sizeof(pte_ncf21.network_id)
                                        + sizeof(pte_ncf21.network_type),
            sizeof(pte_ncf21.batch_number) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT network_id, network_type, batch_number,
               open_date, open_time, release_date, release_time,
               credit_cnt, credit_amt, credit_rev_cnt, credit_rev_amt,
               debit_cnt, debit_amt, debit_rev_cnt, debit_rev_amt,
               total_amt, total_amt_type
   INTO :db_ncf21
   FROM ncf21
   WHERE network_type = :pte_ncf21.network_type   AND 
         network_id   = :pte_ncf21.network_id     AND
         batch_number = :pte_ncf21.batch_number;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_select_ncf21 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf21 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf21 (ncf21_ptr);

   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_select_max_batch_ncf21
 *
 *  DESCRIPTION:  This function selects the largest batch number from NCF21
 *                for a Network Id and Network Type.
 *
 *  INPUTS:       key - Network Id, Network Type
 *
 *  OUTPUTS:      BatchNumber - String containing batch number
 *                ErrorMsg    - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_select_max_batch_ncf21 (  pCHAR   key, 
                                  pCHAR   BatchNumber,
                                  pCHAR   ErrorMsg )
{
	EXEC SQL BEGIN DECLARE SECTION;
	   char  d_batch_number[7];
	EXEC SQL END DECLARE SECTION;
	
   strncpy( pte_ncf21.network_id, key, sizeof(pte_ncf21.network_id) );
   strncpy( pte_ncf21.network_type, key + sizeof(pte_ncf21.network_id),
            sizeof(pte_ncf21.network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }

   EXEC SQL SELECT max(batch_number)
   INTO :d_batch_number
   FROM ncf21
   WHERE network_type = :pte_ncf21.network_type   AND 
         network_id   = :pte_ncf21.network_id  AND 
		 batch_number <> 'ACTIVE';
		 
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_select_max_batch_ncf21 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }      
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_max_batch_ncf21 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   strcpy( BatchNumber, d_batch_number );
   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_select_ncf30
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on a key value.  The record is
 *                selected into db_ncf30, then copied into ncf30_ptr for
 *                the calling function.
 *
 *  INPUTS:       key - Network Id, Network Type, Batch Number and RRN
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 ******************************************************************************/
BYTE db_select_ncf30 (  pCHAR         key, 
                        pNCF30        ncf30_ptr,
                        pCHAR         ErrorMsg )
{
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );

   strncpy( pte_ncf30.network_id, key, sizeof(pte_ncf30.network_id) );

   strncpy( pte_ncf30.network_type, key + sizeof(pte_ncf30.network_id),
            sizeof(pte_ncf30.network_type) );

   strncpy( pte_ncf30.batch_number,
            key + sizeof(pte_ncf30.network_id) + sizeof(pte_ncf30.network_type),
            sizeof(pte_ncf30.batch_number) );

   strncpy( pte_ncf30.retrieval_ref_num,
            key + sizeof(pte_ncf30.network_id)
                + sizeof(pte_ncf30.network_type)
                + sizeof(pte_ncf30.batch_number),
            sizeof(pte_ncf30.retrieval_ref_num) );

   strncpy( pte_ncf30.card_nbr,
            key + sizeof(pte_ncf30.network_id)
                + sizeof(pte_ncf30.network_type)
                + sizeof(pte_ncf30.batch_number)
                + sizeof(pte_ncf30.retrieval_ref_num)
                + sizeof(pte_ncf30.open_date)
                + sizeof(pte_ncf30.open_time)
                + sizeof(pte_ncf30.merchant_id)
                + sizeof(pte_ncf30.transaction_id)
                + sizeof(pte_ncf30.device_id)
             ,sizeof(pte_ncf30.card_nbr) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT *
   INTO :db_ncf30
   FROM ncf30
   WHERE network_id        = :pte_ncf30.network_id     AND
         network_type      = :pte_ncf30.network_type   AND 
         batch_number      = :pte_ncf30.batch_number   AND
         retrieval_ref_num = :pte_ncf30.retrieval_ref_num  AND
         card_nbr          = :pte_ncf30.card_nbr;
         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   } 

   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf30 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;

}

BYTE db_select_ncf01_keyblock (  pCHAR         key, 
                        pNCF01_KEYBLOCK        ncf01_keyblock_ptr,
                        pCHAR         ErrorMsg )
{
   memset( &db_ncf01_keyblock, 0, sizeof( db_ncf01_keyblock ) );

   strncpy( pte_ncf01_keyblock.network_id, key, sizeof(pte_ncf01_keyblock.network_id) );

  /* strncpy( pte_ncf01_keyblock.network_type, key + sizeof(pte_ncf01_keyblock.network_id),
            sizeof(pte_ncf01_keyblock.network_type) ); */


   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT *
   INTO :db_ncf01_keyblock
   FROM ncf01_keyblock
   WHERE network_id        = :pte_ncf01_keyblock.network_id;

         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK ,Fun_Name : db_select_ncf01_keyblock , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   } 

   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf01_keyblock ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf01_keyblock (ncf01_keyblock_ptr);

   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_select_ncf30_by_stan
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on the system trace audit number,
 *                card number, and total amount.  The record is selected into
 *                db_ncf30, then copied into ncf30_ptr for the calling function.
 *
 *  INPUTS:       ncf30 structure containing data in fields:
 *                        system trace audit number
 *                        card number
 *                        tran amount
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 ******************************************************************************/
BYTE db_select_ncf30_by_stan(  pNCF30        ncf30_record, 
                               pNCF30        ncf30_ptr,
                               pCHAR         ErrorMsg )
{
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
   memcpy( pte_ncf30.sys_trace_audit_nbr, ncf30_record->sys_trace_audit_nbr,
              sizeof(pte_ncf30.sys_trace_audit_nbr) );
   memcpy( pte_ncf30.card_nbr, ncf30_record->card_nbr,
              sizeof(pte_ncf30.card_nbr) );
   memcpy( pte_ncf30.network_id, ncf30_record->primary_key.network_id,
              sizeof(pte_ncf30.network_id) );
   memcpy( pte_ncf30.network_type, ncf30_record->primary_key.network_type,
              sizeof(pte_ncf30.network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
  // EXEC SQL SELECT /*+ index(NCF30 NCF30_CARD_INDEX) */  *
  EXEC SQL SELECT 	*
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr            = :pte_ncf30.card_nbr             AND
         sys_trace_audit_nbr = :pte_ncf30.sys_trace_audit_nbr  AND
         network_id          = :pte_ncf30.network_id           AND
         network_type        = :pte_ncf30.network_type         AND
         rownum = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30_by_stan , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_select_ncf30_by_stan,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;
}


/******************************************************************************
 *
 *  NAME:         db_select_ncf30_by_stan_for_CUP
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on the system trace audit number,
 *                card number, and total amount.  The record is selected into
 *                db_ncf30, then copied into ncf30_ptr for the calling function.
 *
 *  INPUTS:       ncf30 structure containing data in fields:
 *                        system trace audit number
 *                        card number
 *                        tran amount
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Abhishek Verma
 *
 ******************************************************************************/
BYTE db_select_ncf30_by_stan_for_CUP(  pNCF30        ncf30_record, 
                               pNCF30        ncf30_ptr,
                               pCHAR         ErrorMsg )
{
   BYTE CUP_ACQ_LINK[6]="nccup";
   BYTE CUP_ISU_LINK[7]="nccup3";
   
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
   memcpy( pte_ncf30.sys_trace_audit_nbr, ncf30_record->sys_trace_audit_nbr,
              sizeof(pte_ncf30.sys_trace_audit_nbr) );
   memcpy( pte_ncf30.card_nbr, ncf30_record->card_nbr,
              sizeof(pte_ncf30.card_nbr) );
   memcpy( pte_ncf30.network_id, ncf30_record->primary_key.network_id,
              sizeof(pte_ncf30.network_id) );
   memcpy( pte_ncf30.network_type, ncf30_record->primary_key.network_type,
              sizeof(pte_ncf30.network_type) );

            
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL SELECT 	*
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr            = :pte_ncf30.card_nbr            		 AND
         sys_trace_audit_nbr = :pte_ncf30.sys_trace_audit_nbr  		 AND
         (network_id = :CUP_ACQ_LINK OR network_id = :CUP_ISU_LINK)  AND
         network_type        = :pte_ncf30.network_type         		 AND
         rownum = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30_by_stan_for_CUP , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf30_by_stan_for_CUP ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;
}


/******************************************************************************
 *
 *  NAME:         db_select_ncf30_by_termid
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on the device Id,
 *                card number, and total amount.  The record is selected into
 *                db_ncf30, then copied into ncf30_ptr for the calling function.
 *
 *  INPUTS:       ncf30 structure containing data in fields:
 *                        device Id
 *                        card number
 *                        tran amount
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 ******************************************************************************/
BYTE db_select_ncf30_by_termid(  pNCF30        ncf30_record, 
                                 pNCF30        ncf30_ptr,
                                 pCHAR         ErrorMsg )
{
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
   memcpy( pte_ncf30.device_id, ncf30_record->device_id,
              sizeof(pte_ncf30.device_id) );
   memcpy( pte_ncf30.card_nbr, ncf30_record->card_nbr,
              sizeof(pte_ncf30.card_nbr) );
   memcpy( pte_ncf30.tran_amount, ncf30_record->tran_amount,
              sizeof(pte_ncf30.tran_amount) );
   memcpy( pte_ncf30.network_id, ncf30_record->primary_key.network_id,
              sizeof(pte_ncf30.network_id) );
   memcpy( pte_ncf30.network_type, ncf30_record->primary_key.network_type,
              sizeof(pte_ncf30.network_type) );




//   EXEC SQL SELECT /*+ index(NCF30 NCF30_CARD_INDEX) */  *
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT   *
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr      = :pte_ncf30.card_nbr        AND
         device_id     = :pte_ncf30.device_id       AND
         tran_amount   = :pte_ncf30.tran_amount     AND
         network_id    = :pte_ncf30.network_id      AND
         network_type  = :pte_ncf30.network_type    AND
         rownum = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30_by_termid , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf30_by_termid ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_select_ncf30_by_card
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on the card number, total_amount,
 *                processing code, currency_code and auth_number.  The record
 *                is selected into db_ncf30, then copied into ncf30_ptr for
 *                the calling function.
 *
 *  INPUTS:       ncf30 structure containing data in fields:
 *                        card number
 *                        tran amount
 *                        processing code
 *                        currency code
 *                        auth_number
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 ******************************************************************************/
BYTE db_select_ncf30_by_card(  pNCF30        ncf30_record, 
                               pNCF30        ncf30_ptr,
                               pCHAR         ErrorMsg )
{
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
   memcpy( pte_ncf30.card_nbr, ncf30_record->card_nbr,
              sizeof(pte_ncf30.card_nbr) );
   memcpy( pte_ncf30.tran_amount, ncf30_record->tran_amount,
              sizeof(pte_ncf30.tran_amount) );
   memcpy( pte_ncf30.processing_code, ncf30_record->processing_code,
              sizeof(pte_ncf30.processing_code) );
   memcpy( pte_ncf30.currency_code, ncf30_record->currency_code,
              sizeof(pte_ncf30.currency_code) );
   memcpy( pte_ncf30.retrieval_ref_num,
              ncf30_record->primary_key.retrieval_ref_num,
              sizeof(pte_ncf30.retrieval_ref_num) );
   memcpy( pte_ncf30.network_id, ncf30_record->primary_key.network_id,
              sizeof(pte_ncf30.network_id) );
   memcpy( pte_ncf30.network_type, ncf30_record->primary_key.network_type,
              sizeof(pte_ncf30.network_type) );





//   EXEC SQL SELECT /*+ index(NCF30 NCF30_CARD_INDEX) */  *
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT *
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr               = :pte_ncf30.card_nbr             AND
         retrieval_ref_num      = :pte_ncf30.retrieval_ref_num    AND
         tran_amount            = :pte_ncf30.tran_amount          AND
         processing_code        = :pte_ncf30.processing_code      AND
         currency_code          = :pte_ncf30.currency_code        AND
         network_id             = :pte_ncf30.network_id           AND
         network_type           = :pte_ncf30.network_type         AND
         rownum = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30_by_card , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg  );
		sprintf(er_buf,"In db_select_ncf30_by_card ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_select_ncf30_by_merchant_id
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on the merchant Id, currency_code,
 *                card number, and total amount.  The record is selected into
 *                db_ncf30, then copied into ncf30_ptr for the calling function.
 *
 *  INPUTS:       ncf30 structure containing data in fields:
 *                        merchant Id
 *                        card number
 *                        tran amount
 *                        currency code
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 ******************************************************************************/
BYTE db_select_ncf30_by_merchant_id(  pNCF30        ncf30_record, 
                                      pNCF30        ncf30_ptr,
                                      pCHAR         ErrorMsg )
{
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
   memcpy( pte_ncf30.merchant_id, ncf30_record->merchant_id,
              sizeof(pte_ncf30.merchant_id) );
   memcpy( pte_ncf30.card_nbr, ncf30_record->card_nbr,
              sizeof(pte_ncf30.card_nbr) );
   memcpy( pte_ncf30.tran_amount, ncf30_record->tran_amount,
              sizeof(pte_ncf30.tran_amount) );
   memcpy( pte_ncf30.currency_code, ncf30_record->currency_code,
              sizeof(pte_ncf30.currency_code) );
   memcpy( pte_ncf30.network_id, ncf30_record->primary_key.network_id,
              sizeof(pte_ncf30.network_id) );
   memcpy( pte_ncf30.network_type, ncf30_record->primary_key.network_type,
              sizeof(pte_ncf30.network_type) );





//   EXEC SQL SELECT /*+ index(NCF30 NCF30_CARD_INDEX) */  *
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT   *
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr        = :pte_ncf30.card_nbr          AND
         merchant_id     = :pte_ncf30.merchant_id       AND
         tran_amount     = :pte_ncf30.tran_amount       AND
         currency_code   = :pte_ncf30.currency_code     AND
         network_id      = :pte_ncf30.network_id        AND
         network_type    = :pte_ncf30.network_type      AND
         rownum = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30_by_merchant_id , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf30_by_merchant_id ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_select_ncf30_by_merchant_id_for_CUP
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on the merchant Id, currency_code,
 *                card number, and total amount.  The record is selected into
 *                db_ncf30, then copied into ncf30_ptr for the calling function.
 *
 *  INPUTS:       ncf30 structure containing data in fields:
 *                        merchant Id
 *                        card number
 *                        tran amount
 *                        currency code
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 ******************************************************************************/
BYTE db_select_ncf30_by_merchant_id_for_CUP(  pNCF30        ncf30_record, 
                                      pNCF30        ncf30_ptr,
                                      pCHAR         ErrorMsg )
{

	BYTE CUP_ACQ_LINK[6]="nccup";
    BYTE CUP_ISU_LINK[7]="nccup3";
    
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
   memcpy( pte_ncf30.merchant_id, ncf30_record->merchant_id,
              sizeof(pte_ncf30.merchant_id) );
   memcpy( pte_ncf30.card_nbr, ncf30_record->card_nbr,
              sizeof(pte_ncf30.card_nbr) );
   memcpy( pte_ncf30.tran_amount, ncf30_record->tran_amount,
              sizeof(pte_ncf30.tran_amount) );
   memcpy( pte_ncf30.currency_code, ncf30_record->currency_code,
              sizeof(pte_ncf30.currency_code) );
   memcpy( pte_ncf30.network_id, ncf30_record->primary_key.network_id,
              sizeof(pte_ncf30.network_id) );
   memcpy( pte_ncf30.network_type, ncf30_record->primary_key.network_type,
              sizeof(pte_ncf30.network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT   *
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr        = :pte_ncf30.card_nbr          			AND
         merchant_id     = :pte_ncf30.merchant_id       			AND
         tran_amount     = :pte_ncf30.tran_amount       			AND
         currency_code   = :pte_ncf30.currency_code    				AND
        (network_id = :CUP_ACQ_LINK OR network_id = :CUP_ISU_LINK)  AND
         network_type    = :pte_ncf30.network_type      			AND
         rownum = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30_by_merchant_id_for_CUP , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf30_by_merchant_id_for_CUP ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;
}


/******************************************************************************
 *
 *  NAME:         db_select_ncf30_by_rrn_and_terminal
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on the terminal Id and retrieval
 *                reference number (RRN).  The record is selected into
 *                db_ncf30, then copied into ncf30_ptr for the calling function.
 *
 *  INPUTS:       ncf30 structure containing data in fields:
 *                        terminal Id
 *                        retrieval reference number
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       D Irby
 *
 ******************************************************************************/
BYTE db_select_ncf30_by_rrn_and_terminal(  pNCF30        ncf30_record, 
                                           pNCF30        ncf30_ptr,
                                           pCHAR         ErrorMsg )
{
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
   memcpy( pte_ncf30.device_id, ncf30_record->device_id,
              sizeof(pte_ncf30.device_id) );
   memcpy( pte_ncf30.retrieval_ref_num,
              ncf30_record->primary_key.retrieval_ref_num,
              sizeof(pte_ncf30.retrieval_ref_num) );
   memcpy( pte_ncf30.network_id, ncf30_record->primary_key.network_id,
              sizeof(pte_ncf30.network_id) );
   memcpy( pte_ncf30.network_type, ncf30_record->primary_key.network_type,
              sizeof(pte_ncf30.network_type) );

   
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL SELECT *
   INTO :db_ncf30
   FROM ncf30
   WHERE
         network_id        = :pte_ncf30.network_id        AND
         network_type      = :pte_ncf30.network_type      AND
         retrieval_ref_num = :pte_ncf30.retrieval_ref_num AND
         device_id         = :pte_ncf30.device_id         AND
         rownum = 1;
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30_by_rrn_and_terminal , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf30_by_rrn_and_terminal ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_select_ncf30_for_voice
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NCF30 based on card number, amount, and
 *                approval code.  The record is selected into db_ncf30,
 *                then copied into ncf30_ptr for the calling function.
 *
 *  INPUTS:       ncf30 structure containing data in fields:
 *                        card number
 *                        amount
 *                        approval code
 *
 *  OUTPUTS:      ncf30_ptr - NCF30 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       D Irby
 *
 ******************************************************************************/
BYTE db_select_ncf30_for_voice( pNCF30 ncf30_record,
                                pNCF30 ncf30_ptr,
                                pCHAR  ErrorMsg )
{
   memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
   memcpy( pte_ncf30.card_nbr,
           ncf30_record->card_nbr,
           sizeof(pte_ncf30.card_nbr) );

   memcpy( pte_ncf30.tran_amount,
           ncf30_record->tran_amount,
           sizeof(pte_ncf30.tran_amount) );

   memcpy( pte_ncf30.auth_number,
           ncf30_record->auth_number,
           sizeof(pte_ncf30.auth_number) );

 
//   EXEC SQL SELECT /*+ index(NCF30 NCF30_CARD_INDEX) */  *
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL SELECT   *
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr    = :pte_ncf30.card_nbr
     AND auth_number = :pte_ncf30.auth_number
     AND tran_amount = :pte_ncf30.tran_amount
     AND rownum      = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_ncf30_for_voice , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_ncf30_for_voice ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

   return PTEMSG_OK;
}

#ifdef AMEX03A
BYTE db_select_and_update_ncf30_for_Incrementalauthorization( pNCF30 ncf30_record,pNCF30 ncf30_ptr,pCHAR  ErrorMsg )
{
   CHAR  current_date [ 9] = {0}, look_back_date[9]={0};
   LONG  current_julian_date=0,lookback_julian_date=0;
   CHAR  incremental_txn_amount[13]={0}, actual_total_amount[13]={0};
   double total_amount=0, incremental_amount=0, actual_amount=0;
   char estimated_txn_key[8]={0};

	memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
	
	memcpy( pte_ncf30.card_nbr,ncf30_record->card_nbr,sizeof(pte_ncf30.card_nbr) );
   	memcpy( pte_ncf30.merchant_id,ncf30_record->merchant_id,sizeof(pte_ncf30.merchant_id) );
    memcpy( pte_ncf30.tran_fee_amount,ncf30_record->tran_fee_amount,sizeof(pte_ncf30.tran_fee_amount) );
    memcpy( pte_ncf30.open_time,ncf30_record->open_time,6 );
    memcpy( incremental_txn_amount,ncf30_record->network_data,12 );
    strncpy(estimated_txn_key,ESTIMATED_TRANSACTION_KEY,7);
    
    if (LOOKBACK_DAYS == 0)
    {
    	Get_LookbackDays_for_Variable_Auth();
    }
	create_system_date(current_date );
	current_julian_date =  Txutils_Calculate_Julian_Date (current_date);
	lookback_julian_date = current_julian_date - LOOKBACK_DAYS;
    Txutils_Calculate_Gregorian_Date(lookback_julian_date,look_back_date);
   
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL SELECT   *
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr    = :pte_ncf30.card_nbr
     AND merchant_id = :pte_ncf30.merchant_id
     AND open_time = :pte_ncf30.open_time
     AND tran_fee_amount = :pte_ncf30.tran_fee_amount
     AND (tran_date <= :current_date AND tran_date >= :look_back_date) 
     AND open_date =:estimated_txn_key
     AND rownum      = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_and_update_ncf30_for_Incrementalauthorization , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_and_update_ncf30_for_Incrementalauthorization ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);
   
   /*now add the incremental amount to the estimated authrization transaction to keep track the total amount*/
   
   if(ncf30_ptr->network_data[0] != '\0')
   {
   		total_amount = atoi(ncf30_ptr->network_data);
   		incremental_amount = atoi(incremental_txn_amount);
   		actual_amount = total_amount+incremental_amount;
   		
   		itoa(actual_amount, actual_total_amount,10);
   		Rj_with_lead_zeros(actual_total_amount, 12);
   		
   		memcpy(pte_ncf30.network_data,actual_total_amount,12);
   		
	   	if ( db_error_statics_flag == true )
	   {
	      start_time = ptetime_get_time();
	   }
 		EXEC SQL UPDATE ncf30
   			 SET    network_data =   :pte_ncf30.network_data        
		   WHERE card_nbr    = :pte_ncf30.card_nbr
		     AND merchant_id = :pte_ncf30.merchant_id
		     AND open_time = :pte_ncf30.open_time
		     AND tran_fee_amount = :pte_ncf30.tran_fee_amount
		     AND (tran_date <= :current_date AND tran_date >= :look_back_date)  
		     AND open_date =:estimated_txn_key
		     AND rownum      = 1;
	   
	   if ( db_error_statics_flag == true )
	   {
	      end_time = ptetime_get_time();
	      duration = end_time - start_time;
	      if(duration >= db_error_statics_value)
		  {
		  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_and_update_ncf30_for_Incrementalauthorization_1 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
		  }
	   }
	   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
	   {
			memset(er_buf,0x00,sizeof(er_buf));
			DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
			sprintf(er_buf,"In db_select_and_update_ncf30_for_Incrementalauthorization_1 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
			strcat(er_buf,ErrorMsg);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
			return DB_rcode;
	   }
   }
   else
   {
   		return TOTAL_AMOUNT_EMPTY;
   }

   return PTEMSG_OK;
}

BYTE db_select_and_update_ncf30_for_Partialreversalauthorization( pNCF30 ncf30_record,pNCF30 ncf30_ptr,pCHAR  ErrorMsg )
{
   CHAR  current_date [ 9] = {0}, look_back_date[9]={0};
   LONG  current_julian_date=0,lookback_julian_date=0;
   CHAR  partial_txn_amount[13]={0}, actual_total_amount[13]={0};
   double total_amount=0, partial_amount=0, actual_amount=0;
	CHAR estimated_txn_key[8]={0};
   LONG   returncode = 0;
   double conv_rate = 0;
   CRF01  crf01;      
   
	
	memset( &db_ncf30, 0, sizeof( db_ncf30 ) );
	
	memcpy( pte_ncf30.card_nbr,ncf30_record->card_nbr,sizeof(pte_ncf30.card_nbr) );
   	memcpy( pte_ncf30.merchant_id,ncf30_record->merchant_id,sizeof(pte_ncf30.merchant_id) );
    memcpy( pte_ncf30.tran_fee_amount,ncf30_record->tran_fee_amount,sizeof(pte_ncf30.tran_fee_amount) );
    memcpy( pte_ncf30.open_time,ncf30_record->open_time,6 );
    memcpy( pte_ncf30.tran_amount,ncf30_record->tran_amount,sizeof(pte_ncf30.tran_amount) );
    memcpy( partial_txn_amount,ncf30_record->network_data,12 );
    strncpy(estimated_txn_key,ESTIMATED_TRANSACTION_KEY,7);
      
    // convert the settlement_total (always USD) to PESOs
     strcpy( crf01.primary_key.currency_code, PESO);

     // get conversion value to convert from USD to PESOs
     returncode = FindMemRecord((pBYTE)&crf01,
                                 sizeof(crf01.primary_key.currency_code),
                                 sizeof(crf01),
                                "Crf01Table");
	if ( returncode < 0)
	{	                               
		conv_rate = 1.0;
	}                             
	conv_rate = strtod(crf01.conversion_rate, 0);                                

    if (LOOKBACK_DAYS == 0)
    {
    	Get_LookbackDays_for_Variable_Auth();
    }
	create_system_date(current_date );
	current_julian_date =  Txutils_Calculate_Julian_Date (current_date);
	lookback_julian_date = current_julian_date - LOOKBACK_DAYS;
    Txutils_Calculate_Gregorian_Date(lookback_julian_date,look_back_date);
   
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL SELECT   *
   INTO :db_ncf30
   FROM ncf30
   WHERE card_nbr    = :pte_ncf30.card_nbr
     AND merchant_id = :pte_ncf30.merchant_id
     AND open_time = :pte_ncf30.open_time
     AND tran_amount = :pte_ncf30.tran_amount
     AND tran_fee_amount = :pte_ncf30.tran_fee_amount
     AND (tran_date <= :current_date AND tran_date >= :look_back_date)  
     AND open_date =:estimated_txn_key
     AND rownum      = 1;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_and_update_ncf30_for_Partialreversalauthorization , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_and_update_ncf30_for_Partialreversalauthorization ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_ncf30 (ncf30_ptr);

 /*now subtract the partial reversal amount from the total amount stored in the network_data*/

   if(ncf30_ptr->network_data[0] != '\0')
   {
   		total_amount = atoi(ncf30_ptr->network_data);
   		total_amount = total_amount * conv_rate;
   		
   		 partial_amount = atoi(partial_txn_amount);
   		 partial_amount = partial_amount * conv_rate;
   		 
   		 if(total_amount >= partial_amount)
   		 {
   		 	actual_amount = total_amount-partial_amount;
   		 }
   		 else
   		 {
   		 	return PARTIAL_AMOUNT_EXCEEDED_TOTAL_AMOUNT;
   		 }
   		 
   		itoa(actual_amount, actual_total_amount,10);
   		Rj_with_lead_zeros(actual_total_amount, 12);
   		
	   	if ( db_error_statics_flag == true )
	   {
	      start_time = ptetime_get_time();
	   }
 		EXEC SQL UPDATE ncf30
   			 SET    network_data =   :actual_total_amount        
		   WHERE card_nbr    = :pte_ncf30.card_nbr
		     AND merchant_id = :pte_ncf30.merchant_id
		     AND open_time = :pte_ncf30.open_time
		     AND tran_fee_amount = :pte_ncf30.tran_fee_amount
		     AND (tran_date <= :current_date AND tran_date >= :look_back_date)  
		     AND open_date =:estimated_txn_key 
		     AND rownum      = 1;
	   
	   if ( db_error_statics_flag == true )
	   {
	      end_time = ptetime_get_time();
	      duration = end_time - start_time;
	      if(duration >= db_error_statics_value)
		  {
		  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_select_and_update_ncf30_for_Partialreversalauthorization_1 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
		  }
	   }
	   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
	   {
			memset(er_buf,0x00,sizeof(er_buf));
			DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
			sprintf(er_buf,"In db_select_and_update_ncf30_for_Partialreversalauthorization_1 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
			strcat(er_buf,ErrorMsg);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
			return DB_rcode;
	   }
   }
   else
   {
   		return TOTAL_AMOUNT_EMPTY;
   }
 
   return PTEMSG_OK;
}
#endif
/******************************************************************************
 *
 *  NAME:         db_select_atm01
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from ATM01 based on a key value.  The record is
 *                selected into db_atm01, then copied into atm01_ptr for
 *                the calling function.
 *
 *  INPUTS:       key - bkcb_name and termnumr
 *
 *  OUTPUTS:      atm01_ptr - ATM01 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_select_atm01 (  pCHAR         key, 
                        pATM01        atm01_ptr,
                        pCHAR         ErrorMsg )
{
   memset( &db_atm01, 0, sizeof( db_atm01 ) );

   strncpy( pte_atm01.bkcb_name, key, sizeof(pte_atm01.bkcb_name) );
   strncpy( pte_atm01.termnumr, key + sizeof(pte_atm01.bkcb_name),
            sizeof(pte_atm01.termnumr) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL SELECT bkcb_name, termnumr, bourder, mnemonic, brchname,
               termsite, termaddr, termdist, termcimu, termprov, termregn,
               machtype, termodel, dateinst, termloc, termtype, refnum, linktype
   INTO :db_atm01
   FROM atm01
   WHERE bkcb_name = :pte_atm01.bkcb_name   AND 
         termnumr  = :pte_atm01.termnumr ;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : ATM01 ,Fun_Name : db_select_atm01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   } 
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_atm01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_atm01 (atm01_ptr);

   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_select_neg01
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NEG01 based on a key value.  The record is
 *                selected into db_neg01, then copied into neg01_ptr for
 *                the calling function.
 *
 *  INPUTS:       key - card number and card type
 *
 *  OUTPUTS:      neg01_ptr - NEG01 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_select_neg01 (  pCHAR         key, 
                        pNEG01        neg01_ptr,
                        pCHAR         ErrorMsg )
{
   memset( &db_neg01, 0, sizeof( db_neg01 ) );

   strncpy( pte_neg01.card_nbr, key, sizeof(pte_neg01.card_nbr) );
   strncpy( pte_neg01.card_type, key + sizeof(pte_neg01.card_nbr),
            sizeof(pte_neg01.card_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT card_nbr, card_type, card_exten, card_status
   INTO :db_neg01
   FROM neg01
   WHERE card_nbr  = :pte_neg01.card_nbr  AND 
         card_type = :pte_neg01.card_type ;
         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NEG01 ,Fun_Name : db_select_neg01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_neg01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_neg01 (neg01_ptr);

   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_select_neg01_by_card_num
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from NEG01 based on a card number.  The record is
 *                selected into db_neg01, then copied into neg01_ptr for
 *                the calling function.
 *
 *  INPUTS:       key - card number and card type
 *
 *  OUTPUTS:      neg01_ptr - NEG01 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_select_neg01_by_card_num (  pCHAR         key, 
                                    pNEG01        neg01_ptr,
                                    pCHAR         ErrorMsg )
{
   memset( &db_neg01, 0, sizeof( db_neg01 ) );

   strncpy( pte_neg01.card_nbr, key, sizeof(pte_neg01.card_nbr) );
  
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT card_nbr, card_type, card_exten, card_status
   INTO :db_neg01
   FROM neg01
   WHERE card_nbr  = :pte_neg01.card_nbr;
      
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NEG01 ,Fun_Name : db_select_neg01_by_card_num , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }   
      
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_select_neg01_by_card_num,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_neg01 (neg01_ptr);

   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_select_saf01
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from SAF01 based on a key value.  The record is
 *                selected into db_saf01, then copied into saf01_ptr for
 *                the calling function.
 *
 *  INPUTS:       saf01 structure containing data in field handler_queue.
 *
 *  OUTPUTS:      saf01_ptr - SAF01 structure containing the selected record
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_select_saf01 (  pSAF01        saf01_record, 
                        pSAF01        saf01_ptr,
                        pCHAR         ErrorMsg )
{
   memset( &db_saf01, 0, sizeof( db_saf01 ) );
   memcpy( pte_saf01.handler_queue, saf01_record->handler_queue,
              sizeof(pte_saf01.handler_queue) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }

   EXEC SQL SELECT *
   INTO :db_saf01
   FROM saf01
   WHERE rownum = 1    AND
         handler_queue = :pte_saf01.handler_queue ;
      
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : SAF01 ,Fun_Name : db_select_saf01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }   
      
   if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_saf01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   db_to_saf01 (saf01_ptr);

   return PTEMSG_OK;

}

/******************************************************************************
 *
 *  NAME:         db_update_ncf01
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in NCF01 based on a key values in ncf01_ptr.
 *                The record is copied into pte_ncf01, then the database is
 *                updated.
 *
 *  INPUTS:       ncf01_ptr - NCF01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 *     DI - 03/17/99 - Added receiving_inst_id_code.
 ******************************************************************************/
BYTE db_update_ncf01( pNCF01 ncf01_ptr, pCHAR ErrorMsg )
{
   ncf01_to_db( ncf01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }

   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf01
      FROM   NCF01
      WHERE  network_id   = :pte_ncf01.network_id
        AND  network_type = :pte_ncf01.network_type
        AND  rownum		  = 1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_update_ncf01_S , Duration = %f, network id:%s, Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf01.network_id,pte_ncf01.network_type);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf01 ,ST1:%d,ST2: %d_1network id:%s, Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf01.network_id,pte_ncf01.network_type);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL UPDATE ncf01
   SET   network_id                 = :pte_ncf01.network_id,
     network_type                   = :pte_ncf01.network_type,
     name                           = :pte_ncf01.name,
     status                         = :pte_ncf01.status,
     totals_ind                     = :pte_ncf01.totals_ind,
     statistics_ind                 = :pte_ncf01.statistics_ind,
     acquirer_inst_id_code          = :pte_ncf01.acquirer_inst_id_code,
     forwarding_inst_id_code        = :pte_ncf01.forwarding_inst_id_code,
     receiving_inst_id_code         = :pte_ncf01.receiving_inst_id_code,
     remote_nsp_type                = :pte_ncf01.remote_nsp_type,
     pin_type                       = :pte_ncf01.pin_type,
     encr_type                      = :pte_ncf01.encr_type,
     pad_char                       = :pte_ncf01.pad_char,
     cwk                            = :pte_ncf01.cwk,
     kek                            = :pte_ncf01.kek,
     retired_cwk                    = :pte_ncf01.retired_cwk,
     auto_logon                     = :pte_ncf01.auto_logon,
     echo_interval                  = :pte_ncf01.echo_interval,
     max_consecutive_timeouts       = :pte_ncf01.max_consecutive_timeouts,
     max_active_txns                = :pte_ncf01.max_active_txns,
     que_name                       = :pte_ncf01.que_name,
     local_nsp_type                 = :pte_ncf01.local_nsp_type,
     request_timer                  = :pte_ncf01.request_timer,
     idle_line_timer                = :pte_ncf01.idle_line_timer,
     advice_repeat_counter          = :pte_ncf01.advice_repeat_counter,
     admin_message_timer            = :pte_ncf01.admin_message_timer,  
     store_forward_processing       = :pte_ncf01.store_forward_processing,
     currency_code_purchase         = :pte_ncf01.currency_code_purchase, 
     currency_code_cash             = :pte_ncf01.currency_code_cash, 
     country_code                   = :pte_ncf01.country_code,
     station_id1                    = :pte_ncf01.station_id1,
     station_id2                    = :pte_ncf01.station_id2,
     prev_src_station               = :pte_ncf01.prev_src_station,
     tpdu_id                        = :pte_ncf01.tpdu_id,
     identifier1                    = :pte_ncf01.identifier1,
     identifier2                    = :pte_ncf01.identifier2,
     identifier3                    = :pte_ncf01.identifier3,
     identifier4                    = :pte_ncf01.identifier4, 
     identifier5                    = :pte_ncf01.identifier5,
     identifier6                    = :pte_ncf01.identifier6, 
     identifier7                    = :pte_ncf01.identifier7,
     identifier8                    = :pte_ncf01.identifier8, 
     identifier9                    = :pte_ncf01.identifier9,
     identifier10                   = :pte_ncf01.identifier10,
     processing_code1               = :pte_ncf01.processing_code1,  
     processing_code2               = :pte_ncf01.processing_code2,
     processing_code3               = :pte_ncf01.processing_code3,  
     processing_code4               = :pte_ncf01.processing_code4,  
     processing_code5               = :pte_ncf01.processing_code5,  
     processing_code6               = :pte_ncf01.processing_code6,  
     processing_code7               = :pte_ncf01.processing_code7,  
     processing_code8               = :pte_ncf01.processing_code8,  
     processing_code9               = :pte_ncf01.processing_code9,  
     processing_code10              = :pte_ncf01.processing_code10, 
     processing_code11              = :pte_ncf01.processing_code11, 
     processing_code12              = :pte_ncf01.processing_code12, 
     processing_code13              = :pte_ncf01.processing_code13, 
     processing_code14              = :pte_ncf01.processing_code14, 
     processing_code15              = :pte_ncf01.processing_code15, 
     processing_code16              = :pte_ncf01.processing_code16,
     processing_code17              = :pte_ncf01.processing_code17,
     processing_code18              = :pte_ncf01.processing_code18, 
     processing_code19              = :pte_ncf01.processing_code19, 
     processing_code20              = :pte_ncf01.processing_code20,       
     zmk                            = :pte_ncf01.zmk,
     neg_access_code                = :pte_ncf01.neg_access_code

   WHERE network_id                 = :pte_ncf01.network_id AND
     network_type                   = :pte_ncf01.network_type;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_update_ncf01_U , Duration = %f, network id:%s, Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf01.network_id,pte_ncf01.network_type);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }    
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf01 ,ST1:%d,ST2: %d_2,network id:%s, Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf01.network_id,pte_ncf01.network_type);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_update_ncf02
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in NCF02 based on a key values in ncf02_ptr.
 *                The record is copied into pte_ncf02, then the database is
 *                updated.
 *
 *  INPUTS:       ncf02_ptr - NCF02 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_ncf02( pNCF02 ncf02_ptr, pCHAR ErrorMsg )
{
   ncf02_to_db( ncf02_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf02
      FROM   NCF02
      WHERE  network_id   = :pte_ncf02.network_id
        AND  network_type = :pte_ncf02.network_type
        AND  rownum       = 1
      For Update NOWAIT;
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF02 ,Fun_Name : db_update_ncf02_S , Duration = %f,network id:%s, Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf02.network_id,pte_ncf02.network_type);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   } 
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf02 ,ST1:%d,ST2: %d_1,network id:%s, Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf02.network_id,pte_ncf02.network_type);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL UPDATE ncf02
   SET   network_id                          =   :pte_ncf02.network_id,    
         network_type                        =   :pte_ncf02.network_type,         

     credit_cnt                              =   :pte_ncf02.credit_cnt,          
     credit_reversal_cnt                     =   :pte_ncf02.credit_reversal_cnt, 
     debit_cnt                               =   :pte_ncf02.debit_cnt,           
     debit_reversal_cnt                      =   :pte_ncf02.debit_reversal_cnt,  
     transfer_cnt                            =   :pte_ncf02.transfer_cnt,        
     transfer_reversal_cnt                   =   :pte_ncf02.transfer_reversal_cnt,
     inquiries_cnt                           =   :pte_ncf02.inquiries_cnt,        
     authorizations_cnt                      =   :pte_ncf02.authorizations_cnt,   
     credit_proc_fee_amt                     =   :pte_ncf02.credit_proc_fee_amt,  
     credit_tran_fee_amt                     =   :pte_ncf02.credit_tran_fee_amt,  
     debit_proc_fee_amt                      =   :pte_ncf02.debit_proc_fee_amt,   
     debit_tran_fee_amt                      =   :pte_ncf02.debit_tran_fee_amt,   
     credit_amt                              =   :pte_ncf02.credit_amt,           
     credit_reversal_amt                     =   :pte_ncf02.credit_reversal_amt,  
     debit_amt                               =   :pte_ncf02.debit_amt,            
     debit_reversal_amt                      =   :pte_ncf02.debit_reversal_amt,   
     net_settlement_amt                      =   :pte_ncf02.net_settlement_amt

   WHERE  network_id     =   :pte_ncf02.network_id    AND   
            network_type =   :pte_ncf02.network_type;         
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF02 ,Fun_Name : db_update_ncf02_U , Duration = %f,network id:%s, Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf02.network_id,pte_ncf02.network_type);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf02 ,ST1:%d,ST2: %d_2,network id:%s, Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf02.network_id,pte_ncf02.network_type);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

BYTE db_update_obs01( pOBS01 obs01_ptr, pCHAR ErrorMsg )
{
   obs01_to_db( obs01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL SELECT *
   INTO :db_obs01
   FROM obs01
   WHERE on_behalf_service   = :pte_obs01.on_behalf_service   AND 
         on_behalf_result 	 = :pte_obs01.on_behalf_result    AND  
         rownum       = 1
         For Update NOWAIT;
         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01 ,Fun_Name : db_update_obs01_S , Duration = %f,on_behalf_service: %s,on_behalf_result:%s  ",
		DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   } 
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_obs01 ,ST1:%d,ST2: %d_1, on_behalf_service: %s,on_behalf_result:%s  ",
		DB_MsgSubtype1,DB_MsgSubtype2,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
      EXEC SQL UPDATE obs01
      SET   on_behalf_service	=   :pte_obs01.on_behalf_service,    
            on_behalf_result    =   :pte_obs01.on_behalf_result,         
     		description         =   :pte_obs01.description,          
     		response_code 		=   :pte_obs01.response_code 
        WHERE  on_behalf_service     	=   :pte_obs01.on_behalf_service	AND   
               on_behalf_result 		=   :pte_obs01.on_behalf_result;         
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01 ,Fun_Name : db_update_obs01_U , Duration = %f,on_behalf_service:%s, on_behalf_result: %s",
		DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_obs01 ,ST1:%d,ST2: %d_2,on_behalf_service:%s, on_behalf_result: %s",
		DB_MsgSubtype1,DB_MsgSubtype2,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}
/******************************************************************************/

BYTE db_update_visa3ds2( pVISA3DS2 visa3ds2_ptr, pCHAR ErrorMsg )
{
   visa3ds2_to_db( visa3ds2_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL SELECT *
   INTO :db_visa3ds2
   FROM VISA3DS2
   WHERE cavv   = :pte_visa3ds2.cavv AND 
         rownum       = 1
         For Update NOWAIT;
         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2 ,Fun_Name : db_update_obs01_S , Duration = %f,cavv:%s  ",
		DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_visa3ds2.cavv);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   } 
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_obs01 ,ST1:%d,ST2: %d_1, cavv:%s ",
		DB_MsgSubtype1,DB_MsgSubtype2,pte_visa3ds2.cavv);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
      EXEC SQL UPDATE VISA3DS2
      SET   cavv				=   :pte_visa3ds2.cavv,             
     		description         =   :pte_visa3ds2.description,          
     		response_code 		=   :pte_visa3ds2.response_code 
        WHERE  cavv     		=   :pte_visa3ds2.cavv;	              
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2 ,Fun_Name : db_update_visa3ds2 , Duration = %f,cavv:%s ",
		DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_visa3ds2.cavv);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_obs01 ,ST1:%d,ST2: %d_2,cavv:%s",
		DB_MsgSubtype1,DB_MsgSubtype2,pte_visa3ds2.cavv);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}
/******************************************************************************
 *
 *  NAME:         db_update_ncf20
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in NCF20 based on a key values in ncf20_ptr.
 *                The record is copied into pte_ncf20, then the database is
 *                updated.
 *
 *  INPUTS:       ncf20_ptr - NCF20 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_ncf20( pNCF20 ncf20_ptr, pCHAR ErrorMsg )
{
   ncf20_to_db( ncf20_ptr );

	/* Make sure we can access the record before attempting to update it. */
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL
      SELECT *
      INTO  :db_ncf20
      FROM   ncf20
      WHERE  network_id =   :pte_ncf20.network_id    AND   
            yyyymmdd    =   :pte_ncf20.yyyymmdd      AND
            rownum      =    1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF20 ,Fun_Name : db_update_ncf20_S , Duration = %f,network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf20.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf20 ,ST1:%d,ST2: %d_1,network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf20.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL UPDATE ncf20
   SET   network_id                          =   :pte_ncf20.network_id,    
         yyyymmdd                            =   :pte_ncf20.yyyymmdd,

     ytd_total_tran_cnt                      =   :pte_ncf20.ytd_total_tran_cnt,
     ytd_total_tran_amt                      =   :pte_ncf20.ytd_total_tran_amt, 
     mtd_total_tran_cnt                      =   :pte_ncf20.mtd_total_tran_cnt,
     mtd_total_tran_amt                      =   :pte_ncf20.mtd_total_tran_amt,  
     tran_cnt                                =   :pte_ncf20.tran_cnt,
     tran_amt                                =   :pte_ncf20.tran_amt,
     tran_approved_cnt                       =   :pte_ncf20.tran_approved_cnt,
     tran_declined_cnt                       =   :pte_ncf20.tran_declined_cnt,

     category_code1                          =   :pte_ncf20.category_code1,
     category_cnt1                           =   :pte_ncf20.category_cnt1,
     category_code2                          =   :pte_ncf20.category_code2,
     category_cnt2                           =   :pte_ncf20.category_cnt2,
     category_code3                          =   :pte_ncf20.category_code3,
     category_cnt3                           =   :pte_ncf20.category_cnt3,
     category_code4                          =   :pte_ncf20.category_code4,
     category_cnt4                           =   :pte_ncf20.category_cnt4,
     category_code5                          =   :pte_ncf20.category_code5,
     category_cnt5                           =   :pte_ncf20.category_cnt5,
     category_code6                          =   :pte_ncf20.category_code6,
     category_cnt6                           =   :pte_ncf20.category_cnt6,
     category_code7                          =   :pte_ncf20.category_code7,
     category_cnt7                           =   :pte_ncf20.category_cnt7,
     category_code8                          =   :pte_ncf20.category_code8,
     category_cnt8                           =   :pte_ncf20.category_cnt8,
     category_code9                          =   :pte_ncf20.category_code9,
     category_cnt9                           =   :pte_ncf20.category_cnt9,
     category_code10                         =   :pte_ncf20.category_code10,
     category_cnt10                          =   :pte_ncf20.category_cnt10,
     category_code11                         =   :pte_ncf20.category_code11,
     category_cnt11                          =   :pte_ncf20.category_cnt11,
     category_code12                         =   :pte_ncf20.category_code12,
     category_cnt12                          =   :pte_ncf20.category_cnt12,
     category_code13                         =   :pte_ncf20.category_code13,
     category_cnt13                          =   :pte_ncf20.category_cnt13,
     category_code14                         =   :pte_ncf20.category_code14,
     category_cnt14                          =   :pte_ncf20.category_cnt14,
     category_code15                         =   :pte_ncf20.category_code15,
     category_cnt15                          =   :pte_ncf20.category_cnt15,
     category_code16                         =   :pte_ncf20.category_code16,
     category_cnt16                          =   :pte_ncf20.category_cnt16,
     category_code17                         =   :pte_ncf20.category_code17,
     category_cnt17                          =   :pte_ncf20.category_cnt17,
     category_code18                         =   :pte_ncf20.category_code18,
     category_cnt18                          =   :pte_ncf20.category_cnt18,
     category_code19                         =   :pte_ncf20.category_code19,
     category_cnt19                          =   :pte_ncf20.category_cnt19,
     category_code20                         =   :pte_ncf20.category_code20,
     category_cnt20                          =   :pte_ncf20.category_cnt20

   WHERE  network_id =   :pte_ncf20.network_id    AND   
            yyyymmdd =   :pte_ncf20.yyyymmdd;         
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF20 ,Fun_Name : db_update_ncf20_U , Duration = %f,network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf20.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf20 ,ST1:%d,ST2: %d_2,network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,pte_ncf20.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_update_ncf21
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in NCF21 based on a key values in ncf21_ptr.
 *                The record is copied into pte_ncf21, then the database is
 *                updated.
 *
 *  INPUTS:       ncf21_ptr - NCF21 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_ncf21( pNCF21 ncf21_ptr, pCHAR ErrorMsg )
{
   ncf21_to_db( ncf21_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf21
      FROM   NCF21
      WHERE  network_id   = :pte_ncf21.network_id    AND  
      		 network_type = :pte_ncf21.network_type  AND  
      		 batch_number = :pte_ncf21.batch_number  AND
      		 rownum       = 1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_update_ncf21_S , Duration = %f,network id:%s,Network type:%s,batch number:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf21.network_id,pte_ncf21.network_type,pte_ncf21.batch_number);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */
      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf21 ,ST1:%d,ST2: %d_1,network id:%s,Network type:%s,batch number:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf21.network_id,pte_ncf21.network_type,pte_ncf21.batch_number);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL UPDATE ncf21
   SET   network_id                          =   :pte_ncf21.network_id,    
         network_type                        =   :pte_ncf21.network_type, 
         batch_number                        =   :pte_ncf21.batch_number,

     open_date                               =   :pte_ncf21.open_date,          
     open_time                               =   :pte_ncf21.open_time, 
     release_date                            =   :pte_ncf21.release_date,           
     release_time                            =   :pte_ncf21.release_time,  
     credit_cnt                              =   :pte_ncf21.credit_cnt,        
     credit_amt                              =   :pte_ncf21.credit_amt,
     credit_rev_cnt                          =   :pte_ncf21.credit_rev_cnt,        
     credit_rev_amt                          =   :pte_ncf21.credit_rev_amt,   
     debit_cnt                               =   :pte_ncf21.debit_cnt,  
     debit_amt                               =   :pte_ncf21.debit_amt,  
     debit_rev_cnt                           =   :pte_ncf21.debit_rev_cnt,   
     debit_rev_amt                           =   :pte_ncf21.debit_rev_amt,   
     total_amt                               =   :pte_ncf21.total_amt,           
     total_amt_type                          =   :pte_ncf21.total_amt_type  

   WHERE  network_id     =   :pte_ncf21.network_id    AND   
          network_type   =   :pte_ncf21.network_type  AND
          batch_number   =   :pte_ncf21.batch_number ;         
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_update_ncf21_U , Duration = %f,network id:%s,Network type:%s,batch number:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf21.network_id,pte_ncf21.network_type,pte_ncf21.batch_number);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_update_ncf21,ST1:%d,ST2: %d_2,network id:%s,Network type:%s,batch number:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf21.network_id,pte_ncf21.network_type,pte_ncf21.batch_number);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_update_ncf21_batch_number
 *
 *  DESCRIPTION:  This function makes the call to the database to update the
 *                batch number in an NCF21 record for Network Id, Network
 *                Type, and Batch Number = "ACTIVE".  It also updates the
 *                batch release_date and release_time - date and time the
 *                batch closes.
 *
 *  INPUTS:       ncf21_ptr - NCF21 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_ncf21_batch_number( pNCF21 ncf21_ptr, pCHAR ErrorMsg )
{
EXEC SQL BEGIN DECLARE SECTION;
   char  d_batch_number[7];
   char  d_network_id[11];
   char  d_network_type[2];
   char  d_release_date[9];
   char  d_release_time[7];
   char  d_open_date[9];
   char  d_open_time[7];

EXEC SQL END DECLARE SECTION;

   strcpy( d_batch_number, ncf21_ptr->primary_key.batch_number );
   strcpy( d_network_id,   ncf21_ptr->primary_key.network_id   );
   strcpy( d_network_type, ncf21_ptr->primary_key.network_type );
   strcpy( d_release_date, ncf21_ptr->release_date             );
   strcpy( d_release_time, ncf21_ptr->release_time             );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL SELECT open_date, open_time INTO :d_open_date, :d_open_time
	   FROM NCF21
	   WHERE  network_id =   :d_network_id    AND   
          network_type   =   :d_network_type  AND
          batch_number   =   'ACTIVE'  AND
          rownum         =   1	
          FOR UPDATE NOWAIT;           
  
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_update_ncf21_batch_number_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }

   if(SQLCODE != 0)
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_update_ncf21_batch_number ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   strcpy(ncf21_ptr->open_date, d_open_date);
   strcpy(ncf21_ptr->open_time, d_open_time);
   
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL UPDATE ncf21
   SET   batch_number    =   :d_batch_number,
         release_date    =   :d_release_date,
         release_time    =   :d_release_time

   WHERE  network_id     =   :d_network_id    AND   
          network_type   =   :d_network_type  AND
          batch_number   =   'ACTIVE' ;         
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_update_ncf21_batch_number_U , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In  db_update_ncf21_batch_number,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_update_ncf30
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in NCF30 based on a key values in ncf30_ptr.
 *                The record is copied into pte_ncf30, then the database is
 *                updated.
 *
 *  INPUTS:       ncf30_ptr - NCF30 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_ncf30( pNCF30 ncf30_ptr, pCHAR ErrorMsg )
{
   ncf30_to_db( ncf30_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf30
      FROM   NCF30
   WHERE  network_id        =   :pte_ncf30.network_id    AND   
          network_type      =   :pte_ncf30.network_type  AND
          batch_number      =   :pte_ncf30.batch_number  AND
          retrieval_ref_num =   :pte_ncf30.retrieval_ref_num AND
          card_nbr          =   :pte_ncf30.card_nbr AND
          rownum			=   1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_update_ncf30_S , Duration = %f,batch num:%s,card num:%s,device id:%s,merchant id:%s,STAN:%s, network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf30.batch_number,pte_ncf30.card_nbr,pte_ncf30.device_id,pte_ncf30.merchant_id,pte_ncf30.sys_trace_audit_nbr,pte_ncf30.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */  
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf30 ,ST1:%d,ST2: %d_1,batch num:%s,card num:%s,device id:%s,merchant id:%s,STAN:%s, network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf30.batch_number,pte_ncf30.card_nbr,pte_ncf30.device_id,pte_ncf30.merchant_id,pte_ncf30.sys_trace_audit_nbr,pte_ncf30.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;  
   }
   
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL UPDATE ncf30
   SET   network_id                          =   :pte_ncf30.network_id,    
         network_type                        =   :pte_ncf30.network_type,         
         batch_number                        =   :pte_ncf30.batch_number,
         retrieval_ref_num                   =   :pte_ncf30.retrieval_ref_num,

     open_date                               =   :pte_ncf30.open_date,          
     open_time                               =   :pte_ncf30.open_time, 
     merchant_id                             =   :pte_ncf30.merchant_id,           
     transaction_id                          =   :pte_ncf30.transaction_id,  
     device_id                               =   :pte_ncf30.device_id,        
     card_nbr                                =   :pte_ncf30.card_nbr,
     message_type                            =   :pte_ncf30.message_type,        
     processing_code                         =   :pte_ncf30.processing_code,   
     tran_amount                             =   :pte_ncf30.tran_amount,  
     auth_number                             =   :pte_ncf30.auth_number,  
     response_code                           =   :pte_ncf30.response_code,   
     tran_date                               =   :pte_ncf30.tran_date,   
     tran_time                               =   :pte_ncf30.tran_time,           
     sys_trace_audit_nbr                     =   :pte_ncf30.sys_trace_audit_nbr,  
     tx_key                                  =   :pte_ncf30.tx_key,            
     invoice_nbr                             =   :pte_ncf30.invoice_nbr,   
     network_data                            =   :pte_ncf30.network_data,
     currency_code                           =   :pte_ncf30.currency_code,
     acquiring_inst_id_code                  =   :pte_ncf30.acquiring_inst_id_code,
     settlement_date                         =   :pte_ncf30.settlement_date,
     transmission_timestamp                  =   :pte_ncf30.transmission_timestamp,
     tran_fee_amount                         =   :pte_ncf30.tran_fee_amount

   WHERE  network_id        =   :pte_ncf30.network_id    AND   
          network_type      =   :pte_ncf30.network_type  AND
          batch_number      =   :pte_ncf30.batch_number  AND
          retrieval_ref_num =   :pte_ncf30.retrieval_ref_num AND
          card_nbr          =   :pte_ncf30.card_nbr ;  
                 
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_update_ncf30_U , Duration = %f,batch num:%s,device id:%s,merchant id:%s,STAN:%s, network id:%s ",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf30.batch_number,pte_ncf30.device_id,pte_ncf30.merchant_id,pte_ncf30.sys_trace_audit_nbr,pte_ncf30.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf30 ,ST1:%d,ST2: %d_2,batch num:%s,device id:%s,merchant id:%s,STAN:%s, network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf30.batch_number,pte_ncf30.device_id,pte_ncf30.merchant_id,pte_ncf30.sys_trace_audit_nbr,pte_ncf30.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}


BYTE db_update_ncf01_keyblock( pNCF01_KEYBLOCK ncf01_keyblock_ptr, pCHAR ErrorMsg )
{
   ncf01_keyblock_to_db( ncf01_keyblock_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf01_keyblock
      FROM   NCF01_KEYBLOCK
   WHERE  network_id        =   :pte_ncf01_keyblock.network_id    AND   
          rownum			=   1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK ,Fun_Name : db_update_ncf01_keyblock_S , Duration = %f,network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration, pte_ncf01_keyblock.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */  
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf01_keyblock_S ,ST1:%d,ST2: %d_1, network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,pte_ncf01_keyblock.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;  
   }
   
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL UPDATE ncf01_keyblock
   SET   network_id                          =   :pte_ncf01_keyblock.network_id,            

     iss_cwk_keyblock                        =   :pte_ncf01_keyblock.iss_cwk_keyblock,          
     iss_zmk_keyblock                        =   :pte_ncf01_keyblock.iss_zmk_keyblock, 
     iss_rtdcwk_keyblock                     =   :pte_ncf01_keyblock.iss_rtdcwk_keyblock,           
     iss_kek_keyblock                        =   :pte_ncf01_keyblock.iss_kek_keyblock,  
     acq_cwk_keyblock                        =   :pte_ncf01_keyblock.acq_cwk_keyblock,        
     acq_zmk_keyblock                        =   :pte_ncf01_keyblock.acq_zmk_keyblock,
     acq_kek_keyblock                        =   :pte_ncf01_keyblock.acq_kek_keyblock,        
     iss_prev_src_station                    =   :pte_ncf01_keyblock.iss_prev_src_station   
          
   WHERE  network_id        =   :pte_ncf01_keyblock.network_id;
                 
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK ,Fun_Name : db_update_ncf01_keyblock_U , Duration = %f,network id:%s ",DB_MsgSubtype1,DB_MsgSubtype2,duration, pte_ncf01_keyblock.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf01_keyblock ,ST1:%d,ST2: %d_2, network id:%s",DB_MsgSubtype1,DB_MsgSubtype2, pte_ncf01_keyblock.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_update_ncf30_batch_nbr
 *
 *  DESCRIPTION:  This function updates a record in NCF30 by changing the
 *                batch number from ACTIVE to a numeric string.
 *
 *  INPUTS:       NetworkId, NetworkType, BatchNumber
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_ncf30_batch_nbr( pCHAR NetworkId,   pCHAR NetworkType,
                                pCHAR BatchNumber, pCHAR open_date,pCHAR open_time, pCHAR ErrorMsg )
{
   EXEC SQL BEGIN DECLARE SECTION;
      char  d_batch_number[7];
      char  d_network_id[11];
      char  d_network_type[2];
	  char  d_open_date[9];
	  char  d_open_time[7];
   EXEC SQL END DECLARE SECTION;

   strcpy( d_batch_number, BatchNumber );
   strcpy( d_network_id,   NetworkId   );
   strcpy( d_network_type, NetworkType );
   strcpy( d_open_date, open_date);
   strcpy( d_open_time, open_time);
   
   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
     /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf30
      FROM   NCF30
   WHERE  network_id        =   :d_network_id    AND   
          network_type      =   :d_network_type  AND
		  open_date			=   :d_open_date 	 AND
		  open_time			=   :d_open_time 	 AND
          batch_number      =   'ACTIVE' 		 AND
          rownum            =   1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_update_ncf30_batch_nbr_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */     
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf30_batch_nbr ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }   

   EXEC SQL UPDATE ncf30
   SET           
         batch_number       =   :d_batch_number

   WHERE  network_id        =   :d_network_id    AND   
          network_type      =   :d_network_type  AND
		  open_date			=   :d_open_date AND
		  open_time			=   :d_open_time AND
          batch_number      =   'ACTIVE' ;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_update_ncf30_batch_nbr_U , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_ncf30_batch_nbr ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_update_atm01
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in ATM01 based on a key values in atm01_ptr.
 *                The record is copied into pte_atm01, then the database is
 *                updated.
 *
 *  INPUTS:       atm01_ptr - ATM01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_atm01( pATM01 atm01_ptr, pCHAR ErrorMsg )
{
   atm01_to_db( atm01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_atm01
      FROM   ATM01
      WHERE  bkcb_name = :pte_atm01.bkcb_name
        AND  termnumr  = :pte_atm01.termnumr
        AND  rownum    = 1
      For Update NOWAIT;
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : ATM01 ,Fun_Name : db_update_atm01_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */
      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_atm01 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL UPDATE atm01
   SET   bkcb_name                           =   :pte_atm01.bkcb_name,    
         termnumr                            =   :pte_atm01.termnumr,         

     bourder                                 =   :pte_atm01.bourder,          
     mnemonic                                =   :pte_atm01.mnemonic, 
     brchname                                =   :pte_atm01.brchname,           
     termsite                                =   :pte_atm01.termsite,  
     termaddr                                =   :pte_atm01.termaddr,        
     termdist                                =   :pte_atm01.termdist,
     termcimu                                =   :pte_atm01.termcimu,        
     termprov                                =   :pte_atm01.termprov,   
     termregn                                =   :pte_atm01.termregn,  
     machtype                                =   :pte_atm01.machtype,  
     termodel                                =   :pte_atm01.termodel,   
     dateinst                                =   :pte_atm01.dateinst,   
     termloc                                 =   :pte_atm01.termloc,           
     termtype                                =   :pte_atm01.termtype,  
     refnum                                  =   :pte_atm01.refnum,            
     linktype                                =   :pte_atm01.linktype

   WHERE  bkcb_name   =   :pte_atm01.bkcb_name    AND   
          termnumr    =   :pte_atm01.termnumr;         
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : ATM01 ,Fun_Name : db_update_atm01_U , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_atm01 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_update_neg01
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in NEG01 based on a key values in neg01_ptr.
 *                The record is copied into pte_neg01, then the database is
 *                updated.
 *
 *  INPUTS:       neg01_ptr - NEG01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_neg01( pNEG01 neg01_ptr, pCHAR ErrorMsg )
{
   neg01_to_db( neg01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_neg01
      FROM   NEG01
      WHERE  card_nbr  = :pte_neg01.card_nbr
        AND  card_type = :pte_neg01.card_type
        AND  rownum    = 1
      For Update NOWAIT;
      
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NEG01 ,Fun_Name : db_update_neg01_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */     
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_neg01 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;  
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL UPDATE neg01
   SET   card_nbr                          =   :pte_neg01.card_nbr,    
         card_type                         =   :pte_neg01.card_type,         

     card_exten                            =   :pte_neg01.card_exten,          
     card_status                           =   :pte_neg01.card_status

   WHERE  card_nbr  =   :pte_neg01.card_nbr    AND   
          card_type =   :pte_neg01.card_type;         
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NEG01 ,Fun_Name : db_update_neg01_U , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg );
		sprintf(er_buf,"In db_update_neg01 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_update_saf01
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in SAF01 based on a key values in saf01_ptr.
 *                The record is copied into pte_saf01, then the database is
 *                updated.
 *
 *  INPUTS:       saf01_ptr - SAF01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_update_saf01( pSAF01 saf01_ptr, pCHAR ErrorMsg )
{
   saf01_to_db( saf01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_saf01
      FROM   SAF01
      WHERE  transaction_id = :pte_saf01.transaction_id AND
      	     rownum         = 1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : SAF01 ,Fun_Name : db_update_saf01_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_saf01 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL UPDATE saf01
   SET   transaction_id             = :pte_saf01.transaction_id,
     card_num                       = :pte_saf01.card_num,
     tran_amount                    = :pte_saf01.tran_amount,
     device_id                      = :pte_saf01.device_id,
     message_type                   = :pte_saf01.message_type,
     processing_code                = :pte_saf01.processing_code,
     sys_trace_audit_nbr            = :pte_saf01.sys_trace_audit_nbr,
     tran_date                      = :pte_saf01.tran_date,
     tran_time                      = :pte_saf01.tran_time,
     tx_key                         = :pte_saf01.tx_key,
     retrieval_ref_num              = :pte_saf01.retrieval_ref_num,
     merchant_id                    = :pte_saf01.merchant_id,
     auth_number                    = :pte_saf01.auth_number,
     response_code                  = :pte_saf01.response_code,
     invoice_nbr                    = :pte_saf01.invoice_nbr,
     network_data                   = :pte_saf01.network_data,
     currency_code                  = :pte_saf01.currency_code,
     transmission_timestamp         = :pte_saf01.transmission_timestamp,
     exp_date                       = :pte_saf01.exp_date,
     settlement_amount              = :pte_saf01.settlement_amount,
     settlement_date                = :pte_saf01.settlement_date,
     settlement_conv_rate           = :pte_saf01.settlement_conv_rate,
     settlement_curr_code           = :pte_saf01.settlement_curr_code,
     billing_amount                 = :pte_saf01.billing_amount,
     billing_conv_rate              = :pte_saf01.billing_conv_rate,
     billing_curr_code              = :pte_saf01.billing_curr_code,  
     tran_fee_amount                = :pte_saf01.tran_fee_amount,
     handler_queue                  = :pte_saf01.handler_queue,
     acquiring_inst_id_code         = :pte_saf01.acquiring_inst_id_code,
     forwarding_inst_id_code        = :pte_saf01.forwarding_inst_id_code,
     reversal_amount                = :pte_saf01.reversal_amount

   WHERE transaction_id             = :pte_saf01.transaction_id ;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : SAF01 ,Fun_Name : db_update_saf01_U , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   } 
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_saf01 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_delete_ncf01
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in NCF01 based on a key values in ncf01_ptr.
 *                The record is copied into pte_ncf01, then the record is
 *                deleted.
 *
 *  INPUTS:       ncf01_ptr - NCF01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_delete_ncf01( pNCF01 ncf01_ptr, pCHAR ErrorMsg)
{
   ncf01_to_db( ncf01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf01
      FROM   NCF01
      WHERE  network_id   = :pte_ncf01.network_id
        AND  network_type = :pte_ncf01.network_type
        AND  rownum       = 1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_delete_ncf01_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   } 
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf01 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DELETE FROM ncf01
   WHERE network_id   = :pte_ncf01.network_id   and 
         network_type = :pte_ncf01.network_type;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_delete_ncf01_D , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }

   if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND) )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf01 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_delete_ncf02
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in NCF02 based on a key values in ncf02_ptr.
 *                The record is copied into pte_ncf02, then the record is
 *                deleted.
 *
 *  INPUTS:       ncf02_ptr - NCF02 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_delete_ncf02( pNCF02 ncf02_ptr, pCHAR ErrorMsg)
{
   ncf02_to_db( ncf02_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf02
      FROM   NCF02
      WHERE  network_id   = :pte_ncf02.network_id
        AND  network_type = :pte_ncf02.network_type
        AND  rownum       = 1
      For Update NOWAIT;
      
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF02 ,Fun_Name : db_delete_ncf02_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf02 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DELETE FROM ncf02
   WHERE network_id   = :pte_ncf02.network_id  and 
         network_type = :pte_ncf02.network_type;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF02 ,Fun_Name : db_delete_ncf02_D , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf02 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_delete_ncf20
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in NCF20 based on a key values in ncf20_ptr.
 *                The record is copied into pte_ncf20, then the record is
 *                deleted.
 *
 *  INPUTS:       ncf20_ptr - NCF20 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_delete_ncf20( pNCF20 ncf20_ptr, pCHAR ErrorMsg)
{
   ncf20_to_db( ncf20_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }

/* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf20
      FROM   ncf20
      WHERE network_id   = :pte_ncf20.network_id AND 
         	yyyymmdd     = :pte_ncf20.yyyymmdd AND
      		rownum = 1
      For Update NOWAIT;

   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */
      return( dbcommon_oracle_to_pte_rcode(SQLCODE, ErrorMsg) );
   }
   
   EXEC SQL DELETE FROM ncf20
   WHERE network_id   = :pte_ncf20.network_id   and 
         yyyymmdd     = :pte_ncf20.yyyymmdd;
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF20 ,Fun_Name : db_delete_ncf20 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND) )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf20 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_delete_ncf21
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in NCF21 based on a key values in ncf21_ptr.
 *                The record is copied into pte_ncf21, then the record is
 *                deleted.
 *
 *  INPUTS:       ncf21_ptr - NCF21 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_delete_ncf21( pNCF21 ncf21_ptr, pCHAR ErrorMsg)
{
   ncf21_to_db( ncf21_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf21
      FROM   NCF21
      WHERE  network_id   = :pte_ncf21.network_id
        AND  network_type = :pte_ncf21.network_type
        AND  batch_number = :pte_ncf21.batch_number
        AND  rownum       = 1
      For Update NOWAIT;
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_delete_ncf21_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf21 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL DELETE FROM ncf21
   WHERE network_id   = :pte_ncf21.network_id   and 
         network_type = :pte_ncf21.network_type and
         batch_number = :pte_ncf21.batch_number;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_delete_ncf21_D , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND) )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf21 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_delete_ncf30
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in NCF30 based on a key values in ncf30_ptr.
 *                The record is copied into pte_ncf30, then the record is
 *                deleted.
 *
 *  INPUTS:       ncf30_ptr - NCF30 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_delete_ncf30( pNCF30 ncf30_ptr, pCHAR ErrorMsg)
{
   ncf30_to_db( ncf30_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf30
      FROM   NCF30
      WHERE  network_id        = :pte_ncf30.network_id
        AND  network_type      = :pte_ncf30.network_type
        AND  batch_number      = :pte_ncf30.batch_number
        AND  retrieval_ref_num = :pte_ncf30.retrieval_ref_num
        AND  card_nbr          = :pte_ncf30.card_nbr
        AND  rownum            = 1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_delete_ncf30_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf30 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DELETE FROM ncf30
   WHERE network_id        = :pte_ncf30.network_id   and 
         network_type      = :pte_ncf30.network_type and
         batch_number      = :pte_ncf30.batch_number and
         retrieval_ref_num = :pte_ncf30.retrieval_ref_num and
         card_nbr          = :pte_ncf30.card_nbr;
         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_delete_ncf30_D , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND) )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf30 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}


BYTE db_delete_ncf01_keyblock( pNCF01_KEYBLOCK ncf01_keyblock_ptr, pCHAR ErrorMsg)
{
   ncf01_keyblock_to_db( ncf01_keyblock_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_ncf01_keyblock
      FROM   NCF01_KEYBLOCK
      WHERE  network_id        = :pte_ncf01_keyblock.network_id
        AND  rownum            = 1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK ,Fun_Name : db_delete_ncf01_keyblock_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf01_keyblock ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DELETE FROM ncf01_keyblock
   WHERE network_id        = :pte_ncf01_keyblock.network_id; 

         
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK ,Fun_Name : db_delete_ncf01_keyblock_D , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND) )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_ncf01_keyblock ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_delete_atm01
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in ATM01 based on a key values in atm01_ptr.
 *                The record is copied into pte_atm01, then the record is
 *                deleted.
 *
 *  INPUTS:       atm01_ptr - ATM01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_delete_atm01( pATM01 atm01_ptr, pCHAR ErrorMsg)
{
   atm01_to_db( atm01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_atm01
      FROM   ATM01
      WHERE  bkcb_name = :pte_atm01.bkcb_name
        AND  termnumr  = :pte_atm01.termnumr
        AND  rownum    = 1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : ATM01 ,Fun_Name : db_delete_atm01_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_atm01 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DELETE FROM atm01
   WHERE bkcb_name = :pte_atm01.bkcb_name   and 
         termnumr  = :pte_atm01.termnumr;

   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : ATM01 ,Fun_Name : db_delete_atm01_D , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND) )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_atm01 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_delete_neg01
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in NEG01 based on a key values in neg01_ptr.
 *                The record is copied into pte_neg01, then the record is
 *                deleted.
 *
 *  INPUTS:       neg01_ptr - NEG01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_delete_neg01( pNEG01 neg01_ptr, pCHAR ErrorMsg)
{
   neg01_to_db( neg01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }

   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_neg01
      FROM   neg01
      WHERE card_type = :pte_neg01.card_type AND
      		rownum = 1
      For Update NOWAIT;

   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */
      return( dbcommon_oracle_to_pte_rcode(SQLCODE, ErrorMsg) );
   }

   EXEC SQL DELETE FROM neg01
   WHERE card_type = :pte_neg01.card_type;

   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NEG01 ,Fun_Name : db_delete_neg01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND) )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_neg01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_delete_saf01
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in SAF01 based on a key values in saf01_ptr.
 *                The record is copied into pte_saf01, then the record is
 *                deleted.
 *
 *  INPUTS:       saf01_ptr - SAF01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_delete_saf01( pSAF01 saf01_ptr, pCHAR ErrorMsg)
{
   saf01_to_db( saf01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_saf01
      FROM   SAF01
      WHERE  transaction_id = :pte_saf01.transaction_id AND
      		 rownum         = 1
      For Update NOWAIT;
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : SAF01 ,Fun_Name : db_delete_saf01_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_saf01 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;   
   }

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DELETE FROM saf01
   WHERE transaction_id = :pte_saf01.transaction_id;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : SAF01 ,Fun_Name : db_delete_saf01_D , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if (( SQLCODE != 0 ) && ( SQLCODE != NO_DATA_FOUND) )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_saf01 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_insert_ncf01
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into NCF01.
 *
 *  INPUTS:       ncf01_ptr - NCF01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 *     DI - 03/17/99 - Added receiving_inst_id_code.
 ******************************************************************************/
BYTE db_insert_ncf01( pNCF01 ncf01_ptr, pCHAR ErrorMsg )
{
   ncf01_to_db( ncf01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL INSERT INTO ncf01
     ( network_id,
      network_type,
      name,
      status,
      totals_ind,
      statistics_ind,
      acquirer_inst_id_code,
      forwarding_inst_id_code,
      receiving_inst_id_code,
      remote_nsp_type,
      pin_type,
      encr_type,
      pad_char,
      cwk,
      kek,
      retired_cwk,
      auto_logon,
      echo_interval,
      max_consecutive_timeouts,
      max_active_txns,
      que_name,
      local_nsp_type,
      request_timer ,
      idle_line_timer,
      advice_repeat_counter,
      admin_message_timer,  
      store_forward_processing ,
      currency_code_purchase, 
      currency_code_cash, 
      country_code, 
      station_id1 ,
      station_id2 ,
      prev_src_station,
      tpdu_id,
      identifier1 ,
      identifier2 ,
      identifier3 ,
      identifier4, 
      identifier5,
      identifier6, 
      identifier7, 
      identifier8, 
      identifier9 ,
      identifier10,
      processing_code1,  
      processing_code2,
      processing_code3,  
      processing_code4,  
      processing_code5,  
      processing_code6,  
      processing_code7,  
      processing_code8,  
      processing_code9,  
      processing_code10, 
      processing_code11, 
      processing_code12, 
      processing_code13, 
      processing_code14, 
      processing_code15, 
      processing_code16,
      processing_code17,
      processing_code18, 
      processing_code19, 
      processing_code20,
      zmk,
      neg_access_code
     )               
   VALUES(  :pte_ncf01.network_id,
     :pte_ncf01.network_type,
     :pte_ncf01.name,
     :pte_ncf01.status,
     :pte_ncf01.totals_ind,
     :pte_ncf01.statistics_ind,
     :pte_ncf01.acquirer_inst_id_code,
     :pte_ncf01.forwarding_inst_id_code,
     :pte_ncf01.receiving_inst_id_code,
     :pte_ncf01.remote_nsp_type,
     :pte_ncf01.pin_type,
     :pte_ncf01.encr_type,
     :pte_ncf01.pad_char,
     :pte_ncf01.cwk,
     :pte_ncf01.kek,
     :pte_ncf01.retired_cwk,
     :pte_ncf01.auto_logon,
     :pte_ncf01.echo_interval,
     :pte_ncf01.max_consecutive_timeouts,
     :pte_ncf01.max_active_txns,
     :pte_ncf01.que_name,
     :pte_ncf01.local_nsp_type,
     :pte_ncf01.request_timer ,
     :pte_ncf01.idle_line_timer,
     :pte_ncf01.advice_repeat_counter,
     :pte_ncf01.admin_message_timer,  
     :pte_ncf01.store_forward_processing ,
     :pte_ncf01.currency_code_purchase, 
     :pte_ncf01.currency_code_cash, 
     :pte_ncf01.country_code, 
     :pte_ncf01.station_id1 ,
     :pte_ncf01.station_id2 ,
     :pte_ncf01.prev_src_station,
     :pte_ncf01.tpdu_id,
     :pte_ncf01.identifier1 ,
     :pte_ncf01.identifier2 ,
     :pte_ncf01.identifier3 ,
     :pte_ncf01.identifier4, 
     :pte_ncf01.identifier5,
     :pte_ncf01.identifier6, 
     :pte_ncf01.identifier7, 
     :pte_ncf01.identifier8, 
     :pte_ncf01.identifier9 ,
     :pte_ncf01.identifier10,
     :pte_ncf01.processing_code1,  
     :pte_ncf01.processing_code2,
     :pte_ncf01.processing_code3,  
     :pte_ncf01.processing_code4,  
     :pte_ncf01.processing_code5,  
     :pte_ncf01.processing_code6,  
     :pte_ncf01.processing_code7,  
     :pte_ncf01.processing_code8,  
     :pte_ncf01.processing_code9,  
     :pte_ncf01.processing_code10, 
     :pte_ncf01.processing_code11, 
     :pte_ncf01.processing_code12, 
     :pte_ncf01.processing_code13, 
     :pte_ncf01.processing_code14, 
     :pte_ncf01.processing_code15, 
     :pte_ncf01.processing_code16,
     :pte_ncf01.processing_code17,
     :pte_ncf01.processing_code18, 
     :pte_ncf01.processing_code19, 
     :pte_ncf01.processing_code20,
     :pte_ncf01.zmk,
     :pte_ncf01.neg_access_code
	   
      );
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_insert_ncf01 , Duration = %f,Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf01.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_ncf01 ,ST1:%d,ST2: %d,Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf01.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}
/******************************************************************************
 *
 *  NAME:         db_insert_ncf02
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into NCF02.
 *
 *  INPUTS:       ncf02_ptr - NCF02 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_insert_ncf02( pNCF02 ncf02_ptr, pCHAR ErrorMsg )
{
   ncf02_to_db( ncf02_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL INSERT INTO ncf02
     (  network_id,    
        network_type,         

     credit_cnt,          
     credit_reversal_cnt, 
     debit_cnt,           
     debit_reversal_cnt,  
     transfer_cnt,        
     transfer_reversal_cnt,
     inquiries_cnt,        
     authorizations_cnt,   
     credit_proc_fee_amt,  
     credit_tran_fee_amt,  
     debit_proc_fee_amt,   
     debit_tran_fee_amt,   
     credit_amt,           
     credit_reversal_amt,  
     debit_amt,            
     debit_reversal_amt,   
     net_settlement_amt   
     )               
   VALUES(  :pte_ncf02.network_id,    
     :pte_ncf02.network_type,         

     :pte_ncf02.credit_cnt,          
     :pte_ncf02.credit_reversal_cnt, 
     :pte_ncf02.debit_cnt,           
     :pte_ncf02.debit_reversal_cnt,  
     :pte_ncf02.transfer_cnt,        
     :pte_ncf02.transfer_reversal_cnt,
     :pte_ncf02.inquiries_cnt,        
     :pte_ncf02.authorizations_cnt,   
     :pte_ncf02.credit_proc_fee_amt,  
     :pte_ncf02.credit_tran_fee_amt,  
     :pte_ncf02.debit_proc_fee_amt,   
     :pte_ncf02.debit_tran_fee_amt,   
     :pte_ncf02.credit_amt,           
     :pte_ncf02.credit_reversal_amt,  
     :pte_ncf02.debit_amt,            
     :pte_ncf02.debit_reversal_amt,   
     :pte_ncf02.net_settlement_amt 
      );
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF02 ,Fun_Name : db_insert_ncf02 , Duration = %f,Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf02.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_ncf02 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

BYTE db_insert_obs01(pOBS01 obs01_ptr, pCHAR ErrorMsg )
{
   obs01_to_db( obs01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
    EXEC SQL INSERT INTO obs01
    (
    	on_behalf_service,
		on_behalf_result, 
		description,      
		response_code    
    )
     VALUES(    :pte_obs01.on_behalf_service,    
     			:pte_obs01.on_behalf_result,         
     			:pte_obs01.description,          
     			:pte_obs01.response_code
    );
    
    if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01 ,Fun_Name : db_insert_obs01 , Duration = %f on_behalf_service=%s, on_behalf_result=%s",
		DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_obs01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************/
BYTE db_insert_visa3ds2(pVISA3DS2 visa3ds2_ptr, pCHAR ErrorMsg )
{
   visa3ds2_to_db( visa3ds2_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
    EXEC SQL INSERT INTO visa3ds2
    (
    	cavv,
		description,      
		response_code    
    )
     VALUES(    :pte_visa3ds2.cavv,          
     			:pte_visa3ds2.description,          
     			:pte_visa3ds2.response_code
    );
    
    if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2 ,Fun_Name : db_insert_visa3ds2 , Duration = %f,cavv:%s",
		DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_visa3ds2.cavv);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_visa3ds2 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_insert_ncf20
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into NCF20.
 *
 *  INPUTS:       ncf20_ptr - NCF20 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_insert_ncf20( pNCF20 ncf20_ptr, pCHAR ErrorMsg )
{
   ncf20_to_db( ncf20_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL INSERT INTO ncf20
     (  network_id,    
        yyyymmdd,         

     ytd_total_tran_cnt,          
     ytd_total_tran_amt, 
     mtd_total_tran_cnt,           
     mtd_total_tran_amt,  
     tran_cnt,        
     tran_amt,
     tran_approved_cnt,        
     tran_declined_cnt,   
     category_code1,  
     category_cnt1,  
     category_code2,  
     category_cnt2,  
     category_code3,  
     category_cnt3,  
     category_code4,  
     category_cnt4,  
     category_code5,  
     category_cnt5,  
     category_code6,  
     category_cnt6,  
     category_code7,  
     category_cnt7,  
     category_code8,  
     category_cnt8,  
     category_code9,  
     category_cnt9,  
     category_code10,  
     category_cnt10,  
     category_code11,  
     category_cnt11,  
     category_code12,  
     category_cnt12,  
     category_code13,  
     category_cnt13,  
     category_code14,  
     category_cnt14,  
     category_code15,  
     category_cnt15,  
     category_code16,  
     category_cnt16,  
     category_code17,  
     category_cnt17,  
     category_code18,  
     category_cnt18,  
     category_code19,  
     category_cnt19,  
     category_code20,  
     category_cnt20  
     )               
   VALUES(  :pte_ncf20.network_id,    
     :pte_ncf20.yyyymmdd,         

     :pte_ncf20.ytd_total_tran_cnt,          
     :pte_ncf20.ytd_total_tran_amt, 
     :pte_ncf20.mtd_total_tran_cnt,           
     :pte_ncf20.mtd_total_tran_amt,  
     :pte_ncf20.tran_cnt,        
     :pte_ncf20.tran_amt,
     :pte_ncf20.tran_approved_cnt,        
     :pte_ncf20.tran_declined_cnt,   
     :pte_ncf20.category_code1,  
     :pte_ncf20.category_cnt1,  
     :pte_ncf20.category_code2,  
     :pte_ncf20.category_cnt2,  
     :pte_ncf20.category_code3,  
     :pte_ncf20.category_cnt3,  
     :pte_ncf20.category_code4,  
     :pte_ncf20.category_cnt4,  
     :pte_ncf20.category_code5,  
     :pte_ncf20.category_cnt5,  
     :pte_ncf20.category_code6,  
     :pte_ncf20.category_cnt6,  
     :pte_ncf20.category_code7,  
     :pte_ncf20.category_cnt7,  
     :pte_ncf20.category_code8,  
     :pte_ncf20.category_cnt8,  
     :pte_ncf20.category_code9,  
     :pte_ncf20.category_cnt9,  
     :pte_ncf20.category_code10,  
     :pte_ncf20.category_cnt10,  
     :pte_ncf20.category_code11,  
     :pte_ncf20.category_cnt11,  
     :pte_ncf20.category_code12,  
     :pte_ncf20.category_cnt12,  
     :pte_ncf20.category_code13,  
     :pte_ncf20.category_cnt13,  
     :pte_ncf20.category_code14,  
     :pte_ncf20.category_cnt14,  
     :pte_ncf20.category_code15,  
     :pte_ncf20.category_cnt15,  
     :pte_ncf20.category_code16,  
     :pte_ncf20.category_cnt16,  
     :pte_ncf20.category_code17,  
     :pte_ncf20.category_cnt17,  
     :pte_ncf20.category_code18,  
     :pte_ncf20.category_cnt18,  
     :pte_ncf20.category_code19,  
     :pte_ncf20.category_cnt19,  
     :pte_ncf20.category_code20,  
     :pte_ncf20.category_cnt20 
      );
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF20 ,Fun_Name : db_insert_ncf20 , Duration = %f,Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf20.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_ncf20 ,ST1:%d,ST2: %d,Network type:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf20.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_insert_ncf21
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into NCF21.
 *
 *  INPUTS:       ncf21_ptr - NCF21 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_insert_ncf21( pNCF21 ncf21_ptr, pCHAR ErrorMsg )
{
   ncf21_to_db( ncf21_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL INSERT INTO ncf21
     (  network_id,    
        network_type,
        batch_number,	         

     open_date,          
     open_time, 
     release_date,           
     release_time,  
     credit_cnt,        
     credit_amt,
     credit_rev_cnt,        
     credit_rev_amt,   
     debit_cnt,  
     debit_amt,  
     debit_rev_cnt,   
     debit_rev_amt,   
     total_amt,           
     total_amt_type  
     )               
   VALUES(  :pte_ncf21.network_id,    
     :pte_ncf21.network_type, 
     :pte_ncf21.batch_number,

     :pte_ncf21.open_date,          
     :pte_ncf21.open_time, 
     :pte_ncf21.release_date,           
     :pte_ncf21.release_time,  
     :pte_ncf21.credit_cnt,        
     :pte_ncf21.credit_amt,
     :pte_ncf21.credit_rev_cnt,        
     :pte_ncf21.credit_rev_amt,   
     :pte_ncf21.debit_cnt,  
     :pte_ncf21.debit_amt,  
     :pte_ncf21.debit_rev_cnt,   
     :pte_ncf21.debit_rev_amt,   
     :pte_ncf21.total_amt,           
     :pte_ncf21.total_amt_type  
      );
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF21 ,Fun_Name : db_insert_ncf21 , Duration = %f,network id:%s,Network type:%s,batch number:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf21.network_id,pte_ncf21.network_type,pte_ncf21.batch_number);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_ncf21 ,ST1:%d,ST2: %d,network id:%s,Network type:%s,batch number:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf21.network_id,pte_ncf21.network_type,pte_ncf21.batch_number);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_insert_ncf30
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into NCF30.
 *
 *  INPUTS:       ncf30_ptr - NCF30 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_insert_ncf30( pNCF30 ncf30_ptr, pCHAR ErrorMsg )
{
   ncf30_to_db( ncf30_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL INSERT INTO ncf30
     (  network_id,    
        network_type,
        batch_number,
        retrieval_ref_num,

     open_date,          
     open_time, 
     merchant_id,           
     transaction_id,  
     device_id,        
     card_nbr,
     message_type,        
     processing_code,   
     tran_amount,  
     auth_number,  
     response_code,   
     tran_date,   
     tran_time,           
     sys_trace_audit_nbr,  
     tx_key,            
     invoice_nbr,   
     network_data,   
     currency_code,   
     acquiring_inst_id_code, 
     settlement_date, 
     transmission_timestamp,
     tran_fee_amount  
     )               
   VALUES(  :pte_ncf30.network_id,    
     :pte_ncf30.network_type,
     :pte_ncf30.batch_number,
     :pte_ncf30.retrieval_ref_num,

     :pte_ncf30.open_date,          
     :pte_ncf30.open_time, 
     :pte_ncf30.merchant_id,           
     :pte_ncf30.transaction_id,  
     :pte_ncf30.device_id,        
     :pte_ncf30.card_nbr,
     :pte_ncf30.message_type,        
     :pte_ncf30.processing_code,   
     :pte_ncf30.tran_amount,  
     :pte_ncf30.auth_number,  
     :pte_ncf30.response_code,   
     :pte_ncf30.tran_date,   
     :pte_ncf30.tran_time,           
     :pte_ncf30.sys_trace_audit_nbr,  
     :pte_ncf30.tx_key,            
     :pte_ncf30.invoice_nbr,   
     :pte_ncf30.network_data, 
     :pte_ncf30.currency_code, 
     :pte_ncf30.acquiring_inst_id_code, 
     :pte_ncf30.settlement_date, 
     :pte_ncf30.transmission_timestamp, 
     :pte_ncf30.tran_fee_amount 
      );
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF30 ,Fun_Name : db_insert_ncf30 , Duration = %f,batch num:%s,device id:%s,merchant id:%s,STAN:%s, network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration,
		pte_ncf30.batch_number,pte_ncf30.device_id,pte_ncf30.merchant_id,pte_ncf30.sys_trace_audit_nbr,pte_ncf30.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_ncf30 ,ST1:%d,ST2: %d,batch num:%s,device id:%s,merchant id:%s,STAN:%s, network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,
		pte_ncf30.batch_number,pte_ncf30.device_id,pte_ncf30.merchant_id,pte_ncf30.sys_trace_audit_nbr,pte_ncf30.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

BYTE db_insert_ncf01_keyblock( pNCF01_KEYBLOCK ncf01_keyblock_ptr, pCHAR ErrorMsg )
{
   ncf01_keyblock_to_db( ncf01_keyblock_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL INSERT INTO ncf01_keyblock
     (  network_id,    

     iss_cwk_keyblock,          
     iss_zmk_keyblock, 
     iss_rtdcwk_keyblock,           
     iss_kek_keyblock,  
     acq_cwk_keyblock,        
     acq_zmk_keyblock,
     acq_kek_keyblock,        
     iss_prev_src_station   
          
     )               
   VALUES(  :pte_ncf01_keyblock.network_id,    

     :pte_ncf01_keyblock.iss_cwk_keyblock,          
     :pte_ncf01_keyblock.iss_zmk_keyblock, 
     :pte_ncf01_keyblock.iss_rtdcwk_keyblock,           
     :pte_ncf01_keyblock.iss_kek_keyblock,  
     :pte_ncf01_keyblock.acq_cwk_keyblock,        
     :pte_ncf01_keyblock.acq_zmk_keyblock,
     :pte_ncf01_keyblock.acq_kek_keyblock,        
     :pte_ncf01_keyblock.iss_prev_src_station   
         
      );
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK ,Fun_Name : db_insert_ncf01_keyblock , Duration = %f, network id:%s",DB_MsgSubtype1,DB_MsgSubtype2,duration, pte_ncf30.network_id);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_ncf01_keyblock ,ST1:%d,ST2: %d,network id:%s",DB_MsgSubtype1,DB_MsgSubtype2, pte_ncf30.network_id);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_insert_atm01
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into ATM01.
 *
 *  INPUTS:       atm01_ptr - ATM01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_insert_atm01( pATM01 atm01_ptr, pCHAR ErrorMsg )
{
   atm01_to_db( atm01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL INSERT INTO atm01
     (  bkcb_name,    
        termnumr,

     bourder,          
     mnemonic, 
     brchname,           
     termsite,  
     termaddr,        
     termdist,
     termcimu,        
     termprov,   
     termregn,  
     machtype,  
     termodel,   
     dateinst,   
     termloc,           
     termtype,  
     refnum,            
     linktype   
     )               
   VALUES(  :pte_atm01.bkcb_name,    
     :pte_atm01.termnumr,         

     :pte_atm01.bourder,          
     :pte_atm01.mnemonic, 
     :pte_atm01.brchname,           
     :pte_atm01.termsite,  
     :pte_atm01.termaddr,        
     :pte_atm01.termdist,
     :pte_atm01.termcimu,        
     :pte_atm01.termprov,   
     :pte_atm01.termregn,  
     :pte_atm01.machtype,  
     :pte_atm01.termodel,   
     :pte_atm01.dateinst,   
     :pte_atm01.termloc,           
     :pte_atm01.termtype,  
     :pte_atm01.refnum,            
     :pte_atm01.linktype 
      );
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : ATM01 ,Fun_Name : db_insert_atm01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg );
		sprintf(er_buf,"In db_insert_atm01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_insert_neg01
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into NEG01.
 *
 *  INPUTS:       neg01_ptr - NEG01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_insert_neg01( pNEG01 neg01_ptr, pCHAR ErrorMsg )
{
   neg01_to_db( neg01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL INSERT INTO neg01
     (  card_nbr,    
        card_type,         

     card_exten,          
     card_status 
     )               
   VALUES(  :pte_neg01.card_nbr,    
     :pte_neg01.card_type,         

     :pte_neg01.card_exten,          
     :pte_neg01.card_status
      );
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NEG01 ,Fun_Name : db_insert_neg01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_neg01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}

/******************************************************************************
 *
 *  NAME:         db_insert_saf01
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into SAF01.
 *
 *  INPUTS:       saf01_ptr - SAF01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Unknown
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_insert_saf01( pSAF01 saf01_ptr, pCHAR ErrorMsg )
{
   saf01_to_db( saf01_ptr );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL INSERT INTO saf01
     ( transaction_id,
      card_num,
      tran_amount,
      device_id,
      message_type,
      processing_code,
      sys_trace_audit_nbr,
      tran_date,
      tran_time,
      tx_key,
      retrieval_ref_num,
      merchant_id,
      auth_number,
      response_code,
      invoice_nbr,
      network_data,
      currency_code,
      transmission_timestamp,
      exp_date,
      settlement_amount,
      settlement_date,
      settlement_conv_rate,
      settlement_curr_code,
      billing_amount,
      billing_conv_rate,
      billing_curr_code,  
      tran_fee_amount,
      handler_queue,
      acquiring_inst_id_code,
      forwarding_inst_id_code,
      reversal_amount
     )               
   VALUES(  :pte_saf01.transaction_id,
     :pte_saf01.card_num,
     :pte_saf01.tran_amount,
     :pte_saf01.device_id,
     :pte_saf01.message_type,
     :pte_saf01.processing_code,
     :pte_saf01.sys_trace_audit_nbr,
     :pte_saf01.tran_date,
     :pte_saf01.tran_time,
     :pte_saf01.tx_key,
     :pte_saf01.retrieval_ref_num,
     :pte_saf01.merchant_id,
     :pte_saf01.auth_number,
     :pte_saf01.response_code,
     :pte_saf01.invoice_nbr,
     :pte_saf01.network_data,
     :pte_saf01.currency_code,
     :pte_saf01.transmission_timestamp,
     :pte_saf01.exp_date,
     :pte_saf01.settlement_amount,
     :pte_saf01.settlement_date,
     :pte_saf01.settlement_conv_rate,
     :pte_saf01.settlement_curr_code ,
     :pte_saf01.billing_amount,
     :pte_saf01.billing_conv_rate,
     :pte_saf01.billing_curr_code,  
     :pte_saf01.tran_fee_amount ,
     :pte_saf01.handler_queue,
     :pte_saf01.acquiring_inst_id_code,
     :pte_saf01.forwarding_inst_id_code,
     :pte_saf01.reversal_amount
      );
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : SAF01 ,Fun_Name : db_insert_saf01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   if ( SQLCODE != 0 )
   {
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_saf01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   return PTEMSG_OK;
}
/******************************************************************************
 *
 *  NAME:         db_get_ncf01_gui_list
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                list of records from NCF01 based on a key values.  The records
 *                are stored into an array of NCF01 structures.
 *
 *  INPUTS:       ncf01_ptr - NCF01 structure
 *
 *  OUTPUTS:      Ncf01_List - Array of records returned
 *                ErrorMsg   - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Supriya
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_get_ncf01_gui_list( pNCF01          ncf01_ptr,
                            pNCF01_GUI_LIST Ncf01_List,
                            pCHAR           ErrorMsg )
{

    EXEC SQL BEGIN DECLARE SECTION;
    char network_id[11];
    char network_type[2];
    int temp;
    EXEC SQL END DECLARE SECTION;

   memset( Ncf01_List, 0, sizeof(NCF01_GUI_LIST) );
   strcpy(Ncf01_List->num_returned,"0");
   strncpy( network_id, ncf01_ptr->primary_key.network_id, sizeof(network_id) );
   strncpy( network_type, ncf01_ptr->primary_key.network_type, sizeof(network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL DECLARE ncf01_cursor3 CURSOR FOR
      SELECT * from ncf01
      WHERE  (network_id >= :network_id AND network_type >= :network_type) OR
                  (network_id > :network_id)
	  ORDER BY network_id;
	  
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_get_ncf01_gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN ncf01_cursor3;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < GUI_MAX_LIST_SIZE ; temp++ )
   {
      memset(&db_ncf01, 0x00, sizeof(db_ncf01));
      
      if ( db_error_statics_flag == true )
   	  {
      	start_time = ptetime_get_time();
   	  }
      EXEC SQL FETCH ncf01_cursor3
      INTO :db_ncf01;
      
      if ( db_error_statics_flag == true )
      {
      	end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_CURSOR3 ,Fun_Name : db_get_ncf01_gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	  }
      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA  )
      {
	         SQL_CODE = SQLCODE;
	         EXEC SQL CLOSE ncf01_cursor3;
	         
			memset(er_buf,0x00,sizeof(er_buf));
			DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
			sprintf(er_buf,"In db_get_ncf01_gui_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
			strcat(er_buf,ErrorMsg);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
			return DB_rcode;
       }
      db_to_ncf01(&Ncf01_List->ncf01_record[temp]);
      sprintf( Ncf01_List->num_returned, "%d", (temp+1) );
   }

   EXEC SQL CLOSE ncf01_cursor3;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In  db_get_ncf01_gui_list,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
}

/******************************************************************************
 *
 *  NAME:         db_get_ncf01_gui_list_by_type
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                list of records from NCF01 based on network Id.  The records
 *                are stored into an array of NCF01 structures.
 *
 *  INPUTS:       Network_Id - Key value to select ncf01 records
 *
 *  OUTPUTS:      Ncf01_List - Array of records returned
 *                ErrorMsg   - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Supriya
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_get_ncf01_gui_list_by_type( pCHAR           Network_Id,
                                    pNCF01_GUI_LIST Ncf01List,
                                    pCHAR           ErrorMsg )
{

   EXEC SQL BEGIN DECLARE SECTION;
   char network_id[11];
   char network_type[2];
   int temp;
   EXEC SQL END DECLARE SECTION;

   memset( Ncf01List, 0, sizeof(NCF01_GUI_LIST) );
   strcpy(Ncf01List->num_returned,"0");
   strncpy( network_id, Network_Id, sizeof(network_id) );
   strncpy( network_type, Network_Id + sizeof(network_id), sizeof(network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DECLARE ncf01_cursor CURSOR FOR
      SELECT * from ncf01
      WHERE  network_id >= :network_id AND network_type = :network_type
	  ORDER BY network_id;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_get_ncf01_gui_list_by_type , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }	  
    
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN ncf01_cursor;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < GUI_MAX_LIST_SIZE; temp++ )
   {
      memset(&db_ncf01, 0x00, sizeof(db_ncf01));
      if ( db_error_statics_flag == true )
   	  {
      	start_time = ptetime_get_time();
   	  }
      EXEC SQL FETCH ncf01_cursor
      INTO :db_ncf01;
      
      if ( db_error_statics_flag == true )
      {
      	end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_CURSOR ,Fun_Name : db_get_ncf01_gui_list_by_type , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	  }

      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
	         SQL_CODE = SQLCODE;
	         EXEC SQL CLOSE ncf01_cursor;
	         
			memset(er_buf,0x00,sizeof(er_buf));
			DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
			sprintf(er_buf,"In db_get_ncf01_gui_list_by_type ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
			strcat(er_buf,ErrorMsg);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
			return DB_rcode;
   
      }
      db_to_ncf01(&Ncf01List->ncf01_record[temp]);
      sprintf( Ncf01List->num_returned, "%d", (temp+1) );
   }

   EXEC SQL CLOSE ncf01_cursor;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
	memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_ncf01_gui_list_by_type ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
   
}
/******************************************************************************
 *
 *  NAME:         db_get_ncf01_gui_list
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                list of records from NCF01 based on a key values.  The records
 *                are stored into an array of NCF01 structures.
 *
 *  INPUTS:       ncf01_ptr - NCF01 structure
 *
 *  OUTPUTS:      Ncf01_List - Array of records returned
 *                ErrorMsg   - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Supriya
 *
 *  MODIFICATIONS:
 ******************************************************************************/

BYTE db_get_ncf01_keyblock_gui_list( pNCF01_KEYBLOCK          ncf01_keyblock_ptr,
                            pNCF01_KEYBLOCK_GUI_LIST 			Ncf01_KeyblockList,
                            pCHAR           ErrorMsg )
{

    EXEC SQL BEGIN DECLARE SECTION;
    char network_id[11];
    /*char network_type[2];*/
    int temp;
    EXEC SQL END DECLARE SECTION;

   memset( Ncf01_KeyblockList, 0, sizeof(NCF01_KEYBLOCK_GUI_LIST) );
   strcpy(Ncf01_KeyblockList->num_returned,"0");
   strncpy( network_id, ncf01_keyblock_ptr->network_id, sizeof(network_id) );
   /*strncpy( network_type, ncf01_keyblock_ptr->NETWORK_TYPE, sizeof(network_type) );*/

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL DECLARE ncf01_keyblock_cursor3 CURSOR FOR
      SELECT * from ncf01_keyblock
      WHERE  (network_id >= :network_id ) OR
                  (network_id > :network_id)
	  ORDER BY network_id;
	  
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK01_DATA ,Fun_Name : db_get_ncf01_keyblock__gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN ncf01_keyblock_cursor3;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < GUI_MAX_LIST_SIZE ; temp++ )
   {
      memset(&db_ncf01_keyblock, 0x00, sizeof(db_ncf01_keyblock));
      
      if ( db_error_statics_flag == true )
   	  {
      	start_time = ptetime_get_time();
   	  }
      EXEC SQL FETCH ncf01_keyblock_cursor3
      INTO :db_ncf01_keyblock;
      
      if ( db_error_statics_flag == true )
      {
      	end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK_CURSOR3 ,Fun_Name : db_get_ncf01_keyblock__gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	  }
      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA  )
      {
	         SQL_CODE = SQLCODE;
	         EXEC SQL CLOSE ncf01_keyblock_cursor3;
	         
			memset(er_buf,0x00,sizeof(er_buf));
			DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
			sprintf(er_buf,"In db_get_ncf01_keyblock__gui_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
			strcat(er_buf,ErrorMsg);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
			return DB_rcode;
       }
      db_to_ncf01_keyblock(&Ncf01_KeyblockList->ncf01_keyblock_record[temp]);
      sprintf( Ncf01_KeyblockList->num_returned, "%d", (temp+1) );
   }

   EXEC SQL CLOSE ncf01_keyblock_cursor3;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In  db_get_ncf01_keyblock__gui_list,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
}

/******************************************************************************
 *
 *  NAME:         db_get_ncf01_gui_list_by_type
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                list of records from NCF01 based on network Id.  The records
 *                are stored into an array of NCF01 structures.
 *
 *  INPUTS:       Network_Id - Key value to select ncf01 records
 *
 *  OUTPUTS:      Ncf01_List - Array of records returned
 *                ErrorMsg   - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Supriya
 *
 *  MODIFICATIONS:
 ******************************************************************************/

BYTE db_get_ncf01_keyblock_gui_list_by_type( pCHAR           Network_Id,
                                    pNCF01_KEYBLOCK_GUI_LIST Ncf01_KeyblockList,
                                    pCHAR           ErrorMsg )
{

   EXEC SQL BEGIN DECLARE SECTION;
   char network_id[11];
   /*char network_type[2];*/
   int temp;
   EXEC SQL END DECLARE SECTION;

   memset( Ncf01_KeyblockList, 0, sizeof(NCF01_KEYBLOCK_GUI_LIST) );
   strcpy(Ncf01_KeyblockList->num_returned,"0");
   strncpy( network_id, Network_Id, sizeof(network_id) );
   /*strncpy( network_type, Network_Id + sizeof(network_id), sizeof(network_type) ); */

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DECLARE ncf01_keyblock_cursor CURSOR FOR
      SELECT * from ncf01_keyblock
      WHERE  network_id >= :network_id
	  ORDER BY network_id;
   
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK01_DATA ,Fun_Name : db_get_ncf01_keyblock_gui_list_by_type , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }	  
    
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN ncf01_keyblock_cursor;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < GUI_MAX_LIST_SIZE; temp++ )
   {
      memset(&db_ncf01_keyblock, 0x00, sizeof(db_ncf01_keyblock));
      if ( db_error_statics_flag == true )
   	  {
      	start_time = ptetime_get_time();
   	  }
      EXEC SQL FETCH ncf01_keyblock_cursor
      INTO :db_ncf01_keyblock;
      
      if ( db_error_statics_flag == true )
      {
      	end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_KEYBLOCK_CURSOR ,Fun_Name : db_get_ncf01_keyblock_gui_list_by_type , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	  }

      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
	         SQL_CODE = SQLCODE;
	         EXEC SQL CLOSE ncf01_cursor;
	         
			memset(er_buf,0x00,sizeof(er_buf));
			DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
			sprintf(er_buf,"In db_get_ncf01_keyblock_gui_list_by_type ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
			strcat(er_buf,ErrorMsg);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
			return DB_rcode;
   
      }
      db_to_ncf01_keyblock(&Ncf01_KeyblockList->ncf01_keyblock_record[temp]);
      sprintf( Ncf01_KeyblockList->num_returned, "%d", (temp+1) );
   }

   EXEC SQL CLOSE ncf01_keyblock_cursor;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
	memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_ncf01_keyblock_gui_list_by_type ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
   
}


/******************************************************************************
 *
 *  NAME:         db_get_ncf02_gui_list
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                list of records from NCF02 based on a key values.  The records
 *                are stored into an array of NCF02 structures.
 *
 *  INPUTS:       ncf02_ptr - NCF02 structure
 *
 *  OUTPUTS:      Ncf02_List - Array of records returned
 *                ErrorMsg   - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Supriya
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_get_ncf02_gui_list( pNCF02          ncf02_ptr,
                            pNCF02_GUI_LIST Ncf02_List,
                            pCHAR           ErrorMsg )
{

   EXEC SQL BEGIN DECLARE SECTION;
   char network_id [11];
   char network_type[2];  
   int temp;
   EXEC SQL END DECLARE SECTION;

   memset( Ncf02_List, 0, sizeof(NCF02_GUI_LIST) );
   strcpy(Ncf02_List->num_returned,"0");
   strncpy( network_id, ncf02_ptr->primary_key.network_id, sizeof(network_id) );
   strncpy( network_type, ncf02_ptr->primary_key.network_type, sizeof(network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DECLARE ncf02_cursor1 CURSOR FOR
      SELECT * from ncf02
      WHERE (network_id = :network_id AND network_type >= :network_type) OR
                  (network_id > :network_id);
             
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF02 ,Fun_Name : db_get_ncf02_gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN ncf02_cursor1;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < GUI_MAX_LIST_SIZE ; temp++ )
   {
      memset(&db_ncf02, 0x00, sizeof(db_ncf02));
      if ( db_error_statics_flag == true )
      {
      		start_time = ptetime_get_time();
      }
      EXEC SQL FETCH ncf02_cursor1
      INTO :db_ncf02;
      
      if ( db_error_statics_flag == true )
   	  {
      		end_time = ptetime_get_time();
      		duration = end_time - start_time;
      		if(duration >= db_error_statics_value)
	  		{
	  			memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
				sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF02_CURSOR1 ,Fun_Name : db_get_ncf02_gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
				Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  		}
   	  }

      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
         SQL_CODE = SQLCODE;
         EXEC SQL CLOSE ncf02_cursor1;
         
		 memset(er_buf,0x00,sizeof(er_buf));
		 DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		 sprintf(er_buf,"In db_get_ncf02_gui_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		 strcat(er_buf,ErrorMsg);
		 Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		 return DB_rcode;
   
      }
      db_to_ncf02(&Ncf02_List->ncf02_record[temp]);
      sprintf( Ncf02_List->num_returned, "%d", (temp+1) );
   }

   EXEC SQL CLOSE ncf02_cursor1;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_ncf02_gui_list ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
}


BYTE db_get_obs01_gui_list( pOBS01          obs01_ptr,
                            pOBS01_GUI_LIST OBS01_List,
                            pCHAR           ErrorMsg )
{

   EXEC SQL BEGIN DECLARE SECTION;
   char on_behalf_service [3] = {0};
   char on_behalf_result[2] = {0};  
   int temp = 0;
   EXEC SQL END DECLARE SECTION;

   memset( OBS01_List, 0, sizeof(OBS01_GUI_LIST) );
   strcpy(OBS01_List->num_returned,"0");
   if(obs01_ptr->on_behalf_service[0] == '\0')
   {
   		on_behalf_service[0] = ' ';
   		on_behalf_result[0] = ' '; 
   }
   else
   {
      strncpy( on_behalf_service, obs01_ptr->on_behalf_service, sizeof(on_behalf_service) );
   	  strncpy( on_behalf_result, obs01_ptr->on_behalf_result, sizeof(on_behalf_result) );
   }


   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DECLARE obs01_cursor1 CURSOR FOR
      SELECT * from obs01
      WHERE (on_behalf_service = :on_behalf_service AND on_behalf_result >= :on_behalf_result) OR
                  (on_behalf_service > :on_behalf_service);
             
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01 ,Fun_Name : db_get_obs01_gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN obs01_cursor1;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < GUI_MAX_LIST_SIZE ; temp++ )
   {
      memset(&db_obs01, 0x00, sizeof(db_obs01));
      if ( db_error_statics_flag == true )
      {
      		start_time = ptetime_get_time();
      }
      EXEC SQL FETCH obs01_cursor1
      INTO :db_obs01;
      
      if ( db_error_statics_flag == true )
   	  {
      		end_time = ptetime_get_time();
      		duration = end_time - start_time;
      		if(duration >= db_error_statics_value)
	  		{
	  			memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
				sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01_CURSOR1 ,Fun_Name : db_get_obs01_gui_list , Duration = %f, on_behalf_service: %s,on_behalf_result:%s",
				DB_MsgSubtype1,DB_MsgSubtype2,duration,db_obs01.on_behalf_service,db_obs01.on_behalf_result);
				Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  		}
   	  }

      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
         SQL_CODE = SQLCODE;
         EXEC SQL CLOSE obs01_cursor1;
         
		 memset(er_buf,0x00,sizeof(er_buf));
		 DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		 sprintf(er_buf,"In db_get_obs01_gui_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		 strcat(er_buf,ErrorMsg);
		 Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		 return DB_rcode;
   
      }
      db_to_obs01(&OBS01_List->obs01_record[temp]);
      sprintf( OBS01_List->num_returned, "%d", (temp+1) );
   }

   EXEC SQL CLOSE obs01_cursor1;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_obs01_gui_list ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
}

/******************************************************************************/

BYTE db_get_visa3ds2_gui_list( pVISA3DS2 visa3ds2_ptr,
                            pVISA3DS2_GUI_LIST VISA3DS2_List,
                            pCHAR           ErrorMsg )
{

   EXEC SQL BEGIN DECLARE SECTION;
   char cavv[2] = {0};  
   int temp = 0;
   EXEC SQL END DECLARE SECTION;

   memset( VISA3DS2_List, 0, sizeof(VISA3DS2_GUI_LIST) );
   strcpy(VISA3DS2_List->num_returned,"0");
   if(visa3ds2_ptr->cavv[0] == '\0')
   {
   		cavv[0] = ' ';

   }
   else
   {
      strncpy( cavv, visa3ds2_ptr->cavv, sizeof(cavv) );
   }


   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DECLARE visa3ds2_cursor1 CURSOR FOR
      SELECT * from visa3ds2
      WHERE (cavv = :cavv OR cavv > :cavv);
             
   if ( db_error_statics_flag == true )
   {
      end_time = ptetime_get_time();
      duration = end_time - start_time;
      if(duration >= db_error_statics_value)
	  {
	  	memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
		sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2 ,Fun_Name : db_get_visa3ds2_gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  }
   }
   
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN visa3ds2_cursor1;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < GUI_MAX_LIST_SIZE ; temp++ )
   {
      memset(&db_visa3ds2, 0x00, sizeof(db_visa3ds2));
      if ( db_error_statics_flag == true )
      {
      		start_time = ptetime_get_time();
      }
      EXEC SQL FETCH visa3ds2_cursor1
      INTO :db_visa3ds2;
      
      if ( db_error_statics_flag == true )
   	  {
      		end_time = ptetime_get_time();
      		duration = end_time - start_time;
      		if(duration >= db_error_statics_value)
	  		{
	  			memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
				sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2_CURSOR1 ,Fun_Name : db_get_visa3ds2_gui_list , Duration = %f, cavvt:%s",
				DB_MsgSubtype1,DB_MsgSubtype2,duration,db_visa3ds2.cavv);
				Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  		}
   	  }

      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
         SQL_CODE = SQLCODE;
         EXEC SQL CLOSE visa3ds2_cursor1;
         
		 memset(er_buf,0x00,sizeof(er_buf));
		 DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		 sprintf(er_buf,"In db_get_visa3ds2_gui_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		 strcat(er_buf,ErrorMsg);
		 Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		 return DB_rcode;
   
      }
      db_to_visa3ds2(&VISA3DS2_List->visa3ds2_record[temp]);
      sprintf( VISA3DS2_List->num_returned, "%d", (temp+1) );
   }

   EXEC SQL CLOSE visa3ds2_cursor1;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_visa3ds2_gui_list ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
}

/******************************************************************************
 *
 *  NAME:         db_get_ncf30_service_list
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                list of records from NCF30 based on key values.  The records
 *                are stored into an array of NCF30 structures.
 *
 *  INPUTS:       ncf30_ptr - NCF30 structure
 *
 *  OUTPUTS:      Ncf30_List - Array of records returned
 *                ErrorMsg   - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Dirby
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_get_ncf30_service_list( pNCF30 ncf30_ptr,
                                pNCF30_BATCH_LIST Ncf30_List,
                                pCHAR ErrorMsg )
{

    EXEC SQL BEGIN DECLARE SECTION;
    char network_id[11];
    char network_type[2];
    char batch_nbr[7];
    char retrieval_ref_num[13];
    char open_date[9];
    char open_time[7];
    int  temp;
    EXEC SQL END DECLARE SECTION;

   memset( Ncf30_List, 0, sizeof(NCF30_BATCH_LIST) );
   strcpy(Ncf30_List->num_returned,"0");
   strncpy( network_id, ncf30_ptr->primary_key.network_id, sizeof(network_id) );
   strncpy( network_type, ncf30_ptr->primary_key.network_type, sizeof(network_type) );
   strncpy( batch_nbr, ncf30_ptr->primary_key.batch_number, sizeof(batch_nbr) );
   strncpy( retrieval_ref_num, ncf30_ptr->primary_key.retrieval_ref_num, sizeof(retrieval_ref_num) );
   strncpy( open_date, ncf30_ptr->open_date, sizeof(open_date) );
   strncpy( open_time, ncf30_ptr->open_time, sizeof(open_time) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   EXEC SQL DECLARE ncf30_cursor2 CURSOR FOR
      SELECT * from ncf30
      WHERE  retrieval_ref_num > :retrieval_ref_num 
             AND  batch_number = :batch_nbr
             AND  network_id   = :network_id 
             AND  network_type = :network_type
             AND  open_date    = :open_date
             AND  open_time    = :open_time
      ORDER BY retrieval_ref_num;
      
   if ( db_error_statics_flag == true )
   {
      	end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : ncf30 ,Fun_Name : db_get_ncf30_service_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   }
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN ncf30_cursor2;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < BATCH_SERVICE_LIST_SIZE; temp++ )
   {
      memset(&db_ncf30, 0x00, sizeof(db_ncf30));
      if ( db_error_statics_flag == true )
   	  {
        	start_time = ptetime_get_time();
      } 
      
      EXEC SQL FETCH ncf30_cursor2
      INTO :db_ncf30;
      
      if ( db_error_statics_flag == true )
   	  {
        	end_time = ptetime_get_time();
      	    duration = end_time - start_time;
      		if(duration >= db_error_statics_value)
	  		{
	  			memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
				sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : ncf30_cursor2 ,Fun_Name : db_get_ncf30_service_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
				Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  		}
   	   }
      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
         SQL_CODE = SQLCODE;
         EXEC SQL CLOSE ncf30_cursor2;
         memset(er_buf,0x00,sizeof(er_buf));
		 DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		 sprintf(er_buf,"In db_get_ncf30_service_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		 strcat(er_buf,ErrorMsg);
		 Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		 return DB_rcode;
      }
      db_to_ncf30(&Ncf30_List->batch_list[temp]);
      sprintf(Ncf30_List->num_returned, "%d", temp+1 );
   }

   EXEC SQL CLOSE ncf30_cursor2;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_ncf30_service_list ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
}

/******************************************************************************
 *
 *  NAME:         db_get_ncf01_service_list
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                list of records from NCF01 based on key values.  The records
 *                are stored into an array of NCF01 structures.
 *
 *  INPUTS:       ncf01_ptr - NCF01 structure
 *
 *  OUTPUTS:      Ncf01_List - Array of records returned
 *                ErrorMsg   - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       Irina Arustamova
 *
 *  MODIFICATIONS:
 ******************************************************************************/
BYTE db_get_ncf01_service_list( pNCF01 ncf01_ptr,
                                pNCF01_LIST Ncf01_List,
                                pCHAR ErrorMsg )
{

    EXEC SQL BEGIN DECLARE SECTION;

    char network_id[11];
    char network_type[2];
    int  temp;

    EXEC SQL END DECLARE SECTION;

   memset( Ncf01_List, 0, sizeof(NCF01_LIST) );
   strcpy(Ncf01_List->num_returned,"0");
   strncpy( network_id, ncf01_ptr->primary_key.network_id, sizeof(network_id) );
   strncpy( network_type, ncf01_ptr->primary_key.network_type, sizeof(network_type) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DECLARE ncf01_cursor4 CURSOR FOR
      SELECT * from ncf01
      WHERE  network_id > :network_id 
             AND  network_id = :network_id
      ORDER BY network_id;
   
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01 ,Fun_Name : db_get_ncf01_service_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN ncf01_cursor4;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < SERVICE_LIST_SIZE; temp++ )
   {
      memset(&db_ncf01, 0x00, sizeof(db_ncf01));
      if ( db_error_statics_flag == true )
      {
          start_time = ptetime_get_time();
      }
      
      EXEC SQL FETCH ncf01_cursor4
      INTO :db_ncf01;
      
      if ( db_error_statics_flag == true )
      {
         end_time = ptetime_get_time();
      	 duration = end_time - start_time;
      	 if(duration >= db_error_statics_value)
	  	 {
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : NCF01_CURSOR4 ,Fun_Name : db_get_ncf01_service_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	 }
   	  }
      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
         SQL_CODE = SQLCODE;
         EXEC SQL CLOSE ncf01_cursor4;
         memset(er_buf,0x00,sizeof(er_buf));
		 DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		 sprintf(er_buf,"In db_get_ncf01_service_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		 strcat(er_buf,ErrorMsg);
		 Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		 return DB_rcode;
   
      }
      db_to_ncf01(&Ncf01_List->ncf01_record[temp]);
      sprintf(Ncf01_List->num_returned, "%d", temp+1 );
   }

   EXEC SQL CLOSE ncf01_cursor4;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
	memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_ncf01_service_list ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;
  
}

BYTE db_get_obs01_service_list(pOBS01 obs01_ptr,
                                pOBS01_GUI_LIST OBS01_List,
                                pCHAR ErrorMsg )
{

    EXEC SQL BEGIN DECLARE SECTION;

    char on_behalf_service[3];
    char on_behalf_result[2];
    int  temp;

    EXEC SQL END DECLARE SECTION;

   memset( OBS01_List, 0, sizeof(OBS01_List) );
   strcpy(OBS01_List->num_returned,"0");
   strncpy( on_behalf_service, obs01_ptr->on_behalf_service, sizeof(on_behalf_service) );
   strncpy( on_behalf_result, obs01_ptr->on_behalf_result, sizeof(on_behalf_result) );

   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DECLARE obs01_cursor4 CURSOR FOR
      SELECT * from ncf01
      WHERE  on_behalf_service > :on_behalf_service 
             AND  on_behalf_service = :on_behalf_service
      ORDER BY on_behalf_service;
   
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01 ,Fun_Name : db_get_obs01_service_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN obs01_cursor4;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < SERVICE_LIST_SIZE; temp++ )
   {
      memset(&db_obs01, 0x00, sizeof(db_obs01));
      if ( db_error_statics_flag == true )
      {
          start_time = ptetime_get_time();
      }
      
      EXEC SQL FETCH obs01_cursor4
      INTO :db_obs01;
      
      if ( db_error_statics_flag == true )
      {
         end_time = ptetime_get_time();
      	 duration = end_time - start_time;
      	 if(duration >= db_error_statics_value)
	  	 {
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01_CURSOR4 ,Fun_Name : db_get_obs01_service_list , Duration = %f,on_behalf_service:%s,on_behalf_result:%s",
			DB_MsgSubtype1,DB_MsgSubtype2,duration,db_obs01.on_behalf_service,db_obs01.on_behalf_result);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	 }
   	  }
      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
         SQL_CODE = SQLCODE;
         EXEC SQL CLOSE obs01_cursor4;
         memset(er_buf,0x00,sizeof(er_buf));
		 DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		 sprintf(er_buf,"In db_get_obs01_service_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		 strcat(er_buf,ErrorMsg);
		 Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		 return DB_rcode;
   
      }
      db_to_obs01(&OBS01_List->obs01_record[temp]);
      sprintf(OBS01_List->num_returned, "%d", temp+1 );
   }

   EXEC SQL CLOSE obs01_cursor4;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
	memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_obs01_service_list ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;

}

/******************************************************************************/

BYTE db_get_visa3ds2_service_list(pVISA3DS2 visa3ds2_ptr,
                                pVISA3DS2_GUI_LIST VISA3DS2_List,
                                pCHAR ErrorMsg )
{

    EXEC SQL BEGIN DECLARE SECTION;

    char cavv[2];
    int  temp;

    EXEC SQL END DECLARE SECTION;

   memset( VISA3DS2_List, 0, sizeof(VISA3DS2_List) );
   strcpy(VISA3DS2_List->num_returned,"0");
   strncpy( cavv, visa3ds2_ptr->cavv, sizeof(cavv) );


   if ( db_error_statics_flag == true )
   {
      start_time = ptetime_get_time();
   }
   
   EXEC SQL DECLARE visa3ds2_cursor4 CURSOR FOR
      SELECT * from VISA3DS2
      WHERE  cavv > :cavv 
      ORDER BY cavv;
   
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2 ,Fun_Name : db_get_obs01_service_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN visa3ds2_cursor4;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < SERVICE_LIST_SIZE; temp++ )
   {
      memset(&db_visa3ds2, 0x00, sizeof(db_visa3ds2));
      if ( db_error_statics_flag == true )
      {
          start_time = ptetime_get_time();
      }
      
      EXEC SQL FETCH visa3ds2_cursor4
      INTO :db_visa3ds2;
      
      if ( db_error_statics_flag == true )
      {
         end_time = ptetime_get_time();
      	 duration = end_time - start_time;
      	 if(duration >= db_error_statics_value)
	  	 {
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2_CURSOR4 ,Fun_Name : db_get_visa3ds2_service_list , Duration = %f,cavv:%s",
			DB_MsgSubtype1,DB_MsgSubtype2,duration,db_visa3ds2.cavv);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	 }
   	  }
      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
      {
         SQL_CODE = SQLCODE;
         EXEC SQL CLOSE visa3ds2_cursor4;
         memset(er_buf,0x00,sizeof(er_buf));
		 DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		 sprintf(er_buf,"In db_get_visa3ds2_service_list ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		 strcat(er_buf,ErrorMsg);
		 Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		 return DB_rcode;
   
      }
      db_to_visa3ds2(&VISA3DS2_List->visa3ds2_record[temp]);
      sprintf(VISA3DS2_List->num_returned, "%d", temp+1 );
   }

   EXEC SQL CLOSE visa3ds2_cursor4;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
	memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_visa3ds2_service_list ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;

}

/******************************************************************************
 *
 *  NAME:         db_insert_fg01
 *
 *  DESCRIPTION:  This function makes the call to the database to insert a
 *                record into FG01.
 *
 *  INPUTS:       fg01_ptr - FG01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
BYTE db_insert_fg01( pFG01 fg01_ptr, pCHAR ErrorMsg )
{
   BYTE  retval;

   fg01_to_db( fg01_ptr );

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   EXEC SQL INSERT INTO fg01
     (NAME,
      TYPE,
      CALLER_ID,
      SOURCE,
      USERNAME,
      APPLICATION,
      RULE_DOMAIN,
      PRODUCT,
      PRIORITY,
      TPDU_ID,
      QUEUE_NAME,
      REQUEST_TIMER,
      ECHO_TIMER
     )               
   VALUES
     (:pte_fg01.name,
      :pte_fg01.type,
      :pte_fg01.caller_id,
      :pte_fg01.source,
      :pte_fg01.username,
      :pte_fg01.application,
      :pte_fg01.rule_domain,
      :pte_fg01.product,
      :pte_fg01.priority,
      :pte_fg01.tpdu_id,
      :pte_fg01.queue_name,
      :pte_fg01.request_timer,
      :pte_fg01.echo_timer
     );
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01 ,Fun_Name : db_insert_fg01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if ( SQLCODE == 0 )
      retval = PTEMSG_OK;
   else
   {
		memset(er_buf,0x00,sizeof(er_buf));
		retval = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_insert_fg01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		
   }

   return( retval );
}


/******************************************************************************
 *
 *  NAME:         db_update_fg01
 *
 *  DESCRIPTION:  This function makes the call to the database to update a
 *                record in FG01 based on key values in fg01_ptr.
 *                The record is copied into pte_fg01, then the database is
 *                updated.
 *
 *  INPUTS:       fg01_ptr - FG01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
BYTE db_update_fg01( pFG01 fg01_ptr, pCHAR ErrorMsg )
{
   BYTE  retval;

   fg01_to_db( fg01_ptr );

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to update it. */
   EXEC SQL
      SELECT *
      INTO  :db_fg01
      FROM   FG01
      WHERE  name   = :pte_fg01.name AND
      		 rownum = 1
      For Update NOWAIT;
   
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01 ,Fun_Name : db_update_fg01_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_fg01 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;

   }

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   
   EXEC SQL UPDATE fg01
   SET  name           = :pte_fg01.name,
        type           = :pte_fg01.type,
        caller_id      = :pte_fg01.caller_id,
        source         = :pte_fg01.source,
        username       = :pte_fg01.username,
        application    = :pte_fg01.application,
        rule_domain    = :pte_fg01.rule_domain,
        product        = :pte_fg01.product,
        priority       = :pte_fg01.priority,
        tpdu_id        = :pte_fg01.tpdu_id,
        queue_name     = :pte_fg01.queue_name,
        request_timer  = :pte_fg01.request_timer,
        echo_timer     = :pte_fg01.echo_timer

   WHERE  name = :pte_fg01.name;
   
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01 ,Fun_Name : db_update_fg01_U , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if ( SQLCODE == 0 )
      retval = PTEMSG_OK;
   else
   {
		memset(er_buf,0x00,sizeof(er_buf));
		retval = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_update_fg01 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		
	}

   return( retval );
}


/******************************************************************************
 *
 *  NAME:         db_delete_fg01
 *
 *  DESCRIPTION:  This function makes the call to the database to delete a
 *                record in FG01 based on key values in fg01_ptr.
 *                The record is copied into pte_fg01, then the record is
 *                deleted.
 *
 *  INPUTS:       fg01_ptr - FG01 structure
 *
 *  OUTPUTS:      ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
BYTE db_delete_fg01( pFG01 fg01_ptr, pCHAR ErrorMsg)
{
   BYTE  retval;

   fg01_to_db( fg01_ptr );

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_fg01
      FROM   FG01
      WHERE  name   =   :pte_fg01.name  AND
      		 rownum = 1
      For Update NOWAIT;
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01 ,Fun_Name : db_delete_fg01_S , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_fg01 ,ST1:%d,ST2: %d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   EXEC SQL DELETE FROM fg01
   WHERE  name = :pte_fg01.name;
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01 ,Fun_Name : db_delete_fg01_D , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if (( SQLCODE == 0 ) || ( SQLCODE == NO_DATA_FOUND) )
      retval = PTEMSG_OK;
   else
   {
	memset(er_buf,0x00,sizeof(er_buf));
	retval = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_delete_fg01 ,ST1:%d,ST2: %d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);

}

   return( retval );
}

BYTE db_delete_obs01( pOBS01 obs01_ptr, pCHAR ErrorMsg)
{
   BYTE  retval;

   obs01_to_db( obs01_ptr );

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_obs01
      FROM   OBS01
      WHERE  on_behalf_service   = :pte_obs01.on_behalf_service	AND 
         		on_behalf_result = :pte_obs01.on_behalf_result  AND
         		rownum = 1
      		For Update NOWAIT;
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : OBS01 ,Fun_Name : db_delete_obs01_S , Duration = %f,on_behalf_service:%s,on_behalf_result:%s",
			DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_obs01 ,ST1:%d,ST2: %d_1,on_behalf_service:%s,on_behalf_result:%s",
		DB_MsgSubtype1,DB_MsgSubtype2,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   EXEC SQL DELETE OBS01
      WHERE  on_behalf_service   = :pte_obs01.on_behalf_service	AND 
         		on_behalf_result = :pte_obs01.on_behalf_result;
   
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01 ,Fun_Name : db_delete_obs01_D , Duration = %f,on_behalf_service:%s,on_behalf_result:%s",
			DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if (( SQLCODE == 0 ) || ( SQLCODE == NO_DATA_FOUND) )
      retval = PTEMSG_OK;
   else
   {
	memset(er_buf,0x00,sizeof(er_buf));
	retval = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_delete_obs01 ,ST1:%d,ST2: %d_2,on_behalf_service:%s,on_behalf_result:%s",
	DB_MsgSubtype1,DB_MsgSubtype2,pte_obs01.on_behalf_service,pte_obs01.on_behalf_result);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);

}

   return( retval );
}

/******************************************************************************/

BYTE db_delete_visa3ds2( pVISA3DS2 visa3ds2_ptr, pCHAR ErrorMsg)
{
   BYTE  retval;

   visa3ds2_to_db( visa3ds2_ptr );

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   /* Make sure we can access the record before attempting to delete it. */
   EXEC SQL
      SELECT *
      INTO  :db_visa3ds2
      FROM  VISA3DS2
      WHERE  cavv   = :pte_visa3ds2.cavv	AND 
         		rownum = 1
      		For Update NOWAIT;
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2 ,Fun_Name : db_delete_visa3ds2 , Duration = %f,cavv:%s",
			DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_visa3ds2.cavv);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if (SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA )
   {
      /* Record is inaccessible. Return with error. */      
		memset(er_buf,0x00,sizeof(er_buf));
		DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_delete_visa3ds2 ,ST1:%d,ST2: %d_1,cavv:%s",
		DB_MsgSubtype1,DB_MsgSubtype2,pte_visa3ds2.cavv);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		return DB_rcode;
   }

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   EXEC SQL DELETE VISA3DS2
      WHERE  cavv   = :pte_visa3ds2.cavv;	
   
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : VISA3DS2 ,Fun_Name : db_delete_visa3ds2 , Duration = %f,cavv:%s",
			DB_MsgSubtype1,DB_MsgSubtype2,duration,pte_visa3ds2.cavv);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if (( SQLCODE == 0 ) || ( SQLCODE == NO_DATA_FOUND) )
      retval = PTEMSG_OK;
   else
   {
	memset(er_buf,0x00,sizeof(er_buf));
	retval = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_delete_visa3ds2 ,ST1:%d,ST2: %d_2,cavv:%s",
	DB_MsgSubtype1,DB_MsgSubtype2,pte_visa3ds2.cavv);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);

}

   return( retval );
}

/******************************************************************************
 *
 *  NAME:         db_select_fg01
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                record from FG01 based on a key value.  The record is
 *                selected into db_fg01, then copied into fg01_ptr for
 *                the calling function.
 *
 *  INPUTS:       key - Name
 *
 *  OUTPUTS:      fg01_ptr - FG01 structure containing the selected record
 *                ErrorMsg - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
BYTE db_select_fg01( pCHAR  key, pFG01  fg01_ptr, pCHAR  ErrorMsg )
{
   BYTE  retval;

   memset( &db_fg01, 0x00, sizeof(db_fg01) );

   memcpy( pte_fg01.name, key, sizeof(pte_fg01.name) );

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   EXEC SQL SELECT
                   name,
                   type,
                   caller_id,
                   source,
                   username,
                   application,
                   rule_domain,
                   product,
                   priority,
                   tpdu_id,
                   queue_name,
                   request_timer,
                   echo_timer
   INTO :db_fg01
   FROM  fg01
   WHERE name = :pte_fg01.name;
   
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01 ,Fun_Name : db_select_fg01 , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   if ( (SQLCODE == 0) || (SQLCODE == NULL_COLUMN_DATA) )
   {
      db_to_fg01( fg01_ptr );
      retval = PTEMSG_OK;
   }
   else
   {
		memset(er_buf,0x00,sizeof(er_buf));
		retval = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		sprintf(er_buf,"In db_select_fg01 ,ST1:%d,ST2: %d",DB_MsgSubtype1,DB_MsgSubtype2);
		strcat(er_buf,ErrorMsg);
		Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	}

   return( retval );
}

/******************************************************************************
 *
 *  NAME:         db_get_fg01_gui_list
 *
 *  DESCRIPTION:  This function makes the call to the database to select a
 *                list of records from FG01 based on a key value.  The records
 *                are stored into an array of FG01 structures.
 *
 *  INPUTS:       fg01_ptr - FG01 structure
 *
 *  OUTPUTS:      Fg01_List - Array of records returned
 *                ErrorMsg  - Error message if database call failed.
 *
 *  RTRN VALUE:   A PTE code is returned:
 *                       PTEMSG_OK  if no errors else a code to identify
 *                       the reason for the failure.
 *
 *  AUTHOR:       DIrby
 *
 ******************************************************************************/
BYTE db_get_fg01_gui_list( pFG01          fg01_ptr,
                           pFG01_GUI_LIST Fg01_List,
                           pCHAR          ErrorMsg )
{
    EXEC SQL BEGIN DECLARE SECTION;
       char name[11];
       int temp;
    EXEC SQL END DECLARE SECTION;

   memset( Fg01_List, 0x00, sizeof(FG01_GUI_LIST) );
   strcpy( Fg01_List->num_returned,"0");
   memcpy( name, fg01_ptr->name, sizeof(name) );

   if ( db_error_statics_flag == true )
   {
       start_time = ptetime_get_time();
   }
   EXEC SQL DECLARE fg01_cursor3 CURSOR FOR
      SELECT * from fg01
      WHERE    name >= :name
	  ORDER BY name;
   if ( db_error_statics_flag == true )
   {
        end_time = ptetime_get_time();
      	duration = end_time - start_time;
      	if(duration >= db_error_statics_value)
	  	{
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01 ,Fun_Name : db_get_fg01_gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	}
   	}
   EXEC SQL WHENEVER SQLERROR goto sql_error;
   EXEC SQL OPEN fg01_cursor3;

   EXEC SQL WHENEVER SQLERROR goto sql_error2;
   EXEC SQL WHENEVER NOTFOUND DO break;
   for ( temp = 0; temp < GUI_MAX_LIST_SIZE ; temp++ )
   {
      memset( &db_fg01, 0x00, sizeof(db_fg01));
      if ( db_error_statics_flag == true )
   	  {
      	 start_time = ptetime_get_time();
      }
      EXEC SQL FETCH fg01_cursor3
      INTO :db_fg01;
      if ( db_error_statics_flag == true )
   	  {
         end_time = ptetime_get_time();
      	 duration = end_time - start_time;
      	 if(duration >= db_error_statics_value)
	  	 {
	  		memset(DB_Tmr_Lgng_Buf,0x00,sizeof(DB_Tmr_Lgng_Buf));
			sprintf(DB_Tmr_Lgng_Buf,"Exceeded Query: Netds, ST1:%d,ST2:%d ,Data_Type : FG01_CURSOR3 ,Fun_Name : db_get_fg01_gui_list , Duration = %f",DB_MsgSubtype1,DB_MsgSubtype2,duration);
			Log_Db_Statics_And_Oracle_Db_Error_To_File(DB_Tmr_Lgng_Buf);
	  	 }
   	 }
      sql_error2:
      if ( SQLCODE != 0 && SQLCODE != NULL_COLUMN_DATA  )
      {
         SQL_CODE = SQLCODE;
         EXEC SQL CLOSE fg01_cursor3;
       	 memset(er_buf,0x00,sizeof(er_buf));
		 DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
		 sprintf(er_buf,"In db_get_fg01_gui_list ,ST1:%d,ST2:%d_1",DB_MsgSubtype1,DB_MsgSubtype2);
		 strcat(er_buf,ErrorMsg);
		 Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
		 return DB_rcode;

      }
      db_to_fg01(&Fg01_List->FG01_record[temp]);
      sprintf( Fg01_List->num_returned, "%d", (temp+1) );
   }

   EXEC SQL CLOSE fg01_cursor3;

   return PTEMSG_OK;

sql_error:
   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   memset(er_buf,0x00,sizeof(er_buf));
	DB_rcode = dbcommon_oracle_to_pte_rcode( SQLCODE, ErrorMsg ) ;
	sprintf(er_buf,"In db_get_fg01_gui_list ,ST1:%d,ST2:%d_2",DB_MsgSubtype1,DB_MsgSubtype2);
	strcat(er_buf,ErrorMsg);
	Log_Db_Statics_And_Oracle_Db_Error_To_File(er_buf);
	return DB_rcode;

}

